{"stats":{"totalMutantsCount":163,"killedCount":148,"notCoveredCount":4,"escapedCount":10,"errorCount":0,"syntaxErrorCount":0,"skippedCount":0,"timeOutCount":1,"msi":91.41,"mutationCodeCoverage":97.55,"coveredCodeMsi":93.71},"escaped":[{"mutator":{"mutatorName":"UnwrapArrayFilter","originalSourceCode":"<?php\n\nnamespace Fido\\PHPXray;\n\nclass HttpSegment extends RemoteSegment\n{\n    use HttpTrait;\n    \/**\n     * @inheritdoc\n     *\/\n    public function jsonSerialize() : array\n    {\n        $data = parent::jsonSerialize();\n        $data['http'] = $this->serialiseHttpData();\n        return array_filter($data);\n    }\n}","mutatedSourceCode":"<?php\n\nnamespace Fido\\PHPXray;\n\nclass HttpSegment extends RemoteSegment\n{\n    use HttpTrait;\n    \/**\n     * @inheritdoc\n     *\/\n    public function jsonSerialize() : array\n    {\n        $data = parent::jsonSerialize();\n        $data['http'] = $this->serialiseHttpData();\n        return $data;\n    }\n}","originalFilePath":"\/home\/ranpafin\/php-xray\/src\/HttpSegment.php","originalStartLine":18},"diff":"--- Original\n+++ New\n@@ @@\n     {\n         $data = parent::jsonSerialize();\n         $data['http'] = $this->serialiseHttpData();\n-        return array_filter($data);\n+        return $data;\n     }\n }","processOutput":"PHPUnit 9.5.10 by Sebastian Bergmann and contributors.\n\nRuntime:       PHP 8.0.13\nConfiguration: \/tmp\/tmp-folder\/infection\/phpunitConfiguration.6ee5a478367a2f1aa2eca7f1d6886dc7.infection.xml\n\n.                                                                   1 \/ 1 (100%)\n\nTime: 00:00.004, Memory: 8.00 MB\n\nOK (1 test, 7 assertions)"},{"mutator":{"mutatorName":"CastBool","originalSourceCode":"<?php\n\nnamespace Fido\\PHPXray;\n\nuse JsonSerializable;\nuse Fido\\PHPXray\\Submission\\SegmentSubmitter;\nclass Segment implements JsonSerializable\n{\n    protected string $id;\n    protected ?string $parentId = null;\n    protected string $traceId;\n    protected ?string $name = null;\n    protected float $startTime;\n    protected float $endTime;\n    \/** @var Segment[] *\/\n    protected array $subsegments = [];\n    protected bool $error = false;\n    protected bool $fault = false;\n    protected bool $sampled = false;\n    protected bool $independent = false;\n    \/** @var array<string, mixed> *\/\n    private array $annotations;\n    \/** @var array<string, mixed> *\/\n    private array $metadata;\n    private int $lastOpenSegment = 0;\n    \/**\n     * @throws \\Exception if an appropriate source of randomness cannot be found.\n     *\/\n    public function __construct()\n    {\n        $this->id = bin2hex(random_bytes(8));\n    }\n    public function setTraceHeader(string $traceHeader = null) : self\n    {\n        if (is_null($traceHeader)) {\n            return $this;\n        }\n        $parts = explode(';', $traceHeader);\n        $variables = array_map(function ($str) : array {\n            return explode('=', $str);\n        }, $parts);\n        $variables = array_column($variables, 1, 0);\n        if (isset($variables['Root'])) {\n            $this->setTraceId($variables['Root']);\n        }\n        if (isset($variables['Sampled'])) {\n            $this->setSampled((bool) $variables['Sampled'] ?? false);\n        }\n        if (isset($variables['Parent'])) {\n            $this->setParentId($variables['Parent'] ?? null);\n        }\n        return $this;\n    }\n    public function begin() : self\n    {\n        $this->startTime = microtime(true);\n        return $this;\n    }\n    public function end() : self\n    {\n        $this->endTime = microtime(true);\n        return $this;\n    }\n    public function setName(string $name) : self\n    {\n        $this->name = $name;\n        return $this;\n    }\n    public function setError(bool $error) : self\n    {\n        $this->error = $error;\n        return $this;\n    }\n    public function setFault(bool $fault) : self\n    {\n        $this->fault = $fault;\n        return $this;\n    }\n    public function addSubsegment(Segment $subsegment) : self\n    {\n        if (!$this->isOpen()) {\n            return $this;\n        }\n        $this->subsegments[] = $subsegment;\n        $subsegment->setSampled($this->isSampled());\n        return $this;\n    }\n    public function submit(SegmentSubmitter $submitter) : void\n    {\n        if (!$this->isSampled()) {\n            return;\n        }\n        $submitter->submitSegment($this);\n    }\n    public function isSampled() : bool\n    {\n        return $this->sampled;\n    }\n    public function setSampled(bool $sampled) : self\n    {\n        $this->sampled = $sampled;\n        return $this;\n    }\n    public function getId() : string\n    {\n        return $this->id;\n    }\n    public function setParentId(?string $parentId) : self\n    {\n        $this->parentId = $parentId;\n        return $this;\n    }\n    public function setTraceId(string $traceId) : self\n    {\n        $this->traceId = $traceId;\n        return $this;\n    }\n    public function getTraceId() : string\n    {\n        return $this->traceId;\n    }\n    public function isOpen() : bool\n    {\n        return isset($this->startTime) && !isset($this->endTime);\n    }\n    public function setIndependent(bool $independent) : self\n    {\n        $this->independent = $independent;\n        return $this;\n    }\n    public function addAnnotation(string $key, string $value) : self\n    {\n        $this->annotations[$key] = $value;\n        return $this;\n    }\n    public function addMetadata(string $key, mixed $value) : self\n    {\n        $this->metadata[$key] = $value;\n        return $this;\n    }\n    public function getCurrentSegment() : self\n    {\n        for ($max = count($this->subsegments); $this->lastOpenSegment < $max; $this->lastOpenSegment++) {\n            if ($this->subsegments[$this->lastOpenSegment]->isOpen()) {\n                return $this->subsegments[$this->lastOpenSegment]->getCurrentSegment();\n            }\n        }\n        return $this;\n    }\n    \/**\n     * @inheritDoc\n     * @return array<string, mixed>\n     *\/\n    public function jsonSerialize() : array\n    {\n        return array_filter(['id' => $this->id, 'parent_id' => $this->parentId, 'trace_id' => $this->traceId ?? null, 'name' => $this->name, 'start_time' => $this->startTime ?? null, 'end_time' => $this->endTime ?? null, 'subsegments' => $this->subsegments ?? null ?: null, 'type' => $this->independent ? 'subsegment' : null, 'fault' => $this->fault ?? null, 'error' => $this->error ?? null, 'annotations' => $this->annotations ?? null ?: null, 'metadata' => $this->metadata ?? null ?: null]);\n    }\n}","mutatedSourceCode":"<?php\n\nnamespace Fido\\PHPXray;\n\nuse JsonSerializable;\nuse Fido\\PHPXray\\Submission\\SegmentSubmitter;\nclass Segment implements JsonSerializable\n{\n    protected string $id;\n    protected ?string $parentId = null;\n    protected string $traceId;\n    protected ?string $name = null;\n    protected float $startTime;\n    protected float $endTime;\n    \/** @var Segment[] *\/\n    protected array $subsegments = [];\n    protected bool $error = false;\n    protected bool $fault = false;\n    protected bool $sampled = false;\n    protected bool $independent = false;\n    \/** @var array<string, mixed> *\/\n    private array $annotations;\n    \/** @var array<string, mixed> *\/\n    private array $metadata;\n    private int $lastOpenSegment = 0;\n    \/**\n     * @throws \\Exception if an appropriate source of randomness cannot be found.\n     *\/\n    public function __construct()\n    {\n        $this->id = bin2hex(random_bytes(8));\n    }\n    public function setTraceHeader(string $traceHeader = null) : self\n    {\n        if (is_null($traceHeader)) {\n            return $this;\n        }\n        $parts = explode(';', $traceHeader);\n        $variables = array_map(function ($str) : array {\n            return explode('=', $str);\n        }, $parts);\n        $variables = array_column($variables, 1, 0);\n        if (isset($variables['Root'])) {\n            $this->setTraceId($variables['Root']);\n        }\n        if (isset($variables['Sampled'])) {\n            $this->setSampled($variables['Sampled'] ?? false);\n        }\n        if (isset($variables['Parent'])) {\n            $this->setParentId($variables['Parent'] ?? null);\n        }\n        return $this;\n    }\n    public function begin() : self\n    {\n        $this->startTime = microtime(true);\n        return $this;\n    }\n    public function end() : self\n    {\n        $this->endTime = microtime(true);\n        return $this;\n    }\n    public function setName(string $name) : self\n    {\n        $this->name = $name;\n        return $this;\n    }\n    public function setError(bool $error) : self\n    {\n        $this->error = $error;\n        return $this;\n    }\n    public function setFault(bool $fault) : self\n    {\n        $this->fault = $fault;\n        return $this;\n    }\n    public function addSubsegment(Segment $subsegment) : self\n    {\n        if (!$this->isOpen()) {\n            return $this;\n        }\n        $this->subsegments[] = $subsegment;\n        $subsegment->setSampled($this->isSampled());\n        return $this;\n    }\n    public function submit(SegmentSubmitter $submitter) : void\n    {\n        if (!$this->isSampled()) {\n            return;\n        }\n        $submitter->submitSegment($this);\n    }\n    public function isSampled() : bool\n    {\n        return $this->sampled;\n    }\n    public function setSampled(bool $sampled) : self\n    {\n        $this->sampled = $sampled;\n        return $this;\n    }\n    public function getId() : string\n    {\n        return $this->id;\n    }\n    public function setParentId(?string $parentId) : self\n    {\n        $this->parentId = $parentId;\n        return $this;\n    }\n    public function setTraceId(string $traceId) : self\n    {\n        $this->traceId = $traceId;\n        return $this;\n    }\n    public function getTraceId() : string\n    {\n        return $this->traceId;\n    }\n    public function isOpen() : bool\n    {\n        return isset($this->startTime) && !isset($this->endTime);\n    }\n    public function setIndependent(bool $independent) : self\n    {\n        $this->independent = $independent;\n        return $this;\n    }\n    public function addAnnotation(string $key, string $value) : self\n    {\n        $this->annotations[$key] = $value;\n        return $this;\n    }\n    public function addMetadata(string $key, mixed $value) : self\n    {\n        $this->metadata[$key] = $value;\n        return $this;\n    }\n    public function getCurrentSegment() : self\n    {\n        for ($max = count($this->subsegments); $this->lastOpenSegment < $max; $this->lastOpenSegment++) {\n            if ($this->subsegments[$this->lastOpenSegment]->isOpen()) {\n                return $this->subsegments[$this->lastOpenSegment]->getCurrentSegment();\n            }\n        }\n        return $this;\n    }\n    \/**\n     * @inheritDoc\n     * @return array<string, mixed>\n     *\/\n    public function jsonSerialize() : array\n    {\n        return array_filter(['id' => $this->id, 'parent_id' => $this->parentId, 'trace_id' => $this->traceId ?? null, 'name' => $this->name, 'start_time' => $this->startTime ?? null, 'end_time' => $this->endTime ?? null, 'subsegments' => $this->subsegments ?? null ?: null, 'type' => $this->independent ? 'subsegment' : null, 'fault' => $this->fault ?? null, 'error' => $this->error ?? null, 'annotations' => $this->annotations ?? null ?: null, 'metadata' => $this->metadata ?? null ?: null]);\n    }\n}","originalFilePath":"\/home\/ranpafin\/php-xray\/src\/Segment.php","originalStartLine":54},"diff":"--- Original\n+++ New\n@@ @@\n             $this->setTraceId($variables['Root']);\n         }\n         if (isset($variables['Sampled'])) {\n-            $this->setSampled((bool) $variables['Sampled'] ?? false);\n+            $this->setSampled($variables['Sampled'] ?? false);\n         }\n         if (isset($variables['Parent'])) {\n             $this->setParentId($variables['Parent'] ?? null);","processOutput":"PHPUnit 9.5.10 by Sebastian Bergmann and contributors.\n\nRuntime:       PHP 8.0.13\nConfiguration: \/tmp\/tmp-folder\/infection\/phpunitConfiguration.061cb6521222e7db76c0d08ab75a368c.infection.xml\n\n.......                                                             7 \/ 7 (100%)\n\nTime: 00:00.005, Memory: 8.00 MB\n\nOK (7 tests, 21 assertions)"},{"mutator":{"mutatorName":"FalseValue","originalSourceCode":"<?php\n\nnamespace Fido\\PHPXray;\n\nuse JsonSerializable;\nuse Fido\\PHPXray\\Submission\\SegmentSubmitter;\nclass Segment implements JsonSerializable\n{\n    protected string $id;\n    protected ?string $parentId = null;\n    protected string $traceId;\n    protected ?string $name = null;\n    protected float $startTime;\n    protected float $endTime;\n    \/** @var Segment[] *\/\n    protected array $subsegments = [];\n    protected bool $error = false;\n    protected bool $fault = false;\n    protected bool $sampled = false;\n    protected bool $independent = false;\n    \/** @var array<string, mixed> *\/\n    private array $annotations;\n    \/** @var array<string, mixed> *\/\n    private array $metadata;\n    private int $lastOpenSegment = 0;\n    \/**\n     * @throws \\Exception if an appropriate source of randomness cannot be found.\n     *\/\n    public function __construct()\n    {\n        $this->id = bin2hex(random_bytes(8));\n    }\n    public function setTraceHeader(string $traceHeader = null) : self\n    {\n        if (is_null($traceHeader)) {\n            return $this;\n        }\n        $parts = explode(';', $traceHeader);\n        $variables = array_map(function ($str) : array {\n            return explode('=', $str);\n        }, $parts);\n        $variables = array_column($variables, 1, 0);\n        if (isset($variables['Root'])) {\n            $this->setTraceId($variables['Root']);\n        }\n        if (isset($variables['Sampled'])) {\n            $this->setSampled((bool) $variables['Sampled'] ?? false);\n        }\n        if (isset($variables['Parent'])) {\n            $this->setParentId($variables['Parent'] ?? null);\n        }\n        return $this;\n    }\n    public function begin() : self\n    {\n        $this->startTime = microtime(true);\n        return $this;\n    }\n    public function end() : self\n    {\n        $this->endTime = microtime(true);\n        return $this;\n    }\n    public function setName(string $name) : self\n    {\n        $this->name = $name;\n        return $this;\n    }\n    public function setError(bool $error) : self\n    {\n        $this->error = $error;\n        return $this;\n    }\n    public function setFault(bool $fault) : self\n    {\n        $this->fault = $fault;\n        return $this;\n    }\n    public function addSubsegment(Segment $subsegment) : self\n    {\n        if (!$this->isOpen()) {\n            return $this;\n        }\n        $this->subsegments[] = $subsegment;\n        $subsegment->setSampled($this->isSampled());\n        return $this;\n    }\n    public function submit(SegmentSubmitter $submitter) : void\n    {\n        if (!$this->isSampled()) {\n            return;\n        }\n        $submitter->submitSegment($this);\n    }\n    public function isSampled() : bool\n    {\n        return $this->sampled;\n    }\n    public function setSampled(bool $sampled) : self\n    {\n        $this->sampled = $sampled;\n        return $this;\n    }\n    public function getId() : string\n    {\n        return $this->id;\n    }\n    public function setParentId(?string $parentId) : self\n    {\n        $this->parentId = $parentId;\n        return $this;\n    }\n    public function setTraceId(string $traceId) : self\n    {\n        $this->traceId = $traceId;\n        return $this;\n    }\n    public function getTraceId() : string\n    {\n        return $this->traceId;\n    }\n    public function isOpen() : bool\n    {\n        return isset($this->startTime) && !isset($this->endTime);\n    }\n    public function setIndependent(bool $independent) : self\n    {\n        $this->independent = $independent;\n        return $this;\n    }\n    public function addAnnotation(string $key, string $value) : self\n    {\n        $this->annotations[$key] = $value;\n        return $this;\n    }\n    public function addMetadata(string $key, mixed $value) : self\n    {\n        $this->metadata[$key] = $value;\n        return $this;\n    }\n    public function getCurrentSegment() : self\n    {\n        for ($max = count($this->subsegments); $this->lastOpenSegment < $max; $this->lastOpenSegment++) {\n            if ($this->subsegments[$this->lastOpenSegment]->isOpen()) {\n                return $this->subsegments[$this->lastOpenSegment]->getCurrentSegment();\n            }\n        }\n        return $this;\n    }\n    \/**\n     * @inheritDoc\n     * @return array<string, mixed>\n     *\/\n    public function jsonSerialize() : array\n    {\n        return array_filter(['id' => $this->id, 'parent_id' => $this->parentId, 'trace_id' => $this->traceId ?? null, 'name' => $this->name, 'start_time' => $this->startTime ?? null, 'end_time' => $this->endTime ?? null, 'subsegments' => $this->subsegments ?? null ?: null, 'type' => $this->independent ? 'subsegment' : null, 'fault' => $this->fault ?? null, 'error' => $this->error ?? null, 'annotations' => $this->annotations ?? null ?: null, 'metadata' => $this->metadata ?? null ?: null]);\n    }\n}","mutatedSourceCode":"<?php\n\nnamespace Fido\\PHPXray;\n\nuse JsonSerializable;\nuse Fido\\PHPXray\\Submission\\SegmentSubmitter;\nclass Segment implements JsonSerializable\n{\n    protected string $id;\n    protected ?string $parentId = null;\n    protected string $traceId;\n    protected ?string $name = null;\n    protected float $startTime;\n    protected float $endTime;\n    \/** @var Segment[] *\/\n    protected array $subsegments = [];\n    protected bool $error = false;\n    protected bool $fault = false;\n    protected bool $sampled = false;\n    protected bool $independent = false;\n    \/** @var array<string, mixed> *\/\n    private array $annotations;\n    \/** @var array<string, mixed> *\/\n    private array $metadata;\n    private int $lastOpenSegment = 0;\n    \/**\n     * @throws \\Exception if an appropriate source of randomness cannot be found.\n     *\/\n    public function __construct()\n    {\n        $this->id = bin2hex(random_bytes(8));\n    }\n    public function setTraceHeader(string $traceHeader = null) : self\n    {\n        if (is_null($traceHeader)) {\n            return $this;\n        }\n        $parts = explode(';', $traceHeader);\n        $variables = array_map(function ($str) : array {\n            return explode('=', $str);\n        }, $parts);\n        $variables = array_column($variables, 1, 0);\n        if (isset($variables['Root'])) {\n            $this->setTraceId($variables['Root']);\n        }\n        if (isset($variables['Sampled'])) {\n            $this->setSampled((bool) $variables['Sampled'] ?? true);\n        }\n        if (isset($variables['Parent'])) {\n            $this->setParentId($variables['Parent'] ?? null);\n        }\n        return $this;\n    }\n    public function begin() : self\n    {\n        $this->startTime = microtime(true);\n        return $this;\n    }\n    public function end() : self\n    {\n        $this->endTime = microtime(true);\n        return $this;\n    }\n    public function setName(string $name) : self\n    {\n        $this->name = $name;\n        return $this;\n    }\n    public function setError(bool $error) : self\n    {\n        $this->error = $error;\n        return $this;\n    }\n    public function setFault(bool $fault) : self\n    {\n        $this->fault = $fault;\n        return $this;\n    }\n    public function addSubsegment(Segment $subsegment) : self\n    {\n        if (!$this->isOpen()) {\n            return $this;\n        }\n        $this->subsegments[] = $subsegment;\n        $subsegment->setSampled($this->isSampled());\n        return $this;\n    }\n    public function submit(SegmentSubmitter $submitter) : void\n    {\n        if (!$this->isSampled()) {\n            return;\n        }\n        $submitter->submitSegment($this);\n    }\n    public function isSampled() : bool\n    {\n        return $this->sampled;\n    }\n    public function setSampled(bool $sampled) : self\n    {\n        $this->sampled = $sampled;\n        return $this;\n    }\n    public function getId() : string\n    {\n        return $this->id;\n    }\n    public function setParentId(?string $parentId) : self\n    {\n        $this->parentId = $parentId;\n        return $this;\n    }\n    public function setTraceId(string $traceId) : self\n    {\n        $this->traceId = $traceId;\n        return $this;\n    }\n    public function getTraceId() : string\n    {\n        return $this->traceId;\n    }\n    public function isOpen() : bool\n    {\n        return isset($this->startTime) && !isset($this->endTime);\n    }\n    public function setIndependent(bool $independent) : self\n    {\n        $this->independent = $independent;\n        return $this;\n    }\n    public function addAnnotation(string $key, string $value) : self\n    {\n        $this->annotations[$key] = $value;\n        return $this;\n    }\n    public function addMetadata(string $key, mixed $value) : self\n    {\n        $this->metadata[$key] = $value;\n        return $this;\n    }\n    public function getCurrentSegment() : self\n    {\n        for ($max = count($this->subsegments); $this->lastOpenSegment < $max; $this->lastOpenSegment++) {\n            if ($this->subsegments[$this->lastOpenSegment]->isOpen()) {\n                return $this->subsegments[$this->lastOpenSegment]->getCurrentSegment();\n            }\n        }\n        return $this;\n    }\n    \/**\n     * @inheritDoc\n     * @return array<string, mixed>\n     *\/\n    public function jsonSerialize() : array\n    {\n        return array_filter(['id' => $this->id, 'parent_id' => $this->parentId, 'trace_id' => $this->traceId ?? null, 'name' => $this->name, 'start_time' => $this->startTime ?? null, 'end_time' => $this->endTime ?? null, 'subsegments' => $this->subsegments ?? null ?: null, 'type' => $this->independent ? 'subsegment' : null, 'fault' => $this->fault ?? null, 'error' => $this->error ?? null, 'annotations' => $this->annotations ?? null ?: null, 'metadata' => $this->metadata ?? null ?: null]);\n    }\n}","originalFilePath":"\/home\/ranpafin\/php-xray\/src\/Segment.php","originalStartLine":54},"diff":"--- Original\n+++ New\n@@ @@\n             $this->setTraceId($variables['Root']);\n         }\n         if (isset($variables['Sampled'])) {\n-            $this->setSampled((bool) $variables['Sampled'] ?? false);\n+            $this->setSampled((bool) $variables['Sampled'] ?? true);\n         }\n         if (isset($variables['Parent'])) {\n             $this->setParentId($variables['Parent'] ?? null);","processOutput":"PHPUnit 9.5.10 by Sebastian Bergmann and contributors.\n\nRuntime:       PHP 8.0.13\nConfiguration: \/tmp\/tmp-folder\/infection\/phpunitConfiguration.1a29383f0b7f02207e6ed2b29ffb2e3b.infection.xml\n\n.......                                                             7 \/ 7 (100%)\n\nTime: 00:00.004, Memory: 8.00 MB\n\nOK (7 tests, 21 assertions)"},{"mutator":{"mutatorName":"Coalesce","originalSourceCode":"<?php\n\nnamespace Fido\\PHPXray;\n\nuse JsonSerializable;\nuse Fido\\PHPXray\\Submission\\SegmentSubmitter;\nclass Segment implements JsonSerializable\n{\n    protected string $id;\n    protected ?string $parentId = null;\n    protected string $traceId;\n    protected ?string $name = null;\n    protected float $startTime;\n    protected float $endTime;\n    \/** @var Segment[] *\/\n    protected array $subsegments = [];\n    protected bool $error = false;\n    protected bool $fault = false;\n    protected bool $sampled = false;\n    protected bool $independent = false;\n    \/** @var array<string, mixed> *\/\n    private array $annotations;\n    \/** @var array<string, mixed> *\/\n    private array $metadata;\n    private int $lastOpenSegment = 0;\n    \/**\n     * @throws \\Exception if an appropriate source of randomness cannot be found.\n     *\/\n    public function __construct()\n    {\n        $this->id = bin2hex(random_bytes(8));\n    }\n    public function setTraceHeader(string $traceHeader = null) : self\n    {\n        if (is_null($traceHeader)) {\n            return $this;\n        }\n        $parts = explode(';', $traceHeader);\n        $variables = array_map(function ($str) : array {\n            return explode('=', $str);\n        }, $parts);\n        $variables = array_column($variables, 1, 0);\n        if (isset($variables['Root'])) {\n            $this->setTraceId($variables['Root']);\n        }\n        if (isset($variables['Sampled'])) {\n            $this->setSampled((bool) $variables['Sampled'] ?? false);\n        }\n        if (isset($variables['Parent'])) {\n            $this->setParentId($variables['Parent'] ?? null);\n        }\n        return $this;\n    }\n    public function begin() : self\n    {\n        $this->startTime = microtime(true);\n        return $this;\n    }\n    public function end() : self\n    {\n        $this->endTime = microtime(true);\n        return $this;\n    }\n    public function setName(string $name) : self\n    {\n        $this->name = $name;\n        return $this;\n    }\n    public function setError(bool $error) : self\n    {\n        $this->error = $error;\n        return $this;\n    }\n    public function setFault(bool $fault) : self\n    {\n        $this->fault = $fault;\n        return $this;\n    }\n    public function addSubsegment(Segment $subsegment) : self\n    {\n        if (!$this->isOpen()) {\n            return $this;\n        }\n        $this->subsegments[] = $subsegment;\n        $subsegment->setSampled($this->isSampled());\n        return $this;\n    }\n    public function submit(SegmentSubmitter $submitter) : void\n    {\n        if (!$this->isSampled()) {\n            return;\n        }\n        $submitter->submitSegment($this);\n    }\n    public function isSampled() : bool\n    {\n        return $this->sampled;\n    }\n    public function setSampled(bool $sampled) : self\n    {\n        $this->sampled = $sampled;\n        return $this;\n    }\n    public function getId() : string\n    {\n        return $this->id;\n    }\n    public function setParentId(?string $parentId) : self\n    {\n        $this->parentId = $parentId;\n        return $this;\n    }\n    public function setTraceId(string $traceId) : self\n    {\n        $this->traceId = $traceId;\n        return $this;\n    }\n    public function getTraceId() : string\n    {\n        return $this->traceId;\n    }\n    public function isOpen() : bool\n    {\n        return isset($this->startTime) && !isset($this->endTime);\n    }\n    public function setIndependent(bool $independent) : self\n    {\n        $this->independent = $independent;\n        return $this;\n    }\n    public function addAnnotation(string $key, string $value) : self\n    {\n        $this->annotations[$key] = $value;\n        return $this;\n    }\n    public function addMetadata(string $key, mixed $value) : self\n    {\n        $this->metadata[$key] = $value;\n        return $this;\n    }\n    public function getCurrentSegment() : self\n    {\n        for ($max = count($this->subsegments); $this->lastOpenSegment < $max; $this->lastOpenSegment++) {\n            if ($this->subsegments[$this->lastOpenSegment]->isOpen()) {\n                return $this->subsegments[$this->lastOpenSegment]->getCurrentSegment();\n            }\n        }\n        return $this;\n    }\n    \/**\n     * @inheritDoc\n     * @return array<string, mixed>\n     *\/\n    public function jsonSerialize() : array\n    {\n        return array_filter(['id' => $this->id, 'parent_id' => $this->parentId, 'trace_id' => $this->traceId ?? null, 'name' => $this->name, 'start_time' => $this->startTime ?? null, 'end_time' => $this->endTime ?? null, 'subsegments' => $this->subsegments ?? null ?: null, 'type' => $this->independent ? 'subsegment' : null, 'fault' => $this->fault ?? null, 'error' => $this->error ?? null, 'annotations' => $this->annotations ?? null ?: null, 'metadata' => $this->metadata ?? null ?: null]);\n    }\n}","mutatedSourceCode":"<?php\n\nnamespace Fido\\PHPXray;\n\nuse JsonSerializable;\nuse Fido\\PHPXray\\Submission\\SegmentSubmitter;\nclass Segment implements JsonSerializable\n{\n    protected string $id;\n    protected ?string $parentId = null;\n    protected string $traceId;\n    protected ?string $name = null;\n    protected float $startTime;\n    protected float $endTime;\n    \/** @var Segment[] *\/\n    protected array $subsegments = [];\n    protected bool $error = false;\n    protected bool $fault = false;\n    protected bool $sampled = false;\n    protected bool $independent = false;\n    \/** @var array<string, mixed> *\/\n    private array $annotations;\n    \/** @var array<string, mixed> *\/\n    private array $metadata;\n    private int $lastOpenSegment = 0;\n    \/**\n     * @throws \\Exception if an appropriate source of randomness cannot be found.\n     *\/\n    public function __construct()\n    {\n        $this->id = bin2hex(random_bytes(8));\n    }\n    public function setTraceHeader(string $traceHeader = null) : self\n    {\n        if (is_null($traceHeader)) {\n            return $this;\n        }\n        $parts = explode(';', $traceHeader);\n        $variables = array_map(function ($str) : array {\n            return explode('=', $str);\n        }, $parts);\n        $variables = array_column($variables, 1, 0);\n        if (isset($variables['Root'])) {\n            $this->setTraceId($variables['Root']);\n        }\n        if (isset($variables['Sampled'])) {\n            $this->setSampled((bool) $variables['Sampled'] ?? false);\n        }\n        if (isset($variables['Parent'])) {\n            $this->setParentId(null ?? $variables['Parent']);\n        }\n        return $this;\n    }\n    public function begin() : self\n    {\n        $this->startTime = microtime(true);\n        return $this;\n    }\n    public function end() : self\n    {\n        $this->endTime = microtime(true);\n        return $this;\n    }\n    public function setName(string $name) : self\n    {\n        $this->name = $name;\n        return $this;\n    }\n    public function setError(bool $error) : self\n    {\n        $this->error = $error;\n        return $this;\n    }\n    public function setFault(bool $fault) : self\n    {\n        $this->fault = $fault;\n        return $this;\n    }\n    public function addSubsegment(Segment $subsegment) : self\n    {\n        if (!$this->isOpen()) {\n            return $this;\n        }\n        $this->subsegments[] = $subsegment;\n        $subsegment->setSampled($this->isSampled());\n        return $this;\n    }\n    public function submit(SegmentSubmitter $submitter) : void\n    {\n        if (!$this->isSampled()) {\n            return;\n        }\n        $submitter->submitSegment($this);\n    }\n    public function isSampled() : bool\n    {\n        return $this->sampled;\n    }\n    public function setSampled(bool $sampled) : self\n    {\n        $this->sampled = $sampled;\n        return $this;\n    }\n    public function getId() : string\n    {\n        return $this->id;\n    }\n    public function setParentId(?string $parentId) : self\n    {\n        $this->parentId = $parentId;\n        return $this;\n    }\n    public function setTraceId(string $traceId) : self\n    {\n        $this->traceId = $traceId;\n        return $this;\n    }\n    public function getTraceId() : string\n    {\n        return $this->traceId;\n    }\n    public function isOpen() : bool\n    {\n        return isset($this->startTime) && !isset($this->endTime);\n    }\n    public function setIndependent(bool $independent) : self\n    {\n        $this->independent = $independent;\n        return $this;\n    }\n    public function addAnnotation(string $key, string $value) : self\n    {\n        $this->annotations[$key] = $value;\n        return $this;\n    }\n    public function addMetadata(string $key, mixed $value) : self\n    {\n        $this->metadata[$key] = $value;\n        return $this;\n    }\n    public function getCurrentSegment() : self\n    {\n        for ($max = count($this->subsegments); $this->lastOpenSegment < $max; $this->lastOpenSegment++) {\n            if ($this->subsegments[$this->lastOpenSegment]->isOpen()) {\n                return $this->subsegments[$this->lastOpenSegment]->getCurrentSegment();\n            }\n        }\n        return $this;\n    }\n    \/**\n     * @inheritDoc\n     * @return array<string, mixed>\n     *\/\n    public function jsonSerialize() : array\n    {\n        return array_filter(['id' => $this->id, 'parent_id' => $this->parentId, 'trace_id' => $this->traceId ?? null, 'name' => $this->name, 'start_time' => $this->startTime ?? null, 'end_time' => $this->endTime ?? null, 'subsegments' => $this->subsegments ?? null ?: null, 'type' => $this->independent ? 'subsegment' : null, 'fault' => $this->fault ?? null, 'error' => $this->error ?? null, 'annotations' => $this->annotations ?? null ?: null, 'metadata' => $this->metadata ?? null ?: null]);\n    }\n}","originalFilePath":"\/home\/ranpafin\/php-xray\/src\/Segment.php","originalStartLine":57},"diff":"--- Original\n+++ New\n@@ @@\n             $this->setSampled((bool) $variables['Sampled'] ?? false);\n         }\n         if (isset($variables['Parent'])) {\n-            $this->setParentId($variables['Parent'] ?? null);\n+            $this->setParentId(null ?? $variables['Parent']);\n         }\n         return $this;\n     }","processOutput":"PHPUnit 9.5.10 by Sebastian Bergmann and contributors.\n\nRuntime:       PHP 8.0.13\nConfiguration: \/tmp\/tmp-folder\/infection\/phpunitConfiguration.d57b96980808065eaac403d93b339f44.infection.xml\n\n.......                                                             7 \/ 7 (100%)\n\nTime: 00:00.006, Memory: 8.00 MB\n\nOK (7 tests, 21 assertions)"},{"mutator":{"mutatorName":"DecrementInteger","originalSourceCode":"<?php\n\nnamespace Fido\\PHPXray;\n\nuse Exception;\nclass Trace extends Segment\n{\n    use HttpTrait;\n    private static self $instance;\n    private string $serviceVersion;\n    private string $user;\n    public static function getInstance() : self\n    {\n        if (!isset(self::$instance)) {\n            self::$instance = new self();\n        }\n        return self::$instance;\n    }\n    public function setServiceVersion(string $serviceVersion) : self\n    {\n        $this->serviceVersion = $serviceVersion;\n        return $this;\n    }\n    public function setUser(string $user) : self\n    {\n        $this->user = $user;\n        return $this;\n    }\n    public function setClientIpAddress(string $clientIpAddress) : self\n    {\n        $this->clientIpAddress = $clientIpAddress;\n        return $this;\n    }\n    public function setUserAgent(string $userAgent) : self\n    {\n        $this->userAgent = $userAgent;\n        return $this;\n    }\n    \/**\n     * @throws Exception\n     *\/\n    public function begin(int $samplePercentage = 10) : Segment\n    {\n        parent::begin();\n        if (!isset($this->traceId)) {\n            $this->generateTraceId();\n        }\n        if (!$this->isSampled()) {\n            $this->sampled = random_int(0, 99) < $samplePercentage;\n        }\n        return $this;\n    }\n    \/**\n     * @inheritdoc\n     *\/\n    public function jsonSerialize() : array\n    {\n        $data = parent::jsonSerialize();\n        $data['http'] = $this->serialiseHttpData();\n        $data['service'] = empty($this->serviceVersion) ? null : ['version' => $this->serviceVersion];\n        $data['user'] = $this->user ?? null;\n        return array_filter($data);\n    }\n    \/**\n     * @throws Exception if an appropriate source of randomness cannot be found.\n     *\/\n    private function generateTraceId() : void\n    {\n        $startHex = dechex((int) $this->startTime);\n        $uuid = bin2hex(random_bytes(12));\n        $this->setTraceId(\"1-{$startHex}-{$uuid}\");\n    }\n}","mutatedSourceCode":"<?php\n\nnamespace Fido\\PHPXray;\n\nuse Exception;\nclass Trace extends Segment\n{\n    use HttpTrait;\n    private static self $instance;\n    private string $serviceVersion;\n    private string $user;\n    public static function getInstance() : self\n    {\n        if (!isset(self::$instance)) {\n            self::$instance = new self();\n        }\n        return self::$instance;\n    }\n    public function setServiceVersion(string $serviceVersion) : self\n    {\n        $this->serviceVersion = $serviceVersion;\n        return $this;\n    }\n    public function setUser(string $user) : self\n    {\n        $this->user = $user;\n        return $this;\n    }\n    public function setClientIpAddress(string $clientIpAddress) : self\n    {\n        $this->clientIpAddress = $clientIpAddress;\n        return $this;\n    }\n    public function setUserAgent(string $userAgent) : self\n    {\n        $this->userAgent = $userAgent;\n        return $this;\n    }\n    \/**\n     * @throws Exception\n     *\/\n    public function begin(int $samplePercentage = 10) : Segment\n    {\n        parent::begin();\n        if (!isset($this->traceId)) {\n            $this->generateTraceId();\n        }\n        if (!$this->isSampled()) {\n            $this->sampled = random_int(-1, 99) < $samplePercentage;\n        }\n        return $this;\n    }\n    \/**\n     * @inheritdoc\n     *\/\n    public function jsonSerialize() : array\n    {\n        $data = parent::jsonSerialize();\n        $data['http'] = $this->serialiseHttpData();\n        $data['service'] = empty($this->serviceVersion) ? null : ['version' => $this->serviceVersion];\n        $data['user'] = $this->user ?? null;\n        return array_filter($data);\n    }\n    \/**\n     * @throws Exception if an appropriate source of randomness cannot be found.\n     *\/\n    private function generateTraceId() : void\n    {\n        $startHex = dechex((int) $this->startTime);\n        $uuid = bin2hex(random_bytes(12));\n        $this->setTraceId(\"1-{$startHex}-{$uuid}\");\n    }\n}","originalFilePath":"\/home\/ranpafin\/php-xray\/src\/Trace.php","originalStartLine":64},"diff":"--- Original\n+++ New\n@@ @@\n             $this->generateTraceId();\n         }\n         if (!$this->isSampled()) {\n-            $this->sampled = random_int(0, 99) < $samplePercentage;\n+            $this->sampled = random_int(-1, 99) < $samplePercentage;\n         }\n         return $this;\n     }","processOutput":"PHPUnit 9.5.10 by Sebastian Bergmann and contributors.\n\nRuntime:       PHP 8.0.13\nConfiguration: \/tmp\/tmp-folder\/infection\/phpunitConfiguration.edae24a46f13bf4fe200cbb3c3397510.infection.xml\n\n.......                                                             7 \/ 7 (100%)\n\nTime: 00:00.005, Memory: 8.00 MB\n\nOK (7 tests, 21 assertions)"},{"mutator":{"mutatorName":"IncrementInteger","originalSourceCode":"<?php\n\nnamespace Fido\\PHPXray;\n\nuse Exception;\nclass Trace extends Segment\n{\n    use HttpTrait;\n    private static self $instance;\n    private string $serviceVersion;\n    private string $user;\n    public static function getInstance() : self\n    {\n        if (!isset(self::$instance)) {\n            self::$instance = new self();\n        }\n        return self::$instance;\n    }\n    public function setServiceVersion(string $serviceVersion) : self\n    {\n        $this->serviceVersion = $serviceVersion;\n        return $this;\n    }\n    public function setUser(string $user) : self\n    {\n        $this->user = $user;\n        return $this;\n    }\n    public function setClientIpAddress(string $clientIpAddress) : self\n    {\n        $this->clientIpAddress = $clientIpAddress;\n        return $this;\n    }\n    public function setUserAgent(string $userAgent) : self\n    {\n        $this->userAgent = $userAgent;\n        return $this;\n    }\n    \/**\n     * @throws Exception\n     *\/\n    public function begin(int $samplePercentage = 10) : Segment\n    {\n        parent::begin();\n        if (!isset($this->traceId)) {\n            $this->generateTraceId();\n        }\n        if (!$this->isSampled()) {\n            $this->sampled = random_int(0, 99) < $samplePercentage;\n        }\n        return $this;\n    }\n    \/**\n     * @inheritdoc\n     *\/\n    public function jsonSerialize() : array\n    {\n        $data = parent::jsonSerialize();\n        $data['http'] = $this->serialiseHttpData();\n        $data['service'] = empty($this->serviceVersion) ? null : ['version' => $this->serviceVersion];\n        $data['user'] = $this->user ?? null;\n        return array_filter($data);\n    }\n    \/**\n     * @throws Exception if an appropriate source of randomness cannot be found.\n     *\/\n    private function generateTraceId() : void\n    {\n        $startHex = dechex((int) $this->startTime);\n        $uuid = bin2hex(random_bytes(12));\n        $this->setTraceId(\"1-{$startHex}-{$uuid}\");\n    }\n}","mutatedSourceCode":"<?php\n\nnamespace Fido\\PHPXray;\n\nuse Exception;\nclass Trace extends Segment\n{\n    use HttpTrait;\n    private static self $instance;\n    private string $serviceVersion;\n    private string $user;\n    public static function getInstance() : self\n    {\n        if (!isset(self::$instance)) {\n            self::$instance = new self();\n        }\n        return self::$instance;\n    }\n    public function setServiceVersion(string $serviceVersion) : self\n    {\n        $this->serviceVersion = $serviceVersion;\n        return $this;\n    }\n    public function setUser(string $user) : self\n    {\n        $this->user = $user;\n        return $this;\n    }\n    public function setClientIpAddress(string $clientIpAddress) : self\n    {\n        $this->clientIpAddress = $clientIpAddress;\n        return $this;\n    }\n    public function setUserAgent(string $userAgent) : self\n    {\n        $this->userAgent = $userAgent;\n        return $this;\n    }\n    \/**\n     * @throws Exception\n     *\/\n    public function begin(int $samplePercentage = 10) : Segment\n    {\n        parent::begin();\n        if (!isset($this->traceId)) {\n            $this->generateTraceId();\n        }\n        if (!$this->isSampled()) {\n            $this->sampled = random_int(1, 99) < $samplePercentage;\n        }\n        return $this;\n    }\n    \/**\n     * @inheritdoc\n     *\/\n    public function jsonSerialize() : array\n    {\n        $data = parent::jsonSerialize();\n        $data['http'] = $this->serialiseHttpData();\n        $data['service'] = empty($this->serviceVersion) ? null : ['version' => $this->serviceVersion];\n        $data['user'] = $this->user ?? null;\n        return array_filter($data);\n    }\n    \/**\n     * @throws Exception if an appropriate source of randomness cannot be found.\n     *\/\n    private function generateTraceId() : void\n    {\n        $startHex = dechex((int) $this->startTime);\n        $uuid = bin2hex(random_bytes(12));\n        $this->setTraceId(\"1-{$startHex}-{$uuid}\");\n    }\n}","originalFilePath":"\/home\/ranpafin\/php-xray\/src\/Trace.php","originalStartLine":64},"diff":"--- Original\n+++ New\n@@ @@\n             $this->generateTraceId();\n         }\n         if (!$this->isSampled()) {\n-            $this->sampled = random_int(0, 99) < $samplePercentage;\n+            $this->sampled = random_int(1, 99) < $samplePercentage;\n         }\n         return $this;\n     }","processOutput":"PHPUnit 9.5.10 by Sebastian Bergmann and contributors.\n\nRuntime:       PHP 8.0.13\nConfiguration: \/tmp\/tmp-folder\/infection\/phpunitConfiguration.4761eb0e0a612d1b591a49c15c9d4085.infection.xml\n\n.......                                                             7 \/ 7 (100%)\n\nTime: 00:00.005, Memory: 8.00 MB\n\nOK (7 tests, 21 assertions)"},{"mutator":{"mutatorName":"DecrementInteger","originalSourceCode":"<?php\n\nnamespace Fido\\PHPXray;\n\nuse Exception;\nclass Trace extends Segment\n{\n    use HttpTrait;\n    private static self $instance;\n    private string $serviceVersion;\n    private string $user;\n    public static function getInstance() : self\n    {\n        if (!isset(self::$instance)) {\n            self::$instance = new self();\n        }\n        return self::$instance;\n    }\n    public function setServiceVersion(string $serviceVersion) : self\n    {\n        $this->serviceVersion = $serviceVersion;\n        return $this;\n    }\n    public function setUser(string $user) : self\n    {\n        $this->user = $user;\n        return $this;\n    }\n    public function setClientIpAddress(string $clientIpAddress) : self\n    {\n        $this->clientIpAddress = $clientIpAddress;\n        return $this;\n    }\n    public function setUserAgent(string $userAgent) : self\n    {\n        $this->userAgent = $userAgent;\n        return $this;\n    }\n    \/**\n     * @throws Exception\n     *\/\n    public function begin(int $samplePercentage = 10) : Segment\n    {\n        parent::begin();\n        if (!isset($this->traceId)) {\n            $this->generateTraceId();\n        }\n        if (!$this->isSampled()) {\n            $this->sampled = random_int(0, 99) < $samplePercentage;\n        }\n        return $this;\n    }\n    \/**\n     * @inheritdoc\n     *\/\n    public function jsonSerialize() : array\n    {\n        $data = parent::jsonSerialize();\n        $data['http'] = $this->serialiseHttpData();\n        $data['service'] = empty($this->serviceVersion) ? null : ['version' => $this->serviceVersion];\n        $data['user'] = $this->user ?? null;\n        return array_filter($data);\n    }\n    \/**\n     * @throws Exception if an appropriate source of randomness cannot be found.\n     *\/\n    private function generateTraceId() : void\n    {\n        $startHex = dechex((int) $this->startTime);\n        $uuid = bin2hex(random_bytes(12));\n        $this->setTraceId(\"1-{$startHex}-{$uuid}\");\n    }\n}","mutatedSourceCode":"<?php\n\nnamespace Fido\\PHPXray;\n\nuse Exception;\nclass Trace extends Segment\n{\n    use HttpTrait;\n    private static self $instance;\n    private string $serviceVersion;\n    private string $user;\n    public static function getInstance() : self\n    {\n        if (!isset(self::$instance)) {\n            self::$instance = new self();\n        }\n        return self::$instance;\n    }\n    public function setServiceVersion(string $serviceVersion) : self\n    {\n        $this->serviceVersion = $serviceVersion;\n        return $this;\n    }\n    public function setUser(string $user) : self\n    {\n        $this->user = $user;\n        return $this;\n    }\n    public function setClientIpAddress(string $clientIpAddress) : self\n    {\n        $this->clientIpAddress = $clientIpAddress;\n        return $this;\n    }\n    public function setUserAgent(string $userAgent) : self\n    {\n        $this->userAgent = $userAgent;\n        return $this;\n    }\n    \/**\n     * @throws Exception\n     *\/\n    public function begin(int $samplePercentage = 10) : Segment\n    {\n        parent::begin();\n        if (!isset($this->traceId)) {\n            $this->generateTraceId();\n        }\n        if (!$this->isSampled()) {\n            $this->sampled = random_int(0, 98) < $samplePercentage;\n        }\n        return $this;\n    }\n    \/**\n     * @inheritdoc\n     *\/\n    public function jsonSerialize() : array\n    {\n        $data = parent::jsonSerialize();\n        $data['http'] = $this->serialiseHttpData();\n        $data['service'] = empty($this->serviceVersion) ? null : ['version' => $this->serviceVersion];\n        $data['user'] = $this->user ?? null;\n        return array_filter($data);\n    }\n    \/**\n     * @throws Exception if an appropriate source of randomness cannot be found.\n     *\/\n    private function generateTraceId() : void\n    {\n        $startHex = dechex((int) $this->startTime);\n        $uuid = bin2hex(random_bytes(12));\n        $this->setTraceId(\"1-{$startHex}-{$uuid}\");\n    }\n}","originalFilePath":"\/home\/ranpafin\/php-xray\/src\/Trace.php","originalStartLine":64},"diff":"--- Original\n+++ New\n@@ @@\n             $this->generateTraceId();\n         }\n         if (!$this->isSampled()) {\n-            $this->sampled = random_int(0, 99) < $samplePercentage;\n+            $this->sampled = random_int(0, 98) < $samplePercentage;\n         }\n         return $this;\n     }","processOutput":"PHPUnit 9.5.10 by Sebastian Bergmann and contributors.\n\nRuntime:       PHP 8.0.13\nConfiguration: \/tmp\/tmp-folder\/infection\/phpunitConfiguration.963ff018d3b4056853ceddf7a72043c7.infection.xml\n\n.......                                                             7 \/ 7 (100%)\n\nTime: 00:00.005, Memory: 8.00 MB\n\nOK (7 tests, 21 assertions)"},{"mutator":{"mutatorName":"IncrementInteger","originalSourceCode":"<?php\n\nnamespace Fido\\PHPXray;\n\nuse Exception;\nclass Trace extends Segment\n{\n    use HttpTrait;\n    private static self $instance;\n    private string $serviceVersion;\n    private string $user;\n    public static function getInstance() : self\n    {\n        if (!isset(self::$instance)) {\n            self::$instance = new self();\n        }\n        return self::$instance;\n    }\n    public function setServiceVersion(string $serviceVersion) : self\n    {\n        $this->serviceVersion = $serviceVersion;\n        return $this;\n    }\n    public function setUser(string $user) : self\n    {\n        $this->user = $user;\n        return $this;\n    }\n    public function setClientIpAddress(string $clientIpAddress) : self\n    {\n        $this->clientIpAddress = $clientIpAddress;\n        return $this;\n    }\n    public function setUserAgent(string $userAgent) : self\n    {\n        $this->userAgent = $userAgent;\n        return $this;\n    }\n    \/**\n     * @throws Exception\n     *\/\n    public function begin(int $samplePercentage = 10) : Segment\n    {\n        parent::begin();\n        if (!isset($this->traceId)) {\n            $this->generateTraceId();\n        }\n        if (!$this->isSampled()) {\n            $this->sampled = random_int(0, 99) < $samplePercentage;\n        }\n        return $this;\n    }\n    \/**\n     * @inheritdoc\n     *\/\n    public function jsonSerialize() : array\n    {\n        $data = parent::jsonSerialize();\n        $data['http'] = $this->serialiseHttpData();\n        $data['service'] = empty($this->serviceVersion) ? null : ['version' => $this->serviceVersion];\n        $data['user'] = $this->user ?? null;\n        return array_filter($data);\n    }\n    \/**\n     * @throws Exception if an appropriate source of randomness cannot be found.\n     *\/\n    private function generateTraceId() : void\n    {\n        $startHex = dechex((int) $this->startTime);\n        $uuid = bin2hex(random_bytes(12));\n        $this->setTraceId(\"1-{$startHex}-{$uuid}\");\n    }\n}","mutatedSourceCode":"<?php\n\nnamespace Fido\\PHPXray;\n\nuse Exception;\nclass Trace extends Segment\n{\n    use HttpTrait;\n    private static self $instance;\n    private string $serviceVersion;\n    private string $user;\n    public static function getInstance() : self\n    {\n        if (!isset(self::$instance)) {\n            self::$instance = new self();\n        }\n        return self::$instance;\n    }\n    public function setServiceVersion(string $serviceVersion) : self\n    {\n        $this->serviceVersion = $serviceVersion;\n        return $this;\n    }\n    public function setUser(string $user) : self\n    {\n        $this->user = $user;\n        return $this;\n    }\n    public function setClientIpAddress(string $clientIpAddress) : self\n    {\n        $this->clientIpAddress = $clientIpAddress;\n        return $this;\n    }\n    public function setUserAgent(string $userAgent) : self\n    {\n        $this->userAgent = $userAgent;\n        return $this;\n    }\n    \/**\n     * @throws Exception\n     *\/\n    public function begin(int $samplePercentage = 10) : Segment\n    {\n        parent::begin();\n        if (!isset($this->traceId)) {\n            $this->generateTraceId();\n        }\n        if (!$this->isSampled()) {\n            $this->sampled = random_int(0, 100) < $samplePercentage;\n        }\n        return $this;\n    }\n    \/**\n     * @inheritdoc\n     *\/\n    public function jsonSerialize() : array\n    {\n        $data = parent::jsonSerialize();\n        $data['http'] = $this->serialiseHttpData();\n        $data['service'] = empty($this->serviceVersion) ? null : ['version' => $this->serviceVersion];\n        $data['user'] = $this->user ?? null;\n        return array_filter($data);\n    }\n    \/**\n     * @throws Exception if an appropriate source of randomness cannot be found.\n     *\/\n    private function generateTraceId() : void\n    {\n        $startHex = dechex((int) $this->startTime);\n        $uuid = bin2hex(random_bytes(12));\n        $this->setTraceId(\"1-{$startHex}-{$uuid}\");\n    }\n}","originalFilePath":"\/home\/ranpafin\/php-xray\/src\/Trace.php","originalStartLine":64},"diff":"--- Original\n+++ New\n@@ @@\n             $this->generateTraceId();\n         }\n         if (!$this->isSampled()) {\n-            $this->sampled = random_int(0, 99) < $samplePercentage;\n+            $this->sampled = random_int(0, 100) < $samplePercentage;\n         }\n         return $this;\n     }","processOutput":"PHPUnit 9.5.10 by Sebastian Bergmann and contributors.\n\nRuntime:       PHP 8.0.13\nConfiguration: \/tmp\/tmp-folder\/infection\/phpunitConfiguration.c9921d4e5fc31e9efed1fcb924d8767b.infection.xml\n\n.......                                                             7 \/ 7 (100%)\n\nTime: 00:00.005, Memory: 8.00 MB\n\nOK (7 tests, 21 assertions)"},{"mutator":{"mutatorName":"LessThan","originalSourceCode":"<?php\n\nnamespace Fido\\PHPXray;\n\nuse Exception;\nclass Trace extends Segment\n{\n    use HttpTrait;\n    private static self $instance;\n    private string $serviceVersion;\n    private string $user;\n    public static function getInstance() : self\n    {\n        if (!isset(self::$instance)) {\n            self::$instance = new self();\n        }\n        return self::$instance;\n    }\n    public function setServiceVersion(string $serviceVersion) : self\n    {\n        $this->serviceVersion = $serviceVersion;\n        return $this;\n    }\n    public function setUser(string $user) : self\n    {\n        $this->user = $user;\n        return $this;\n    }\n    public function setClientIpAddress(string $clientIpAddress) : self\n    {\n        $this->clientIpAddress = $clientIpAddress;\n        return $this;\n    }\n    public function setUserAgent(string $userAgent) : self\n    {\n        $this->userAgent = $userAgent;\n        return $this;\n    }\n    \/**\n     * @throws Exception\n     *\/\n    public function begin(int $samplePercentage = 10) : Segment\n    {\n        parent::begin();\n        if (!isset($this->traceId)) {\n            $this->generateTraceId();\n        }\n        if (!$this->isSampled()) {\n            $this->sampled = random_int(0, 99) < $samplePercentage;\n        }\n        return $this;\n    }\n    \/**\n     * @inheritdoc\n     *\/\n    public function jsonSerialize() : array\n    {\n        $data = parent::jsonSerialize();\n        $data['http'] = $this->serialiseHttpData();\n        $data['service'] = empty($this->serviceVersion) ? null : ['version' => $this->serviceVersion];\n        $data['user'] = $this->user ?? null;\n        return array_filter($data);\n    }\n    \/**\n     * @throws Exception if an appropriate source of randomness cannot be found.\n     *\/\n    private function generateTraceId() : void\n    {\n        $startHex = dechex((int) $this->startTime);\n        $uuid = bin2hex(random_bytes(12));\n        $this->setTraceId(\"1-{$startHex}-{$uuid}\");\n    }\n}","mutatedSourceCode":"<?php\n\nnamespace Fido\\PHPXray;\n\nuse Exception;\nclass Trace extends Segment\n{\n    use HttpTrait;\n    private static self $instance;\n    private string $serviceVersion;\n    private string $user;\n    public static function getInstance() : self\n    {\n        if (!isset(self::$instance)) {\n            self::$instance = new self();\n        }\n        return self::$instance;\n    }\n    public function setServiceVersion(string $serviceVersion) : self\n    {\n        $this->serviceVersion = $serviceVersion;\n        return $this;\n    }\n    public function setUser(string $user) : self\n    {\n        $this->user = $user;\n        return $this;\n    }\n    public function setClientIpAddress(string $clientIpAddress) : self\n    {\n        $this->clientIpAddress = $clientIpAddress;\n        return $this;\n    }\n    public function setUserAgent(string $userAgent) : self\n    {\n        $this->userAgent = $userAgent;\n        return $this;\n    }\n    \/**\n     * @throws Exception\n     *\/\n    public function begin(int $samplePercentage = 10) : Segment\n    {\n        parent::begin();\n        if (!isset($this->traceId)) {\n            $this->generateTraceId();\n        }\n        if (!$this->isSampled()) {\n            $this->sampled = random_int(0, 99) <= $samplePercentage;\n        }\n        return $this;\n    }\n    \/**\n     * @inheritdoc\n     *\/\n    public function jsonSerialize() : array\n    {\n        $data = parent::jsonSerialize();\n        $data['http'] = $this->serialiseHttpData();\n        $data['service'] = empty($this->serviceVersion) ? null : ['version' => $this->serviceVersion];\n        $data['user'] = $this->user ?? null;\n        return array_filter($data);\n    }\n    \/**\n     * @throws Exception if an appropriate source of randomness cannot be found.\n     *\/\n    private function generateTraceId() : void\n    {\n        $startHex = dechex((int) $this->startTime);\n        $uuid = bin2hex(random_bytes(12));\n        $this->setTraceId(\"1-{$startHex}-{$uuid}\");\n    }\n}","originalFilePath":"\/home\/ranpafin\/php-xray\/src\/Trace.php","originalStartLine":64},"diff":"--- Original\n+++ New\n@@ @@\n             $this->generateTraceId();\n         }\n         if (!$this->isSampled()) {\n-            $this->sampled = random_int(0, 99) < $samplePercentage;\n+            $this->sampled = random_int(0, 99) <= $samplePercentage;\n         }\n         return $this;\n     }","processOutput":"PHPUnit 9.5.10 by Sebastian Bergmann and contributors.\n\nRuntime:       PHP 8.0.13\nConfiguration: \/tmp\/tmp-folder\/infection\/phpunitConfiguration.76e68c25039a93bc74c7c2e1356cfc2b.infection.xml\n\n.......                                                             7 \/ 7 (100%)\n\nTime: 00:00.008, Memory: 8.00 MB\n\nOK (7 tests, 21 assertions)"},{"mutator":{"mutatorName":"LessThanNegotiation","originalSourceCode":"<?php\n\nnamespace Fido\\PHPXray;\n\nuse Exception;\nclass Trace extends Segment\n{\n    use HttpTrait;\n    private static self $instance;\n    private string $serviceVersion;\n    private string $user;\n    public static function getInstance() : self\n    {\n        if (!isset(self::$instance)) {\n            self::$instance = new self();\n        }\n        return self::$instance;\n    }\n    public function setServiceVersion(string $serviceVersion) : self\n    {\n        $this->serviceVersion = $serviceVersion;\n        return $this;\n    }\n    public function setUser(string $user) : self\n    {\n        $this->user = $user;\n        return $this;\n    }\n    public function setClientIpAddress(string $clientIpAddress) : self\n    {\n        $this->clientIpAddress = $clientIpAddress;\n        return $this;\n    }\n    public function setUserAgent(string $userAgent) : self\n    {\n        $this->userAgent = $userAgent;\n        return $this;\n    }\n    \/**\n     * @throws Exception\n     *\/\n    public function begin(int $samplePercentage = 10) : Segment\n    {\n        parent::begin();\n        if (!isset($this->traceId)) {\n            $this->generateTraceId();\n        }\n        if (!$this->isSampled()) {\n            $this->sampled = random_int(0, 99) < $samplePercentage;\n        }\n        return $this;\n    }\n    \/**\n     * @inheritdoc\n     *\/\n    public function jsonSerialize() : array\n    {\n        $data = parent::jsonSerialize();\n        $data['http'] = $this->serialiseHttpData();\n        $data['service'] = empty($this->serviceVersion) ? null : ['version' => $this->serviceVersion];\n        $data['user'] = $this->user ?? null;\n        return array_filter($data);\n    }\n    \/**\n     * @throws Exception if an appropriate source of randomness cannot be found.\n     *\/\n    private function generateTraceId() : void\n    {\n        $startHex = dechex((int) $this->startTime);\n        $uuid = bin2hex(random_bytes(12));\n        $this->setTraceId(\"1-{$startHex}-{$uuid}\");\n    }\n}","mutatedSourceCode":"<?php\n\nnamespace Fido\\PHPXray;\n\nuse Exception;\nclass Trace extends Segment\n{\n    use HttpTrait;\n    private static self $instance;\n    private string $serviceVersion;\n    private string $user;\n    public static function getInstance() : self\n    {\n        if (!isset(self::$instance)) {\n            self::$instance = new self();\n        }\n        return self::$instance;\n    }\n    public function setServiceVersion(string $serviceVersion) : self\n    {\n        $this->serviceVersion = $serviceVersion;\n        return $this;\n    }\n    public function setUser(string $user) : self\n    {\n        $this->user = $user;\n        return $this;\n    }\n    public function setClientIpAddress(string $clientIpAddress) : self\n    {\n        $this->clientIpAddress = $clientIpAddress;\n        return $this;\n    }\n    public function setUserAgent(string $userAgent) : self\n    {\n        $this->userAgent = $userAgent;\n        return $this;\n    }\n    \/**\n     * @throws Exception\n     *\/\n    public function begin(int $samplePercentage = 10) : Segment\n    {\n        parent::begin();\n        if (!isset($this->traceId)) {\n            $this->generateTraceId();\n        }\n        if (!$this->isSampled()) {\n            $this->sampled = random_int(0, 99) >= $samplePercentage;\n        }\n        return $this;\n    }\n    \/**\n     * @inheritdoc\n     *\/\n    public function jsonSerialize() : array\n    {\n        $data = parent::jsonSerialize();\n        $data['http'] = $this->serialiseHttpData();\n        $data['service'] = empty($this->serviceVersion) ? null : ['version' => $this->serviceVersion];\n        $data['user'] = $this->user ?? null;\n        return array_filter($data);\n    }\n    \/**\n     * @throws Exception if an appropriate source of randomness cannot be found.\n     *\/\n    private function generateTraceId() : void\n    {\n        $startHex = dechex((int) $this->startTime);\n        $uuid = bin2hex(random_bytes(12));\n        $this->setTraceId(\"1-{$startHex}-{$uuid}\");\n    }\n}","originalFilePath":"\/home\/ranpafin\/php-xray\/src\/Trace.php","originalStartLine":64},"diff":"--- Original\n+++ New\n@@ @@\n             $this->generateTraceId();\n         }\n         if (!$this->isSampled()) {\n-            $this->sampled = random_int(0, 99) < $samplePercentage;\n+            $this->sampled = random_int(0, 99) >= $samplePercentage;\n         }\n         return $this;\n     }","processOutput":"PHPUnit 9.5.10 by Sebastian Bergmann and contributors.\n\nRuntime:       PHP 8.0.13\nConfiguration: \/tmp\/tmp-folder\/infection\/phpunitConfiguration.db57d717abc0168970de684c72059384.infection.xml\n\n.......                                                             7 \/ 7 (100%)\n\nTime: 00:00.005, Memory: 8.00 MB\n\nOK (7 tests, 21 assertions)"}],"timeouted":[{"mutator":{"mutatorName":"IncrementInteger","originalSourceCode":"<?php\n\nnamespace Fido\\PHPXray\\Submission;\n\nuse Error;\nuse Fido\\PHPXray\\Segment;\nuse Socket;\nuse function socket_create;\nuse function socket_last_error;\nclass DaemonSegmentSubmitter implements SegmentSubmitter\n{\n    protected const MAX_SEGMENT_SIZE = 64000;\n    \/**\n     * @var array<string, mixed>\n     *\/\n    public const HEADER = ['format' => 'json', 'version' => 1];\n    private string $host;\n    private int $port;\n    \/** @var Socket *\/\n    private $socket;\n    public function __construct(string $host = '127.0.0.1', int $port = 2000)\n    {\n        if (isset($_SERVER['AWS_XRAY_DAEMON_ADDRESS'])) {\n            [$host, $port] = explode(\":\", $_SERVER['AWS_XRAY_DAEMON_ADDRESS']);\n        }\n        $this->host = $_SERVER['_AWS_XRAY_DAEMON_ADDRESS'] ?? $host;\n        $this->port = (int) ($_SERVER['_AWS_XRAY_DAEMON_PORT'] ?? $port);\n        if (!($socket = socket_create(AF_INET, SOCK_DGRAM, SOL_UDP))) {\n            throw new Error('Can\\'t create socket: ' . socket_last_error());\n        }\n        $this->socket = $socket;\n    }\n    public function __destruct()\n    {\n        socket_close($this->socket);\n    }\n    public function submitSegment(Segment $segment) : void\n    {\n        $packet = $this->buildPacket($segment);\n        $packetLength = strlen($packet);\n        if ($packetLength > self::MAX_SEGMENT_SIZE) {\n            $this->submitFragmented($segment);\n            return;\n        }\n        $this->sendPacket($packet);\n    }\n    \/**\n     * @param Segment|array<string, mixed> $segment\n     *\/\n    private function buildPacket(Segment|array $segment) : string\n    {\n        return implode(\"\\n\", array_map('json_encode', [self::HEADER, $segment]));\n    }\n    private function sendPacket(string $packet) : void\n    {\n        socket_sendto($this->socket, $packet, strlen($packet), 0, $this->host, $this->port);\n    }\n    private function submitFragmented(Segment $segment) : void\n    {\n        $rawSegment = $segment->jsonSerialize();\n        \/** @var Segment[] $subsegments *\/\n        $subsegments = $rawSegment['subsegments'] ?? [];\n        unset($rawSegment['subsegments']);\n        $this->submitOpenSegment($rawSegment);\n        foreach ($subsegments as $subsegment) {\n            $subsegment = clone $subsegment;\n            $subsegment->setParentId($segment->getId())->setTraceId($segment->getTraceId())->setIndependent(true);\n            $this->submitSegment($subsegment);\n        }\n        $completePacket = $this->buildPacket($rawSegment);\n        $this->sendPacket($completePacket);\n    }\n    \/**\n     * @param array<string, mixed> $openSegment\n     *\/\n    private function submitOpenSegment(array $openSegment) : void\n    {\n        unset($openSegment['end_time']);\n        $openSegment['in_progress'] = true;\n        $this->sendPacket($this->buildPacket($openSegment));\n    }\n}","mutatedSourceCode":"<?php\n\nnamespace Fido\\PHPXray\\Submission;\n\nuse Error;\nuse Fido\\PHPXray\\Segment;\nuse Socket;\nuse function socket_create;\nuse function socket_last_error;\nclass DaemonSegmentSubmitter implements SegmentSubmitter\n{\n    protected const MAX_SEGMENT_SIZE = 64000;\n    \/**\n     * @var array<string, mixed>\n     *\/\n    public const HEADER = ['format' => 'json', 'version' => 1];\n    private string $host;\n    private int $port;\n    \/** @var Socket *\/\n    private $socket;\n    public function __construct(string $host = '127.0.0.1', int $port = 2001)\n    {\n        if (isset($_SERVER['AWS_XRAY_DAEMON_ADDRESS'])) {\n            [$host, $port] = explode(\":\", $_SERVER['AWS_XRAY_DAEMON_ADDRESS']);\n        }\n        $this->host = $_SERVER['_AWS_XRAY_DAEMON_ADDRESS'] ?? $host;\n        $this->port = (int) ($_SERVER['_AWS_XRAY_DAEMON_PORT'] ?? $port);\n        if (!($socket = socket_create(AF_INET, SOCK_DGRAM, SOL_UDP))) {\n            throw new Error('Can\\'t create socket: ' . socket_last_error());\n        }\n        $this->socket = $socket;\n    }\n    public function __destruct()\n    {\n        socket_close($this->socket);\n    }\n    public function submitSegment(Segment $segment) : void\n    {\n        $packet = $this->buildPacket($segment);\n        $packetLength = strlen($packet);\n        if ($packetLength > self::MAX_SEGMENT_SIZE) {\n            $this->submitFragmented($segment);\n            return;\n        }\n        $this->sendPacket($packet);\n    }\n    \/**\n     * @param Segment|array<string, mixed> $segment\n     *\/\n    private function buildPacket(Segment|array $segment) : string\n    {\n        return implode(\"\\n\", array_map('json_encode', [self::HEADER, $segment]));\n    }\n    private function sendPacket(string $packet) : void\n    {\n        socket_sendto($this->socket, $packet, strlen($packet), 0, $this->host, $this->port);\n    }\n    private function submitFragmented(Segment $segment) : void\n    {\n        $rawSegment = $segment->jsonSerialize();\n        \/** @var Segment[] $subsegments *\/\n        $subsegments = $rawSegment['subsegments'] ?? [];\n        unset($rawSegment['subsegments']);\n        $this->submitOpenSegment($rawSegment);\n        foreach ($subsegments as $subsegment) {\n            $subsegment = clone $subsegment;\n            $subsegment->setParentId($segment->getId())->setTraceId($segment->getTraceId())->setIndependent(true);\n            $this->submitSegment($subsegment);\n        }\n        $completePacket = $this->buildPacket($rawSegment);\n        $this->sendPacket($completePacket);\n    }\n    \/**\n     * @param array<string, mixed> $openSegment\n     *\/\n    private function submitOpenSegment(array $openSegment) : void\n    {\n        unset($openSegment['end_time']);\n        $openSegment['in_progress'] = true;\n        $this->sendPacket($this->buildPacket($openSegment));\n    }\n}","originalFilePath":"\/home\/ranpafin\/php-xray\/src\/Submission\/DaemonSegmentSubmitter.php","originalStartLine":28},"diff":"--- Original\n+++ New\n@@ @@\n     private int $port;\n     \/** @var Socket *\/\n     private $socket;\n-    public function __construct(string $host = '127.0.0.1', int $port = 2000)\n+    public function __construct(string $host = '127.0.0.1', int $port = 2001)\n     {\n         if (isset($_SERVER['AWS_XRAY_DAEMON_ADDRESS'])) {\n             [$host, $port] = explode(\":\", $_SERVER['AWS_XRAY_DAEMON_ADDRESS']);","processOutput":"PHPUnit 9.5.10 by Sebastian Bergmann and contributors.\n\nRuntime:       PHP 8.0.13\nConfiguration: \/tmp\/tmp-folder\/infection\/phpunitConfiguration.85551da5d0fda1e57dc63d8bab980919.infection.xml"}],"killed":[{"mutator":{"mutatorName":"PublicVisibility","originalSourceCode":"<?php\n\ndeclare (strict_types=1);\nnamespace Fido\\PHPXray;\n\nclass DynamoSegment extends RemoteSegment\n{\n    protected string $tableName;\n    protected string $operation;\n    protected string $requestId;\n    \/** @var string[] *\/\n    protected array $resourceNames;\n    public function setTableName(string $tableName) : self\n    {\n        $this->tableName = $tableName;\n        return $this;\n    }\n    public function setOperation(string $operation) : self\n    {\n        $this->operation = $operation;\n        return $this;\n    }\n    public function setRequestId(string $requestId) : self\n    {\n        $this->requestId = $requestId;\n        return $this;\n    }\n    public function addResourceName(string $value) : self\n    {\n        $this->resourceNames[] = $value;\n        return $this;\n    }\n    \/**\n     * @inheritdoc\n     *\/\n    public function jsonSerialize() : array\n    {\n        $data = parent::jsonSerialize();\n        $data['aws'] = ['table_name' => $this->tableName, 'operation' => $this->operation, 'request_id' => $this->requestId, 'resource_names' => $this->resourceNames ?: null];\n        return $data;\n    }\n}","mutatedSourceCode":"<?php\n\ndeclare (strict_types=1);\nnamespace Fido\\PHPXray;\n\nclass DynamoSegment extends RemoteSegment\n{\n    protected string $tableName;\n    protected string $operation;\n    protected string $requestId;\n    \/** @var string[] *\/\n    protected array $resourceNames;\n    protected function setTableName(string $tableName) : self\n    {\n        $this->tableName = $tableName;\n        return $this;\n    }\n    public function setOperation(string $operation) : self\n    {\n        $this->operation = $operation;\n        return $this;\n    }\n    public function setRequestId(string $requestId) : self\n    {\n        $this->requestId = $requestId;\n        return $this;\n    }\n    public function addResourceName(string $value) : self\n    {\n        $this->resourceNames[] = $value;\n        return $this;\n    }\n    \/**\n     * @inheritdoc\n     *\/\n    public function jsonSerialize() : array\n    {\n        $data = parent::jsonSerialize();\n        $data['aws'] = ['table_name' => $this->tableName, 'operation' => $this->operation, 'request_id' => $this->requestId, 'resource_names' => $this->resourceNames ?: null];\n        return $data;\n    }\n}","originalFilePath":"\/home\/ranpafin\/php-xray\/src\/DynamoSegment.php","originalStartLine":16},"diff":"--- Original\n+++ New\n@@ @@\n     protected string $requestId;\n     \/** @var string[] *\/\n     protected array $resourceNames;\n-    public function setTableName(string $tableName) : self\n+    protected function setTableName(string $tableName) : self\n     {\n         $this->tableName = $tableName;\n         return $this;","processOutput":"PHPUnit 9.5.10 by Sebastian Bergmann and contributors.\n\nRuntime:       PHP 8.0.13\nConfiguration: \/tmp\/tmp-folder\/infection\/phpunitConfiguration.cd705c9baf831fb391d1f07e931dad49.infection.xml\n\nE                                                                   1 \/ 1 (100%)\n\nTime: 00:00.003, Memory: 8.00 MB\n\nThere was 1 error:\n\n1) Fido\\PHPXray\\DynamoSegmentTest::testSerialisesCorrectly\nError: Call to protected method Fido\\PHPXray\\DynamoSegment::setTableName() from scope Fido\\PHPXray\\DynamoSegmentTest\n\n\/home\/ranpafin\/php-xray\/tests\/DynamoSegmentTest.php:12\n\nERRORS!\nTests: 1, Assertions: 0, Errors: 1."},{"mutator":{"mutatorName":"PublicVisibility","originalSourceCode":"<?php\n\ndeclare (strict_types=1);\nnamespace Fido\\PHPXray;\n\nclass DynamoSegment extends RemoteSegment\n{\n    protected string $tableName;\n    protected string $operation;\n    protected string $requestId;\n    \/** @var string[] *\/\n    protected array $resourceNames;\n    public function setTableName(string $tableName) : self\n    {\n        $this->tableName = $tableName;\n        return $this;\n    }\n    public function setOperation(string $operation) : self\n    {\n        $this->operation = $operation;\n        return $this;\n    }\n    public function setRequestId(string $requestId) : self\n    {\n        $this->requestId = $requestId;\n        return $this;\n    }\n    public function addResourceName(string $value) : self\n    {\n        $this->resourceNames[] = $value;\n        return $this;\n    }\n    \/**\n     * @inheritdoc\n     *\/\n    public function jsonSerialize() : array\n    {\n        $data = parent::jsonSerialize();\n        $data['aws'] = ['table_name' => $this->tableName, 'operation' => $this->operation, 'request_id' => $this->requestId, 'resource_names' => $this->resourceNames ?: null];\n        return $data;\n    }\n}","mutatedSourceCode":"<?php\n\ndeclare (strict_types=1);\nnamespace Fido\\PHPXray;\n\nclass DynamoSegment extends RemoteSegment\n{\n    protected string $tableName;\n    protected string $operation;\n    protected string $requestId;\n    \/** @var string[] *\/\n    protected array $resourceNames;\n    public function setTableName(string $tableName) : self\n    {\n        $this->tableName = $tableName;\n        return $this;\n    }\n    protected function setOperation(string $operation) : self\n    {\n        $this->operation = $operation;\n        return $this;\n    }\n    public function setRequestId(string $requestId) : self\n    {\n        $this->requestId = $requestId;\n        return $this;\n    }\n    public function addResourceName(string $value) : self\n    {\n        $this->resourceNames[] = $value;\n        return $this;\n    }\n    \/**\n     * @inheritdoc\n     *\/\n    public function jsonSerialize() : array\n    {\n        $data = parent::jsonSerialize();\n        $data['aws'] = ['table_name' => $this->tableName, 'operation' => $this->operation, 'request_id' => $this->requestId, 'resource_names' => $this->resourceNames ?: null];\n        return $data;\n    }\n}","originalFilePath":"\/home\/ranpafin\/php-xray\/src\/DynamoSegment.php","originalStartLine":23},"diff":"--- Original\n+++ New\n@@ @@\n         $this->tableName = $tableName;\n         return $this;\n     }\n-    public function setOperation(string $operation) : self\n+    protected function setOperation(string $operation) : self\n     {\n         $this->operation = $operation;\n         return $this;","processOutput":"PHPUnit 9.5.10 by Sebastian Bergmann and contributors.\n\nRuntime:       PHP 8.0.13\nConfiguration: \/tmp\/tmp-folder\/infection\/phpunitConfiguration.88e5d9e00b7b185a96290857defbeb3d.infection.xml\n\nE                                                                   1 \/ 1 (100%)\n\nTime: 00:00.004, Memory: 8.00 MB\n\nThere was 1 error:\n\n1) Fido\\PHPXray\\DynamoSegmentTest::testSerialisesCorrectly\nError: Call to protected method Fido\\PHPXray\\DynamoSegment::setOperation() from scope Fido\\PHPXray\\DynamoSegmentTest\n\n\/home\/ranpafin\/php-xray\/tests\/DynamoSegmentTest.php:13\n\nERRORS!\nTests: 1, Assertions: 0, Errors: 1."},{"mutator":{"mutatorName":"PublicVisibility","originalSourceCode":"<?php\n\ndeclare (strict_types=1);\nnamespace Fido\\PHPXray;\n\nclass DynamoSegment extends RemoteSegment\n{\n    protected string $tableName;\n    protected string $operation;\n    protected string $requestId;\n    \/** @var string[] *\/\n    protected array $resourceNames;\n    public function setTableName(string $tableName) : self\n    {\n        $this->tableName = $tableName;\n        return $this;\n    }\n    public function setOperation(string $operation) : self\n    {\n        $this->operation = $operation;\n        return $this;\n    }\n    public function setRequestId(string $requestId) : self\n    {\n        $this->requestId = $requestId;\n        return $this;\n    }\n    public function addResourceName(string $value) : self\n    {\n        $this->resourceNames[] = $value;\n        return $this;\n    }\n    \/**\n     * @inheritdoc\n     *\/\n    public function jsonSerialize() : array\n    {\n        $data = parent::jsonSerialize();\n        $data['aws'] = ['table_name' => $this->tableName, 'operation' => $this->operation, 'request_id' => $this->requestId, 'resource_names' => $this->resourceNames ?: null];\n        return $data;\n    }\n}","mutatedSourceCode":"<?php\n\ndeclare (strict_types=1);\nnamespace Fido\\PHPXray;\n\nclass DynamoSegment extends RemoteSegment\n{\n    protected string $tableName;\n    protected string $operation;\n    protected string $requestId;\n    \/** @var string[] *\/\n    protected array $resourceNames;\n    public function setTableName(string $tableName) : self\n    {\n        $this->tableName = $tableName;\n        return $this;\n    }\n    public function setOperation(string $operation) : self\n    {\n        $this->operation = $operation;\n        return $this;\n    }\n    protected function setRequestId(string $requestId) : self\n    {\n        $this->requestId = $requestId;\n        return $this;\n    }\n    public function addResourceName(string $value) : self\n    {\n        $this->resourceNames[] = $value;\n        return $this;\n    }\n    \/**\n     * @inheritdoc\n     *\/\n    public function jsonSerialize() : array\n    {\n        $data = parent::jsonSerialize();\n        $data['aws'] = ['table_name' => $this->tableName, 'operation' => $this->operation, 'request_id' => $this->requestId, 'resource_names' => $this->resourceNames ?: null];\n        return $data;\n    }\n}","originalFilePath":"\/home\/ranpafin\/php-xray\/src\/DynamoSegment.php","originalStartLine":30},"diff":"--- Original\n+++ New\n@@ @@\n         $this->operation = $operation;\n         return $this;\n     }\n-    public function setRequestId(string $requestId) : self\n+    protected function setRequestId(string $requestId) : self\n     {\n         $this->requestId = $requestId;\n         return $this;","processOutput":"PHPUnit 9.5.10 by Sebastian Bergmann and contributors.\n\nRuntime:       PHP 8.0.13\nConfiguration: \/tmp\/tmp-folder\/infection\/phpunitConfiguration.fd48e17f77da6c89921d812205412084.infection.xml\n\nE                                                                   1 \/ 1 (100%)\n\nTime: 00:00.004, Memory: 8.00 MB\n\nThere was 1 error:\n\n1) Fido\\PHPXray\\DynamoSegmentTest::testSerialisesCorrectly\nError: Call to protected method Fido\\PHPXray\\DynamoSegment::setRequestId() from scope Fido\\PHPXray\\DynamoSegmentTest\n\n\/home\/ranpafin\/php-xray\/tests\/DynamoSegmentTest.php:14\n\nERRORS!\nTests: 1, Assertions: 0, Errors: 1."},{"mutator":{"mutatorName":"PublicVisibility","originalSourceCode":"<?php\n\ndeclare (strict_types=1);\nnamespace Fido\\PHPXray;\n\nclass DynamoSegment extends RemoteSegment\n{\n    protected string $tableName;\n    protected string $operation;\n    protected string $requestId;\n    \/** @var string[] *\/\n    protected array $resourceNames;\n    public function setTableName(string $tableName) : self\n    {\n        $this->tableName = $tableName;\n        return $this;\n    }\n    public function setOperation(string $operation) : self\n    {\n        $this->operation = $operation;\n        return $this;\n    }\n    public function setRequestId(string $requestId) : self\n    {\n        $this->requestId = $requestId;\n        return $this;\n    }\n    public function addResourceName(string $value) : self\n    {\n        $this->resourceNames[] = $value;\n        return $this;\n    }\n    \/**\n     * @inheritdoc\n     *\/\n    public function jsonSerialize() : array\n    {\n        $data = parent::jsonSerialize();\n        $data['aws'] = ['table_name' => $this->tableName, 'operation' => $this->operation, 'request_id' => $this->requestId, 'resource_names' => $this->resourceNames ?: null];\n        return $data;\n    }\n}","mutatedSourceCode":"<?php\n\ndeclare (strict_types=1);\nnamespace Fido\\PHPXray;\n\nclass DynamoSegment extends RemoteSegment\n{\n    protected string $tableName;\n    protected string $operation;\n    protected string $requestId;\n    \/** @var string[] *\/\n    protected array $resourceNames;\n    public function setTableName(string $tableName) : self\n    {\n        $this->tableName = $tableName;\n        return $this;\n    }\n    public function setOperation(string $operation) : self\n    {\n        $this->operation = $operation;\n        return $this;\n    }\n    public function setRequestId(string $requestId) : self\n    {\n        $this->requestId = $requestId;\n        return $this;\n    }\n    protected function addResourceName(string $value) : self\n    {\n        $this->resourceNames[] = $value;\n        return $this;\n    }\n    \/**\n     * @inheritdoc\n     *\/\n    public function jsonSerialize() : array\n    {\n        $data = parent::jsonSerialize();\n        $data['aws'] = ['table_name' => $this->tableName, 'operation' => $this->operation, 'request_id' => $this->requestId, 'resource_names' => $this->resourceNames ?: null];\n        return $data;\n    }\n}","originalFilePath":"\/home\/ranpafin\/php-xray\/src\/DynamoSegment.php","originalStartLine":37},"diff":"--- Original\n+++ New\n@@ @@\n         $this->requestId = $requestId;\n         return $this;\n     }\n-    public function addResourceName(string $value) : self\n+    protected function addResourceName(string $value) : self\n     {\n         $this->resourceNames[] = $value;\n         return $this;","processOutput":"PHPUnit 9.5.10 by Sebastian Bergmann and contributors.\n\nRuntime:       PHP 8.0.13\nConfiguration: \/tmp\/tmp-folder\/infection\/phpunitConfiguration.0c16d1af4ad0e39e9f2407e4b9f33fb3.infection.xml\n\nE                                                                   1 \/ 1 (100%)\n\nTime: 00:00.004, Memory: 8.00 MB\n\nThere was 1 error:\n\n1) Fido\\PHPXray\\DynamoSegmentTest::testSerialisesCorrectly\nError: Call to protected method Fido\\PHPXray\\DynamoSegment::addResourceName() from scope Fido\\PHPXray\\DynamoSegmentTest\n\n\/home\/ranpafin\/php-xray\/tests\/DynamoSegmentTest.php:15\n\nERRORS!\nTests: 1, Assertions: 0, Errors: 1."},{"mutator":{"mutatorName":"ArrayItemRemoval","originalSourceCode":"<?php\n\ndeclare (strict_types=1);\nnamespace Fido\\PHPXray;\n\nclass DynamoSegment extends RemoteSegment\n{\n    protected string $tableName;\n    protected string $operation;\n    protected string $requestId;\n    \/** @var string[] *\/\n    protected array $resourceNames;\n    public function setTableName(string $tableName) : self\n    {\n        $this->tableName = $tableName;\n        return $this;\n    }\n    public function setOperation(string $operation) : self\n    {\n        $this->operation = $operation;\n        return $this;\n    }\n    public function setRequestId(string $requestId) : self\n    {\n        $this->requestId = $requestId;\n        return $this;\n    }\n    public function addResourceName(string $value) : self\n    {\n        $this->resourceNames[] = $value;\n        return $this;\n    }\n    \/**\n     * @inheritdoc\n     *\/\n    public function jsonSerialize() : array\n    {\n        $data = parent::jsonSerialize();\n        $data['aws'] = ['table_name' => $this->tableName, 'operation' => $this->operation, 'request_id' => $this->requestId, 'resource_names' => $this->resourceNames ?: null];\n        return $data;\n    }\n}","mutatedSourceCode":"<?php\n\ndeclare (strict_types=1);\nnamespace Fido\\PHPXray;\n\nclass DynamoSegment extends RemoteSegment\n{\n    protected string $tableName;\n    protected string $operation;\n    protected string $requestId;\n    \/** @var string[] *\/\n    protected array $resourceNames;\n    public function setTableName(string $tableName) : self\n    {\n        $this->tableName = $tableName;\n        return $this;\n    }\n    public function setOperation(string $operation) : self\n    {\n        $this->operation = $operation;\n        return $this;\n    }\n    public function setRequestId(string $requestId) : self\n    {\n        $this->requestId = $requestId;\n        return $this;\n    }\n    public function addResourceName(string $value) : self\n    {\n        $this->resourceNames[] = $value;\n        return $this;\n    }\n    \/**\n     * @inheritdoc\n     *\/\n    public function jsonSerialize() : array\n    {\n        $data = parent::jsonSerialize();\n        $data['aws'] = ['operation' => $this->operation, 'request_id' => $this->requestId, 'resource_names' => $this->resourceNames ?: null];\n        return $data;\n    }\n}","originalFilePath":"\/home\/ranpafin\/php-xray\/src\/DynamoSegment.php","originalStartLine":51},"diff":"--- Original\n+++ New\n@@ @@\n     public function jsonSerialize() : array\n     {\n         $data = parent::jsonSerialize();\n-        $data['aws'] = ['table_name' => $this->tableName, 'operation' => $this->operation, 'request_id' => $this->requestId, 'resource_names' => $this->resourceNames ?: null];\n+        $data['aws'] = ['operation' => $this->operation, 'request_id' => $this->requestId, 'resource_names' => $this->resourceNames ?: null];\n         return $data;\n     }\n }","processOutput":"PHPUnit 9.5.10 by Sebastian Bergmann and contributors.\n\nRuntime:       PHP 8.0.13\nConfiguration: \/tmp\/tmp-folder\/infection\/phpunitConfiguration.418c37f1402380edde7f4098ac153c8d.infection.xml\n\nE                                                                   1 \/ 1 (100%)\n\nTime: 00:00.004, Memory: 8.00 MB\n\nThere was 1 error:\n\n1) Fido\\PHPXray\\DynamoSegmentTest::testSerialisesCorrectly\nUndefined array key \"table_name\"\n\n\/home\/ranpafin\/php-xray\/tests\/DynamoSegmentTest.php:20\n\nERRORS!\nTests: 1, Assertions: 0, Errors: 1."},{"mutator":{"mutatorName":"ArrayItem","originalSourceCode":"<?php\n\ndeclare (strict_types=1);\nnamespace Fido\\PHPXray;\n\nclass DynamoSegment extends RemoteSegment\n{\n    protected string $tableName;\n    protected string $operation;\n    protected string $requestId;\n    \/** @var string[] *\/\n    protected array $resourceNames;\n    public function setTableName(string $tableName) : self\n    {\n        $this->tableName = $tableName;\n        return $this;\n    }\n    public function setOperation(string $operation) : self\n    {\n        $this->operation = $operation;\n        return $this;\n    }\n    public function setRequestId(string $requestId) : self\n    {\n        $this->requestId = $requestId;\n        return $this;\n    }\n    public function addResourceName(string $value) : self\n    {\n        $this->resourceNames[] = $value;\n        return $this;\n    }\n    \/**\n     * @inheritdoc\n     *\/\n    public function jsonSerialize() : array\n    {\n        $data = parent::jsonSerialize();\n        $data['aws'] = ['table_name' => $this->tableName, 'operation' => $this->operation, 'request_id' => $this->requestId, 'resource_names' => $this->resourceNames ?: null];\n        return $data;\n    }\n}","mutatedSourceCode":"<?php\n\ndeclare (strict_types=1);\nnamespace Fido\\PHPXray;\n\nclass DynamoSegment extends RemoteSegment\n{\n    protected string $tableName;\n    protected string $operation;\n    protected string $requestId;\n    \/** @var string[] *\/\n    protected array $resourceNames;\n    public function setTableName(string $tableName) : self\n    {\n        $this->tableName = $tableName;\n        return $this;\n    }\n    public function setOperation(string $operation) : self\n    {\n        $this->operation = $operation;\n        return $this;\n    }\n    public function setRequestId(string $requestId) : self\n    {\n        $this->requestId = $requestId;\n        return $this;\n    }\n    public function addResourceName(string $value) : self\n    {\n        $this->resourceNames[] = $value;\n        return $this;\n    }\n    \/**\n     * @inheritdoc\n     *\/\n    public function jsonSerialize() : array\n    {\n        $data = parent::jsonSerialize();\n        $data['aws'] = ['table_name' > $this->tableName, 'operation' => $this->operation, 'request_id' => $this->requestId, 'resource_names' => $this->resourceNames ?: null];\n        return $data;\n    }\n}","originalFilePath":"\/home\/ranpafin\/php-xray\/src\/DynamoSegment.php","originalStartLine":52},"diff":"--- Original\n+++ New\n@@ @@\n     public function jsonSerialize() : array\n     {\n         $data = parent::jsonSerialize();\n-        $data['aws'] = ['table_name' => $this->tableName, 'operation' => $this->operation, 'request_id' => $this->requestId, 'resource_names' => $this->resourceNames ?: null];\n+        $data['aws'] = ['table_name' > $this->tableName, 'operation' => $this->operation, 'request_id' => $this->requestId, 'resource_names' => $this->resourceNames ?: null];\n         return $data;\n     }\n }","processOutput":"PHPUnit 9.5.10 by Sebastian Bergmann and contributors.\n\nRuntime:       PHP 8.0.13\nConfiguration: \/tmp\/tmp-folder\/infection\/phpunitConfiguration.4422b456069862ae32a7c2efe7114e24.infection.xml\n\nE                                                                   1 \/ 1 (100%)\n\nTime: 00:00.003, Memory: 8.00 MB\n\nThere was 1 error:\n\n1) Fido\\PHPXray\\DynamoSegmentTest::testSerialisesCorrectly\nUndefined array key \"table_name\"\n\n\/home\/ranpafin\/php-xray\/tests\/DynamoSegmentTest.php:20\n\nERRORS!\nTests: 1, Assertions: 0, Errors: 1."},{"mutator":{"mutatorName":"ArrayItem","originalSourceCode":"<?php\n\ndeclare (strict_types=1);\nnamespace Fido\\PHPXray;\n\nclass DynamoSegment extends RemoteSegment\n{\n    protected string $tableName;\n    protected string $operation;\n    protected string $requestId;\n    \/** @var string[] *\/\n    protected array $resourceNames;\n    public function setTableName(string $tableName) : self\n    {\n        $this->tableName = $tableName;\n        return $this;\n    }\n    public function setOperation(string $operation) : self\n    {\n        $this->operation = $operation;\n        return $this;\n    }\n    public function setRequestId(string $requestId) : self\n    {\n        $this->requestId = $requestId;\n        return $this;\n    }\n    public function addResourceName(string $value) : self\n    {\n        $this->resourceNames[] = $value;\n        return $this;\n    }\n    \/**\n     * @inheritdoc\n     *\/\n    public function jsonSerialize() : array\n    {\n        $data = parent::jsonSerialize();\n        $data['aws'] = ['table_name' => $this->tableName, 'operation' => $this->operation, 'request_id' => $this->requestId, 'resource_names' => $this->resourceNames ?: null];\n        return $data;\n    }\n}","mutatedSourceCode":"<?php\n\ndeclare (strict_types=1);\nnamespace Fido\\PHPXray;\n\nclass DynamoSegment extends RemoteSegment\n{\n    protected string $tableName;\n    protected string $operation;\n    protected string $requestId;\n    \/** @var string[] *\/\n    protected array $resourceNames;\n    public function setTableName(string $tableName) : self\n    {\n        $this->tableName = $tableName;\n        return $this;\n    }\n    public function setOperation(string $operation) : self\n    {\n        $this->operation = $operation;\n        return $this;\n    }\n    public function setRequestId(string $requestId) : self\n    {\n        $this->requestId = $requestId;\n        return $this;\n    }\n    public function addResourceName(string $value) : self\n    {\n        $this->resourceNames[] = $value;\n        return $this;\n    }\n    \/**\n     * @inheritdoc\n     *\/\n    public function jsonSerialize() : array\n    {\n        $data = parent::jsonSerialize();\n        $data['aws'] = ['table_name' => $this->tableName, 'operation' > $this->operation, 'request_id' => $this->requestId, 'resource_names' => $this->resourceNames ?: null];\n        return $data;\n    }\n}","originalFilePath":"\/home\/ranpafin\/php-xray\/src\/DynamoSegment.php","originalStartLine":53},"diff":"--- Original\n+++ New\n@@ @@\n     public function jsonSerialize() : array\n     {\n         $data = parent::jsonSerialize();\n-        $data['aws'] = ['table_name' => $this->tableName, 'operation' => $this->operation, 'request_id' => $this->requestId, 'resource_names' => $this->resourceNames ?: null];\n+        $data['aws'] = ['table_name' => $this->tableName, 'operation' > $this->operation, 'request_id' => $this->requestId, 'resource_names' => $this->resourceNames ?: null];\n         return $data;\n     }\n }","processOutput":"PHPUnit 9.5.10 by Sebastian Bergmann and contributors.\n\nRuntime:       PHP 8.0.13\nConfiguration: \/tmp\/tmp-folder\/infection\/phpunitConfiguration.7807d0a277b2b0979f6e327b44d8f2b4.infection.xml\n\nE                                                                   1 \/ 1 (100%)\n\nTime: 00:00.003, Memory: 8.00 MB\n\nThere was 1 error:\n\n1) Fido\\PHPXray\\DynamoSegmentTest::testSerialisesCorrectly\nUndefined array key \"operation\"\n\n\/home\/ranpafin\/php-xray\/tests\/DynamoSegmentTest.php:21\n\nERRORS!\nTests: 1, Assertions: 1, Errors: 1."},{"mutator":{"mutatorName":"ArrayItem","originalSourceCode":"<?php\n\ndeclare (strict_types=1);\nnamespace Fido\\PHPXray;\n\nclass DynamoSegment extends RemoteSegment\n{\n    protected string $tableName;\n    protected string $operation;\n    protected string $requestId;\n    \/** @var string[] *\/\n    protected array $resourceNames;\n    public function setTableName(string $tableName) : self\n    {\n        $this->tableName = $tableName;\n        return $this;\n    }\n    public function setOperation(string $operation) : self\n    {\n        $this->operation = $operation;\n        return $this;\n    }\n    public function setRequestId(string $requestId) : self\n    {\n        $this->requestId = $requestId;\n        return $this;\n    }\n    public function addResourceName(string $value) : self\n    {\n        $this->resourceNames[] = $value;\n        return $this;\n    }\n    \/**\n     * @inheritdoc\n     *\/\n    public function jsonSerialize() : array\n    {\n        $data = parent::jsonSerialize();\n        $data['aws'] = ['table_name' => $this->tableName, 'operation' => $this->operation, 'request_id' => $this->requestId, 'resource_names' => $this->resourceNames ?: null];\n        return $data;\n    }\n}","mutatedSourceCode":"<?php\n\ndeclare (strict_types=1);\nnamespace Fido\\PHPXray;\n\nclass DynamoSegment extends RemoteSegment\n{\n    protected string $tableName;\n    protected string $operation;\n    protected string $requestId;\n    \/** @var string[] *\/\n    protected array $resourceNames;\n    public function setTableName(string $tableName) : self\n    {\n        $this->tableName = $tableName;\n        return $this;\n    }\n    public function setOperation(string $operation) : self\n    {\n        $this->operation = $operation;\n        return $this;\n    }\n    public function setRequestId(string $requestId) : self\n    {\n        $this->requestId = $requestId;\n        return $this;\n    }\n    public function addResourceName(string $value) : self\n    {\n        $this->resourceNames[] = $value;\n        return $this;\n    }\n    \/**\n     * @inheritdoc\n     *\/\n    public function jsonSerialize() : array\n    {\n        $data = parent::jsonSerialize();\n        $data['aws'] = ['table_name' => $this->tableName, 'operation' => $this->operation, 'request_id' > $this->requestId, 'resource_names' => $this->resourceNames ?: null];\n        return $data;\n    }\n}","originalFilePath":"\/home\/ranpafin\/php-xray\/src\/DynamoSegment.php","originalStartLine":54},"diff":"--- Original\n+++ New\n@@ @@\n     public function jsonSerialize() : array\n     {\n         $data = parent::jsonSerialize();\n-        $data['aws'] = ['table_name' => $this->tableName, 'operation' => $this->operation, 'request_id' => $this->requestId, 'resource_names' => $this->resourceNames ?: null];\n+        $data['aws'] = ['table_name' => $this->tableName, 'operation' => $this->operation, 'request_id' > $this->requestId, 'resource_names' => $this->resourceNames ?: null];\n         return $data;\n     }\n }","processOutput":"PHPUnit 9.5.10 by Sebastian Bergmann and contributors.\n\nRuntime:       PHP 8.0.13\nConfiguration: \/tmp\/tmp-folder\/infection\/phpunitConfiguration.f623464c869b55bafed4c21d24cecc71.infection.xml\n\nE                                                                   1 \/ 1 (100%)\n\nTime: 00:00.004, Memory: 8.00 MB\n\nThere was 1 error:\n\n1) Fido\\PHPXray\\DynamoSegmentTest::testSerialisesCorrectly\nUndefined array key \"request_id\"\n\n\/home\/ranpafin\/php-xray\/tests\/DynamoSegmentTest.php:22\n\nERRORS!\nTests: 1, Assertions: 2, Errors: 1."},{"mutator":{"mutatorName":"Ternary","originalSourceCode":"<?php\n\ndeclare (strict_types=1);\nnamespace Fido\\PHPXray;\n\nclass DynamoSegment extends RemoteSegment\n{\n    protected string $tableName;\n    protected string $operation;\n    protected string $requestId;\n    \/** @var string[] *\/\n    protected array $resourceNames;\n    public function setTableName(string $tableName) : self\n    {\n        $this->tableName = $tableName;\n        return $this;\n    }\n    public function setOperation(string $operation) : self\n    {\n        $this->operation = $operation;\n        return $this;\n    }\n    public function setRequestId(string $requestId) : self\n    {\n        $this->requestId = $requestId;\n        return $this;\n    }\n    public function addResourceName(string $value) : self\n    {\n        $this->resourceNames[] = $value;\n        return $this;\n    }\n    \/**\n     * @inheritdoc\n     *\/\n    public function jsonSerialize() : array\n    {\n        $data = parent::jsonSerialize();\n        $data['aws'] = ['table_name' => $this->tableName, 'operation' => $this->operation, 'request_id' => $this->requestId, 'resource_names' => $this->resourceNames ?: null];\n        return $data;\n    }\n}","mutatedSourceCode":"<?php\n\ndeclare (strict_types=1);\nnamespace Fido\\PHPXray;\n\nclass DynamoSegment extends RemoteSegment\n{\n    protected string $tableName;\n    protected string $operation;\n    protected string $requestId;\n    \/** @var string[] *\/\n    protected array $resourceNames;\n    public function setTableName(string $tableName) : self\n    {\n        $this->tableName = $tableName;\n        return $this;\n    }\n    public function setOperation(string $operation) : self\n    {\n        $this->operation = $operation;\n        return $this;\n    }\n    public function setRequestId(string $requestId) : self\n    {\n        $this->requestId = $requestId;\n        return $this;\n    }\n    public function addResourceName(string $value) : self\n    {\n        $this->resourceNames[] = $value;\n        return $this;\n    }\n    \/**\n     * @inheritdoc\n     *\/\n    public function jsonSerialize() : array\n    {\n        $data = parent::jsonSerialize();\n        $data['aws'] = ['table_name' => $this->tableName, 'operation' => $this->operation, 'request_id' => $this->requestId, 'resource_names' => $this->resourceNames ? null : $this->resourceNames];\n        return $data;\n    }\n}","originalFilePath":"\/home\/ranpafin\/php-xray\/src\/DynamoSegment.php","originalStartLine":55},"diff":"--- Original\n+++ New\n@@ @@\n     public function jsonSerialize() : array\n     {\n         $data = parent::jsonSerialize();\n-        $data['aws'] = ['table_name' => $this->tableName, 'operation' => $this->operation, 'request_id' => $this->requestId, 'resource_names' => $this->resourceNames ?: null];\n+        $data['aws'] = ['table_name' => $this->tableName, 'operation' => $this->operation, 'request_id' => $this->requestId, 'resource_names' => $this->resourceNames ? null : $this->resourceNames];\n         return $data;\n     }\n }","processOutput":"PHPUnit 9.5.10 by Sebastian Bergmann and contributors.\n\nRuntime:       PHP 8.0.13\nConfiguration: \/tmp\/tmp-folder\/infection\/phpunitConfiguration.dd500604a9e1d63289e41cd1a37c2f9d.infection.xml\n\nE                                                                   1 \/ 1 (100%)\n\nTime: 00:00.004, Memory: 8.00 MB\n\nThere was 1 error:\n\n1) Fido\\PHPXray\\DynamoSegmentTest::testSerialisesCorrectly\nTypeError: PHPUnit\\Framework\\Assert::assertContains(): Argument #2 ($haystack) must be of type iterable, null given, called in \/home\/ranpafin\/php-xray\/tests\/DynamoSegmentTest.php on line 23\n\n\/home\/ranpafin\/php-xray\/tests\/DynamoSegmentTest.php:23\n\nERRORS!\nTests: 1, Assertions: 3, Errors: 1."},{"mutator":{"mutatorName":"ArrayOneItem","originalSourceCode":"<?php\n\ndeclare (strict_types=1);\nnamespace Fido\\PHPXray;\n\nclass DynamoSegment extends RemoteSegment\n{\n    protected string $tableName;\n    protected string $operation;\n    protected string $requestId;\n    \/** @var string[] *\/\n    protected array $resourceNames;\n    public function setTableName(string $tableName) : self\n    {\n        $this->tableName = $tableName;\n        return $this;\n    }\n    public function setOperation(string $operation) : self\n    {\n        $this->operation = $operation;\n        return $this;\n    }\n    public function setRequestId(string $requestId) : self\n    {\n        $this->requestId = $requestId;\n        return $this;\n    }\n    public function addResourceName(string $value) : self\n    {\n        $this->resourceNames[] = $value;\n        return $this;\n    }\n    \/**\n     * @inheritdoc\n     *\/\n    public function jsonSerialize() : array\n    {\n        $data = parent::jsonSerialize();\n        $data['aws'] = ['table_name' => $this->tableName, 'operation' => $this->operation, 'request_id' => $this->requestId, 'resource_names' => $this->resourceNames ?: null];\n        return $data;\n    }\n}","mutatedSourceCode":"<?php\n\ndeclare (strict_types=1);\nnamespace Fido\\PHPXray;\n\nclass DynamoSegment extends RemoteSegment\n{\n    protected string $tableName;\n    protected string $operation;\n    protected string $requestId;\n    \/** @var string[] *\/\n    protected array $resourceNames;\n    public function setTableName(string $tableName) : self\n    {\n        $this->tableName = $tableName;\n        return $this;\n    }\n    public function setOperation(string $operation) : self\n    {\n        $this->operation = $operation;\n        return $this;\n    }\n    public function setRequestId(string $requestId) : self\n    {\n        $this->requestId = $requestId;\n        return $this;\n    }\n    public function addResourceName(string $value) : self\n    {\n        $this->resourceNames[] = $value;\n        return $this;\n    }\n    \/**\n     * @inheritdoc\n     *\/\n    public function jsonSerialize() : array\n    {\n        $data = parent::jsonSerialize();\n        $data['aws'] = ['table_name' => $this->tableName, 'operation' => $this->operation, 'request_id' => $this->requestId, 'resource_names' => $this->resourceNames ?: null];\n        return count($data) > 1 ? array_slice($data, 0, 1, true) : $data;\n    }\n}","originalFilePath":"\/home\/ranpafin\/php-xray\/src\/DynamoSegment.php","originalStartLine":58},"diff":"--- Original\n+++ New\n@@ @@\n     {\n         $data = parent::jsonSerialize();\n         $data['aws'] = ['table_name' => $this->tableName, 'operation' => $this->operation, 'request_id' => $this->requestId, 'resource_names' => $this->resourceNames ?: null];\n-        return $data;\n+        return count($data) > 1 ? array_slice($data, 0, 1, true) : $data;\n     }\n }","processOutput":"PHPUnit 9.5.10 by Sebastian Bergmann and contributors.\n\nRuntime:       PHP 8.0.13\nConfiguration: \/tmp\/tmp-folder\/infection\/phpunitConfiguration.8833e42cac7b6940e0508936a49866a6.infection.xml\n\nE                                                                   1 \/ 1 (100%)\n\nTime: 00:00.004, Memory: 8.00 MB\n\nThere was 1 error:\n\n1) Fido\\PHPXray\\DynamoSegmentTest::testSerialisesCorrectly\nUndefined array key \"aws\"\n\n\/home\/ranpafin\/php-xray\/tests\/DynamoSegmentTest.php:20\n\nERRORS!\nTests: 1, Assertions: 0, Errors: 1."},{"mutator":{"mutatorName":"PublicVisibility","originalSourceCode":"<?php\n\nnamespace Fido\\PHPXray;\n\ntrait HttpTrait\n{\n    protected string $url;\n    protected string $method;\n    protected string $clientIpAddress;\n    protected string $userAgent;\n    protected int $responseCode;\n    public function setUrl(string $url) : self\n    {\n        $this->url = $url;\n        return $this;\n    }\n    public function setMethod(string $method) : self\n    {\n        $this->method = $method;\n        return $this;\n    }\n    public function setResponseCode(int $responseCode) : self\n    {\n        $this->responseCode = $responseCode;\n        return $this;\n    }\n    \/**\n     * @return array{request: array<string, mixed>, response: array<string, mixed>}\n     *\/\n    protected function serialiseHttpData() : array\n    {\n        return ['request' => array_filter(['url' => $this->url ?? null, 'method' => $this->method ?? null, 'client_ip' => $this->clientIpAddress ?? null, 'user_agent' => $this->userAgent ?? null]), 'response' => array_filter(['status' => $this->responseCode ?? null])];\n    }\n}","mutatedSourceCode":"<?php\n\nnamespace Fido\\PHPXray;\n\ntrait HttpTrait\n{\n    protected string $url;\n    protected string $method;\n    protected string $clientIpAddress;\n    protected string $userAgent;\n    protected int $responseCode;\n    protected function setUrl(string $url) : self\n    {\n        $this->url = $url;\n        return $this;\n    }\n    public function setMethod(string $method) : self\n    {\n        $this->method = $method;\n        return $this;\n    }\n    public function setResponseCode(int $responseCode) : self\n    {\n        $this->responseCode = $responseCode;\n        return $this;\n    }\n    \/**\n     * @return array{request: array<string, mixed>, response: array<string, mixed>}\n     *\/\n    protected function serialiseHttpData() : array\n    {\n        return ['request' => array_filter(['url' => $this->url ?? null, 'method' => $this->method ?? null, 'client_ip' => $this->clientIpAddress ?? null, 'user_agent' => $this->userAgent ?? null]), 'response' => array_filter(['status' => $this->responseCode ?? null])];\n    }\n}","originalFilePath":"\/home\/ranpafin\/php-xray\/src\/HttpTrait.php","originalStartLine":13},"diff":"--- Original\n+++ New\n@@ @@\n     protected string $clientIpAddress;\n     protected string $userAgent;\n     protected int $responseCode;\n-    public function setUrl(string $url) : self\n+    protected function setUrl(string $url) : self\n     {\n         $this->url = $url;\n         return $this;","processOutput":"PHPUnit 9.5.10 by Sebastian Bergmann and contributors.\n\nRuntime:       PHP 8.0.13\nConfiguration: \/tmp\/tmp-folder\/infection\/phpunitConfiguration.c6868ca272328bd3ed110842b252e106.infection.xml\n\nE\n\nTime: 00:00.004, Memory: 8.00 MB\n\nThere was 1 error:\n\n1) Fido\\PHPXray\\HttpSegmentTest::testSerialisesCorrectly\nError: Call to protected method Fido\\PHPXray\\HttpSegment::setUrl() from scope Fido\\PHPXray\\HttpSegmentTest\n\n\/home\/ranpafin\/php-xray\/tests\/HttpSegmentTest.php:13\n\nERRORS!\nTests: 1, Assertions: 0, Errors: 1."},{"mutator":{"mutatorName":"PublicVisibility","originalSourceCode":"<?php\n\nnamespace Fido\\PHPXray;\n\ntrait HttpTrait\n{\n    protected string $url;\n    protected string $method;\n    protected string $clientIpAddress;\n    protected string $userAgent;\n    protected int $responseCode;\n    public function setUrl(string $url) : self\n    {\n        $this->url = $url;\n        return $this;\n    }\n    public function setMethod(string $method) : self\n    {\n        $this->method = $method;\n        return $this;\n    }\n    public function setResponseCode(int $responseCode) : self\n    {\n        $this->responseCode = $responseCode;\n        return $this;\n    }\n    \/**\n     * @return array{request: array<string, mixed>, response: array<string, mixed>}\n     *\/\n    protected function serialiseHttpData() : array\n    {\n        return ['request' => array_filter(['url' => $this->url ?? null, 'method' => $this->method ?? null, 'client_ip' => $this->clientIpAddress ?? null, 'user_agent' => $this->userAgent ?? null]), 'response' => array_filter(['status' => $this->responseCode ?? null])];\n    }\n}","mutatedSourceCode":"<?php\n\nnamespace Fido\\PHPXray;\n\ntrait HttpTrait\n{\n    protected string $url;\n    protected string $method;\n    protected string $clientIpAddress;\n    protected string $userAgent;\n    protected int $responseCode;\n    public function setUrl(string $url) : self\n    {\n        $this->url = $url;\n        return $this;\n    }\n    protected function setMethod(string $method) : self\n    {\n        $this->method = $method;\n        return $this;\n    }\n    public function setResponseCode(int $responseCode) : self\n    {\n        $this->responseCode = $responseCode;\n        return $this;\n    }\n    \/**\n     * @return array{request: array<string, mixed>, response: array<string, mixed>}\n     *\/\n    protected function serialiseHttpData() : array\n    {\n        return ['request' => array_filter(['url' => $this->url ?? null, 'method' => $this->method ?? null, 'client_ip' => $this->clientIpAddress ?? null, 'user_agent' => $this->userAgent ?? null]), 'response' => array_filter(['status' => $this->responseCode ?? null])];\n    }\n}","originalFilePath":"\/home\/ranpafin\/php-xray\/src\/HttpTrait.php","originalStartLine":20},"diff":"--- Original\n+++ New\n@@ @@\n         $this->url = $url;\n         return $this;\n     }\n-    public function setMethod(string $method) : self\n+    protected function setMethod(string $method) : self\n     {\n         $this->method = $method;\n         return $this;","processOutput":"PHPUnit 9.5.10 by Sebastian Bergmann and contributors.\n\nRuntime:       PHP 8.0.13\nConfiguration: \/tmp\/tmp-folder\/infection\/phpunitConfiguration.e352e446643268f737f458c5e216a283.infection.xml\n\nE\n\nTime: 00:00.004, Memory: 8.00 MB\n\nThere was 1 error:\n\n1) Fido\\PHPXray\\HttpSegmentTest::testSerialisesCorrectly\nError: Call to protected method Fido\\PHPXray\\HttpSegment::setMethod() from scope Fido\\PHPXray\\HttpSegmentTest\n\n\/home\/ranpafin\/php-xray\/tests\/HttpSegmentTest.php:14\n\nERRORS!\nTests: 1, Assertions: 0, Errors: 1."},{"mutator":{"mutatorName":"PublicVisibility","originalSourceCode":"<?php\n\nnamespace Fido\\PHPXray;\n\ntrait HttpTrait\n{\n    protected string $url;\n    protected string $method;\n    protected string $clientIpAddress;\n    protected string $userAgent;\n    protected int $responseCode;\n    public function setUrl(string $url) : self\n    {\n        $this->url = $url;\n        return $this;\n    }\n    public function setMethod(string $method) : self\n    {\n        $this->method = $method;\n        return $this;\n    }\n    public function setResponseCode(int $responseCode) : self\n    {\n        $this->responseCode = $responseCode;\n        return $this;\n    }\n    \/**\n     * @return array{request: array<string, mixed>, response: array<string, mixed>}\n     *\/\n    protected function serialiseHttpData() : array\n    {\n        return ['request' => array_filter(['url' => $this->url ?? null, 'method' => $this->method ?? null, 'client_ip' => $this->clientIpAddress ?? null, 'user_agent' => $this->userAgent ?? null]), 'response' => array_filter(['status' => $this->responseCode ?? null])];\n    }\n}","mutatedSourceCode":"<?php\n\nnamespace Fido\\PHPXray;\n\ntrait HttpTrait\n{\n    protected string $url;\n    protected string $method;\n    protected string $clientIpAddress;\n    protected string $userAgent;\n    protected int $responseCode;\n    public function setUrl(string $url) : self\n    {\n        $this->url = $url;\n        return $this;\n    }\n    public function setMethod(string $method) : self\n    {\n        $this->method = $method;\n        return $this;\n    }\n    protected function setResponseCode(int $responseCode) : self\n    {\n        $this->responseCode = $responseCode;\n        return $this;\n    }\n    \/**\n     * @return array{request: array<string, mixed>, response: array<string, mixed>}\n     *\/\n    protected function serialiseHttpData() : array\n    {\n        return ['request' => array_filter(['url' => $this->url ?? null, 'method' => $this->method ?? null, 'client_ip' => $this->clientIpAddress ?? null, 'user_agent' => $this->userAgent ?? null]), 'response' => array_filter(['status' => $this->responseCode ?? null])];\n    }\n}","originalFilePath":"\/home\/ranpafin\/php-xray\/src\/HttpTrait.php","originalStartLine":27},"diff":"--- Original\n+++ New\n@@ @@\n         $this->method = $method;\n         return $this;\n     }\n-    public function setResponseCode(int $responseCode) : self\n+    protected function setResponseCode(int $responseCode) : self\n     {\n         $this->responseCode = $responseCode;\n         return $this;","processOutput":"PHPUnit 9.5.10 by Sebastian Bergmann and contributors.\n\nRuntime:       PHP 8.0.13\nConfiguration: \/tmp\/tmp-folder\/infection\/phpunitConfiguration.209a6f3dd5b92dea9ea2c43385ffaee2.infection.xml\n\nE\n\nTime: 00:00.004, Memory: 8.00 MB\n\nThere was 1 error:\n\n1) Fido\\PHPXray\\HttpSegmentTest::testSerialisesCorrectly\nError: Call to protected method Fido\\PHPXray\\HttpSegment::setResponseCode() from scope Fido\\PHPXray\\HttpSegmentTest\n\n\/home\/ranpafin\/php-xray\/tests\/HttpSegmentTest.php:15\n\nERRORS!\nTests: 1, Assertions: 0, Errors: 1."},{"mutator":{"mutatorName":"ProtectedVisibility","originalSourceCode":"<?php\n\nnamespace Fido\\PHPXray;\n\ntrait HttpTrait\n{\n    protected string $url;\n    protected string $method;\n    protected string $clientIpAddress;\n    protected string $userAgent;\n    protected int $responseCode;\n    public function setUrl(string $url) : self\n    {\n        $this->url = $url;\n        return $this;\n    }\n    public function setMethod(string $method) : self\n    {\n        $this->method = $method;\n        return $this;\n    }\n    public function setResponseCode(int $responseCode) : self\n    {\n        $this->responseCode = $responseCode;\n        return $this;\n    }\n    \/**\n     * @return array{request: array<string, mixed>, response: array<string, mixed>}\n     *\/\n    protected function serialiseHttpData() : array\n    {\n        return ['request' => array_filter(['url' => $this->url ?? null, 'method' => $this->method ?? null, 'client_ip' => $this->clientIpAddress ?? null, 'user_agent' => $this->userAgent ?? null]), 'response' => array_filter(['status' => $this->responseCode ?? null])];\n    }\n}","mutatedSourceCode":"<?php\n\nnamespace Fido\\PHPXray;\n\ntrait HttpTrait\n{\n    protected string $url;\n    protected string $method;\n    protected string $clientIpAddress;\n    protected string $userAgent;\n    protected int $responseCode;\n    public function setUrl(string $url) : self\n    {\n        $this->url = $url;\n        return $this;\n    }\n    public function setMethod(string $method) : self\n    {\n        $this->method = $method;\n        return $this;\n    }\n    public function setResponseCode(int $responseCode) : self\n    {\n        $this->responseCode = $responseCode;\n        return $this;\n    }\n    \/**\n     * @return array{request: array<string, mixed>, response: array<string, mixed>}\n     *\/\n    private function serialiseHttpData() : array\n    {\n        return ['request' => array_filter(['url' => $this->url ?? null, 'method' => $this->method ?? null, 'client_ip' => $this->clientIpAddress ?? null, 'user_agent' => $this->userAgent ?? null]), 'response' => array_filter(['status' => $this->responseCode ?? null])];\n    }\n}","originalFilePath":"\/home\/ranpafin\/php-xray\/src\/HttpTrait.php","originalStartLine":37},"diff":"--- Original\n+++ New\n@@ @@\n     \/**\n      * @return array{request: array<string, mixed>, response: array<string, mixed>}\n      *\/\n-    protected function serialiseHttpData() : array\n+    private function serialiseHttpData() : array\n     {\n         return ['request' => array_filter(['url' => $this->url ?? null, 'method' => $this->method ?? null, 'client_ip' => $this->clientIpAddress ?? null, 'user_agent' => $this->userAgent ?? null]), 'response' => array_filter(['status' => $this->responseCode ?? null])];\n     }\n }","processOutput":"PHPUnit 9.5.10 by Sebastian Bergmann and contributors.\n\nRuntime:       PHP 8.0.13\nConfiguration: \/tmp\/tmp-folder\/infection\/phpunitConfiguration.36a871a5b5111bce901579f6f33dc6f1.infection.xml\n\nE\n\nTime: 00:00.003, Memory: 8.00 MB\n\nThere was 1 error:\n\n1) Fido\\PHPXray\\DaemonSegmentSubmitterTest::testSubmitsToDaemon\nsocket_bind(): Unable to bind address [98]: Address already in use\n\n\/home\/ranpafin\/php-xray\/tests\/DaemonSegmentSubmitterTest.php:18\n\nERRORS!\nTests: 1, Assertions: 0, Errors: 1."},{"mutator":{"mutatorName":"ArrayItemRemoval","originalSourceCode":"<?php\n\nnamespace Fido\\PHPXray;\n\ntrait HttpTrait\n{\n    protected string $url;\n    protected string $method;\n    protected string $clientIpAddress;\n    protected string $userAgent;\n    protected int $responseCode;\n    public function setUrl(string $url) : self\n    {\n        $this->url = $url;\n        return $this;\n    }\n    public function setMethod(string $method) : self\n    {\n        $this->method = $method;\n        return $this;\n    }\n    public function setResponseCode(int $responseCode) : self\n    {\n        $this->responseCode = $responseCode;\n        return $this;\n    }\n    \/**\n     * @return array{request: array<string, mixed>, response: array<string, mixed>}\n     *\/\n    protected function serialiseHttpData() : array\n    {\n        return ['request' => array_filter(['url' => $this->url ?? null, 'method' => $this->method ?? null, 'client_ip' => $this->clientIpAddress ?? null, 'user_agent' => $this->userAgent ?? null]), 'response' => array_filter(['status' => $this->responseCode ?? null])];\n    }\n}","mutatedSourceCode":"<?php\n\nnamespace Fido\\PHPXray;\n\ntrait HttpTrait\n{\n    protected string $url;\n    protected string $method;\n    protected string $clientIpAddress;\n    protected string $userAgent;\n    protected int $responseCode;\n    public function setUrl(string $url) : self\n    {\n        $this->url = $url;\n        return $this;\n    }\n    public function setMethod(string $method) : self\n    {\n        $this->method = $method;\n        return $this;\n    }\n    public function setResponseCode(int $responseCode) : self\n    {\n        $this->responseCode = $responseCode;\n        return $this;\n    }\n    \/**\n     * @return array{request: array<string, mixed>, response: array<string, mixed>}\n     *\/\n    protected function serialiseHttpData() : array\n    {\n        return ['response' => array_filter(['status' => $this->responseCode ?? null])];\n    }\n}","originalFilePath":"\/home\/ranpafin\/php-xray\/src\/HttpTrait.php","originalStartLine":39},"diff":"--- Original\n+++ New\n@@ @@\n      *\/\n     protected function serialiseHttpData() : array\n     {\n-        return ['request' => array_filter(['url' => $this->url ?? null, 'method' => $this->method ?? null, 'client_ip' => $this->clientIpAddress ?? null, 'user_agent' => $this->userAgent ?? null]), 'response' => array_filter(['status' => $this->responseCode ?? null])];\n+        return ['response' => array_filter(['status' => $this->responseCode ?? null])];\n     }\n }","processOutput":"PHPUnit 9.5.10 by Sebastian Bergmann and contributors.\n\nRuntime:       PHP 8.0.13\nConfiguration: \/tmp\/tmp-folder\/infection\/phpunitConfiguration.220558e625029572e3015d7d597fda9b.infection.xml\n\nE\n\nTime: 00:00.004, Memory: 8.00 MB\n\nThere was 1 error:\n\n1) Fido\\PHPXray\\HttpSegmentTest::testSerialisesCorrectly\nUndefined array key \"request\"\n\n\/home\/ranpafin\/php-xray\/tests\/HttpSegmentTest.php:21\n\nERRORS!\nTests: 1, Assertions: 1, Errors: 1."},{"mutator":{"mutatorName":"ArrayItemRemoval","originalSourceCode":"<?php\n\nnamespace Fido\\PHPXray;\n\ntrait HttpTrait\n{\n    protected string $url;\n    protected string $method;\n    protected string $clientIpAddress;\n    protected string $userAgent;\n    protected int $responseCode;\n    public function setUrl(string $url) : self\n    {\n        $this->url = $url;\n        return $this;\n    }\n    public function setMethod(string $method) : self\n    {\n        $this->method = $method;\n        return $this;\n    }\n    public function setResponseCode(int $responseCode) : self\n    {\n        $this->responseCode = $responseCode;\n        return $this;\n    }\n    \/**\n     * @return array{request: array<string, mixed>, response: array<string, mixed>}\n     *\/\n    protected function serialiseHttpData() : array\n    {\n        return ['request' => array_filter(['url' => $this->url ?? null, 'method' => $this->method ?? null, 'client_ip' => $this->clientIpAddress ?? null, 'user_agent' => $this->userAgent ?? null]), 'response' => array_filter(['status' => $this->responseCode ?? null])];\n    }\n}","mutatedSourceCode":"<?php\n\nnamespace Fido\\PHPXray;\n\ntrait HttpTrait\n{\n    protected string $url;\n    protected string $method;\n    protected string $clientIpAddress;\n    protected string $userAgent;\n    protected int $responseCode;\n    public function setUrl(string $url) : self\n    {\n        $this->url = $url;\n        return $this;\n    }\n    public function setMethod(string $method) : self\n    {\n        $this->method = $method;\n        return $this;\n    }\n    public function setResponseCode(int $responseCode) : self\n    {\n        $this->responseCode = $responseCode;\n        return $this;\n    }\n    \/**\n     * @return array{request: array<string, mixed>, response: array<string, mixed>}\n     *\/\n    protected function serialiseHttpData() : array\n    {\n        return ['request' => array_filter(['method' => $this->method ?? null, 'client_ip' => $this->clientIpAddress ?? null, 'user_agent' => $this->userAgent ?? null]), 'response' => array_filter(['status' => $this->responseCode ?? null])];\n    }\n}","originalFilePath":"\/home\/ranpafin\/php-xray\/src\/HttpTrait.php","originalStartLine":40},"diff":"--- Original\n+++ New\n@@ @@\n      *\/\n     protected function serialiseHttpData() : array\n     {\n-        return ['request' => array_filter(['url' => $this->url ?? null, 'method' => $this->method ?? null, 'client_ip' => $this->clientIpAddress ?? null, 'user_agent' => $this->userAgent ?? null]), 'response' => array_filter(['status' => $this->responseCode ?? null])];\n+        return ['request' => array_filter(['method' => $this->method ?? null, 'client_ip' => $this->clientIpAddress ?? null, 'user_agent' => $this->userAgent ?? null]), 'response' => array_filter(['status' => $this->responseCode ?? null])];\n     }\n }","processOutput":"PHPUnit 9.5.10 by Sebastian Bergmann and contributors.\n\nRuntime:       PHP 8.0.13\nConfiguration: \/tmp\/tmp-folder\/infection\/phpunitConfiguration.9de71d80ba2c5b875ca8becb75e99fff.infection.xml\n\nE\n\nTime: 00:00.005, Memory: 8.00 MB\n\nThere was 1 error:\n\n1) Fido\\PHPXray\\HttpSegmentTest::testSerialisesCorrectly\nUndefined array key \"url\"\n\n\/home\/ranpafin\/php-xray\/tests\/HttpSegmentTest.php:21\n\nERRORS!\nTests: 1, Assertions: 1, Errors: 1."},{"mutator":{"mutatorName":"UnwrapArrayFilter","originalSourceCode":"<?php\n\nnamespace Fido\\PHPXray;\n\ntrait HttpTrait\n{\n    protected string $url;\n    protected string $method;\n    protected string $clientIpAddress;\n    protected string $userAgent;\n    protected int $responseCode;\n    public function setUrl(string $url) : self\n    {\n        $this->url = $url;\n        return $this;\n    }\n    public function setMethod(string $method) : self\n    {\n        $this->method = $method;\n        return $this;\n    }\n    public function setResponseCode(int $responseCode) : self\n    {\n        $this->responseCode = $responseCode;\n        return $this;\n    }\n    \/**\n     * @return array{request: array<string, mixed>, response: array<string, mixed>}\n     *\/\n    protected function serialiseHttpData() : array\n    {\n        return ['request' => array_filter(['url' => $this->url ?? null, 'method' => $this->method ?? null, 'client_ip' => $this->clientIpAddress ?? null, 'user_agent' => $this->userAgent ?? null]), 'response' => array_filter(['status' => $this->responseCode ?? null])];\n    }\n}","mutatedSourceCode":"<?php\n\nnamespace Fido\\PHPXray;\n\ntrait HttpTrait\n{\n    protected string $url;\n    protected string $method;\n    protected string $clientIpAddress;\n    protected string $userAgent;\n    protected int $responseCode;\n    public function setUrl(string $url) : self\n    {\n        $this->url = $url;\n        return $this;\n    }\n    public function setMethod(string $method) : self\n    {\n        $this->method = $method;\n        return $this;\n    }\n    public function setResponseCode(int $responseCode) : self\n    {\n        $this->responseCode = $responseCode;\n        return $this;\n    }\n    \/**\n     * @return array{request: array<string, mixed>, response: array<string, mixed>}\n     *\/\n    protected function serialiseHttpData() : array\n    {\n        return ['request' => ['url' => $this->url ?? null, 'method' => $this->method ?? null, 'client_ip' => $this->clientIpAddress ?? null, 'user_agent' => $this->userAgent ?? null], 'response' => array_filter(['status' => $this->responseCode ?? null])];\n    }\n}","originalFilePath":"\/home\/ranpafin\/php-xray\/src\/HttpTrait.php","originalStartLine":40},"diff":"--- Original\n+++ New\n@@ @@\n      *\/\n     protected function serialiseHttpData() : array\n     {\n-        return ['request' => array_filter(['url' => $this->url ?? null, 'method' => $this->method ?? null, 'client_ip' => $this->clientIpAddress ?? null, 'user_agent' => $this->userAgent ?? null]), 'response' => array_filter(['status' => $this->responseCode ?? null])];\n+        return ['request' => ['url' => $this->url ?? null, 'method' => $this->method ?? null, 'client_ip' => $this->clientIpAddress ?? null, 'user_agent' => $this->userAgent ?? null], 'response' => array_filter(['status' => $this->responseCode ?? null])];\n     }\n }","processOutput":"PHPUnit 9.5.10 by Sebastian Bergmann and contributors.\n\nRuntime:       PHP 8.0.13\nConfiguration: \/tmp\/tmp-folder\/infection\/phpunitConfiguration.d48b774ff7d9fe22046cacb0bb5f9f9b.infection.xml\n\nE\n\nTime: 00:00.003, Memory: 8.00 MB\n\nThere was 1 error:\n\n1) Fido\\PHPXray\\DaemonSegmentSubmitterTest::testSubmitsToDaemon\nsocket_bind(): Unable to bind address [98]: Address already in use\n\n\/home\/ranpafin\/php-xray\/tests\/DaemonSegmentSubmitterTest.php:18\n\nERRORS!\nTests: 1, Assertions: 0, Errors: 1."},{"mutator":{"mutatorName":"ArrayItem","originalSourceCode":"<?php\n\nnamespace Fido\\PHPXray;\n\ntrait HttpTrait\n{\n    protected string $url;\n    protected string $method;\n    protected string $clientIpAddress;\n    protected string $userAgent;\n    protected int $responseCode;\n    public function setUrl(string $url) : self\n    {\n        $this->url = $url;\n        return $this;\n    }\n    public function setMethod(string $method) : self\n    {\n        $this->method = $method;\n        return $this;\n    }\n    public function setResponseCode(int $responseCode) : self\n    {\n        $this->responseCode = $responseCode;\n        return $this;\n    }\n    \/**\n     * @return array{request: array<string, mixed>, response: array<string, mixed>}\n     *\/\n    protected function serialiseHttpData() : array\n    {\n        return ['request' => array_filter(['url' => $this->url ?? null, 'method' => $this->method ?? null, 'client_ip' => $this->clientIpAddress ?? null, 'user_agent' => $this->userAgent ?? null]), 'response' => array_filter(['status' => $this->responseCode ?? null])];\n    }\n}","mutatedSourceCode":"<?php\n\nnamespace Fido\\PHPXray;\n\ntrait HttpTrait\n{\n    protected string $url;\n    protected string $method;\n    protected string $clientIpAddress;\n    protected string $userAgent;\n    protected int $responseCode;\n    public function setUrl(string $url) : self\n    {\n        $this->url = $url;\n        return $this;\n    }\n    public function setMethod(string $method) : self\n    {\n        $this->method = $method;\n        return $this;\n    }\n    public function setResponseCode(int $responseCode) : self\n    {\n        $this->responseCode = $responseCode;\n        return $this;\n    }\n    \/**\n     * @return array{request: array<string, mixed>, response: array<string, mixed>}\n     *\/\n    protected function serialiseHttpData() : array\n    {\n        return ['request' > array_filter(['url' => $this->url ?? null, 'method' => $this->method ?? null, 'client_ip' => $this->clientIpAddress ?? null, 'user_agent' => $this->userAgent ?? null]), 'response' => array_filter(['status' => $this->responseCode ?? null])];\n    }\n}","originalFilePath":"\/home\/ranpafin\/php-xray\/src\/HttpTrait.php","originalStartLine":40},"diff":"--- Original\n+++ New\n@@ @@\n      *\/\n     protected function serialiseHttpData() : array\n     {\n-        return ['request' => array_filter(['url' => $this->url ?? null, 'method' => $this->method ?? null, 'client_ip' => $this->clientIpAddress ?? null, 'user_agent' => $this->userAgent ?? null]), 'response' => array_filter(['status' => $this->responseCode ?? null])];\n+        return ['request' > array_filter(['url' => $this->url ?? null, 'method' => $this->method ?? null, 'client_ip' => $this->clientIpAddress ?? null, 'user_agent' => $this->userAgent ?? null]), 'response' => array_filter(['status' => $this->responseCode ?? null])];\n     }\n }","processOutput":"PHPUnit 9.5.10 by Sebastian Bergmann and contributors.\n\nRuntime:       PHP 8.0.13\nConfiguration: \/tmp\/tmp-folder\/infection\/phpunitConfiguration.88286e8b4e5a84397b91fed3de89421c.infection.xml\n\nE\n\nTime: 00:00.004, Memory: 8.00 MB\n\nThere was 1 error:\n\n1) Fido\\PHPXray\\HttpSegmentTest::testSerialisesCorrectly\nUndefined array key \"request\"\n\n\/home\/ranpafin\/php-xray\/tests\/HttpSegmentTest.php:21\n\nERRORS!\nTests: 1, Assertions: 1, Errors: 1."},{"mutator":{"mutatorName":"Coalesce","originalSourceCode":"<?php\n\nnamespace Fido\\PHPXray;\n\ntrait HttpTrait\n{\n    protected string $url;\n    protected string $method;\n    protected string $clientIpAddress;\n    protected string $userAgent;\n    protected int $responseCode;\n    public function setUrl(string $url) : self\n    {\n        $this->url = $url;\n        return $this;\n    }\n    public function setMethod(string $method) : self\n    {\n        $this->method = $method;\n        return $this;\n    }\n    public function setResponseCode(int $responseCode) : self\n    {\n        $this->responseCode = $responseCode;\n        return $this;\n    }\n    \/**\n     * @return array{request: array<string, mixed>, response: array<string, mixed>}\n     *\/\n    protected function serialiseHttpData() : array\n    {\n        return ['request' => array_filter(['url' => $this->url ?? null, 'method' => $this->method ?? null, 'client_ip' => $this->clientIpAddress ?? null, 'user_agent' => $this->userAgent ?? null]), 'response' => array_filter(['status' => $this->responseCode ?? null])];\n    }\n}","mutatedSourceCode":"<?php\n\nnamespace Fido\\PHPXray;\n\ntrait HttpTrait\n{\n    protected string $url;\n    protected string $method;\n    protected string $clientIpAddress;\n    protected string $userAgent;\n    protected int $responseCode;\n    public function setUrl(string $url) : self\n    {\n        $this->url = $url;\n        return $this;\n    }\n    public function setMethod(string $method) : self\n    {\n        $this->method = $method;\n        return $this;\n    }\n    public function setResponseCode(int $responseCode) : self\n    {\n        $this->responseCode = $responseCode;\n        return $this;\n    }\n    \/**\n     * @return array{request: array<string, mixed>, response: array<string, mixed>}\n     *\/\n    protected function serialiseHttpData() : array\n    {\n        return ['request' => array_filter(['url' => null ?? $this->url, 'method' => $this->method ?? null, 'client_ip' => $this->clientIpAddress ?? null, 'user_agent' => $this->userAgent ?? null]), 'response' => array_filter(['status' => $this->responseCode ?? null])];\n    }\n}","originalFilePath":"\/home\/ranpafin\/php-xray\/src\/HttpTrait.php","originalStartLine":41},"diff":"--- Original\n+++ New\n@@ @@\n      *\/\n     protected function serialiseHttpData() : array\n     {\n-        return ['request' => array_filter(['url' => $this->url ?? null, 'method' => $this->method ?? null, 'client_ip' => $this->clientIpAddress ?? null, 'user_agent' => $this->userAgent ?? null]), 'response' => array_filter(['status' => $this->responseCode ?? null])];\n+        return ['request' => array_filter(['url' => null ?? $this->url, 'method' => $this->method ?? null, 'client_ip' => $this->clientIpAddress ?? null, 'user_agent' => $this->userAgent ?? null]), 'response' => array_filter(['status' => $this->responseCode ?? null])];\n     }\n }","processOutput":"PHPUnit 9.5.10 by Sebastian Bergmann and contributors.\n\nRuntime:       PHP 8.0.13\nConfiguration: \/tmp\/tmp-folder\/infection\/phpunitConfiguration.276ee7c8192b13e6c7bf68e8dee520ae.infection.xml\n\nE\n\nTime: 00:00.004, Memory: 8.00 MB\n\nThere was 1 error:\n\n1) Fido\\PHPXray\\DaemonSegmentSubmitterTest::testSubmitsToDaemon\nsocket_bind(): Unable to bind address [98]: Address already in use\n\n\/home\/ranpafin\/php-xray\/tests\/DaemonSegmentSubmitterTest.php:18\n\nERRORS!\nTests: 1, Assertions: 0, Errors: 1."},{"mutator":{"mutatorName":"Coalesce","originalSourceCode":"<?php\n\nnamespace Fido\\PHPXray;\n\ntrait HttpTrait\n{\n    protected string $url;\n    protected string $method;\n    protected string $clientIpAddress;\n    protected string $userAgent;\n    protected int $responseCode;\n    public function setUrl(string $url) : self\n    {\n        $this->url = $url;\n        return $this;\n    }\n    public function setMethod(string $method) : self\n    {\n        $this->method = $method;\n        return $this;\n    }\n    public function setResponseCode(int $responseCode) : self\n    {\n        $this->responseCode = $responseCode;\n        return $this;\n    }\n    \/**\n     * @return array{request: array<string, mixed>, response: array<string, mixed>}\n     *\/\n    protected function serialiseHttpData() : array\n    {\n        return ['request' => array_filter(['url' => $this->url ?? null, 'method' => $this->method ?? null, 'client_ip' => $this->clientIpAddress ?? null, 'user_agent' => $this->userAgent ?? null]), 'response' => array_filter(['status' => $this->responseCode ?? null])];\n    }\n}","mutatedSourceCode":"<?php\n\nnamespace Fido\\PHPXray;\n\ntrait HttpTrait\n{\n    protected string $url;\n    protected string $method;\n    protected string $clientIpAddress;\n    protected string $userAgent;\n    protected int $responseCode;\n    public function setUrl(string $url) : self\n    {\n        $this->url = $url;\n        return $this;\n    }\n    public function setMethod(string $method) : self\n    {\n        $this->method = $method;\n        return $this;\n    }\n    public function setResponseCode(int $responseCode) : self\n    {\n        $this->responseCode = $responseCode;\n        return $this;\n    }\n    \/**\n     * @return array{request: array<string, mixed>, response: array<string, mixed>}\n     *\/\n    protected function serialiseHttpData() : array\n    {\n        return ['request' => array_filter(['url' => $this->url ?? null, 'method' => null ?? $this->method, 'client_ip' => $this->clientIpAddress ?? null, 'user_agent' => $this->userAgent ?? null]), 'response' => array_filter(['status' => $this->responseCode ?? null])];\n    }\n}","originalFilePath":"\/home\/ranpafin\/php-xray\/src\/HttpTrait.php","originalStartLine":42},"diff":"--- Original\n+++ New\n@@ @@\n      *\/\n     protected function serialiseHttpData() : array\n     {\n-        return ['request' => array_filter(['url' => $this->url ?? null, 'method' => $this->method ?? null, 'client_ip' => $this->clientIpAddress ?? null, 'user_agent' => $this->userAgent ?? null]), 'response' => array_filter(['status' => $this->responseCode ?? null])];\n+        return ['request' => array_filter(['url' => $this->url ?? null, 'method' => null ?? $this->method, 'client_ip' => $this->clientIpAddress ?? null, 'user_agent' => $this->userAgent ?? null]), 'response' => array_filter(['status' => $this->responseCode ?? null])];\n     }\n }","processOutput":"PHPUnit 9.5.10 by Sebastian Bergmann and contributors.\n\nRuntime:       PHP 8.0.13\nConfiguration: \/tmp\/tmp-folder\/infection\/phpunitConfiguration.b47505b3705a37670d464bf44ae0db17.infection.xml\n\nE\n\nTime: 00:00.003, Memory: 8.00 MB\n\nThere was 1 error:\n\n1) Fido\\PHPXray\\DaemonSegmentSubmitterTest::testSubmitsToDaemon\nsocket_bind(): Unable to bind address [98]: Address already in use\n\n\/home\/ranpafin\/php-xray\/tests\/DaemonSegmentSubmitterTest.php:18\n\nERRORS!\nTests: 1, Assertions: 0, Errors: 1."},{"mutator":{"mutatorName":"Coalesce","originalSourceCode":"<?php\n\nnamespace Fido\\PHPXray;\n\ntrait HttpTrait\n{\n    protected string $url;\n    protected string $method;\n    protected string $clientIpAddress;\n    protected string $userAgent;\n    protected int $responseCode;\n    public function setUrl(string $url) : self\n    {\n        $this->url = $url;\n        return $this;\n    }\n    public function setMethod(string $method) : self\n    {\n        $this->method = $method;\n        return $this;\n    }\n    public function setResponseCode(int $responseCode) : self\n    {\n        $this->responseCode = $responseCode;\n        return $this;\n    }\n    \/**\n     * @return array{request: array<string, mixed>, response: array<string, mixed>}\n     *\/\n    protected function serialiseHttpData() : array\n    {\n        return ['request' => array_filter(['url' => $this->url ?? null, 'method' => $this->method ?? null, 'client_ip' => $this->clientIpAddress ?? null, 'user_agent' => $this->userAgent ?? null]), 'response' => array_filter(['status' => $this->responseCode ?? null])];\n    }\n}","mutatedSourceCode":"<?php\n\nnamespace Fido\\PHPXray;\n\ntrait HttpTrait\n{\n    protected string $url;\n    protected string $method;\n    protected string $clientIpAddress;\n    protected string $userAgent;\n    protected int $responseCode;\n    public function setUrl(string $url) : self\n    {\n        $this->url = $url;\n        return $this;\n    }\n    public function setMethod(string $method) : self\n    {\n        $this->method = $method;\n        return $this;\n    }\n    public function setResponseCode(int $responseCode) : self\n    {\n        $this->responseCode = $responseCode;\n        return $this;\n    }\n    \/**\n     * @return array{request: array<string, mixed>, response: array<string, mixed>}\n     *\/\n    protected function serialiseHttpData() : array\n    {\n        return ['request' => array_filter(['url' => $this->url ?? null, 'method' => $this->method ?? null, 'client_ip' => null ?? $this->clientIpAddress, 'user_agent' => $this->userAgent ?? null]), 'response' => array_filter(['status' => $this->responseCode ?? null])];\n    }\n}","originalFilePath":"\/home\/ranpafin\/php-xray\/src\/HttpTrait.php","originalStartLine":43},"diff":"--- Original\n+++ New\n@@ @@\n      *\/\n     protected function serialiseHttpData() : array\n     {\n-        return ['request' => array_filter(['url' => $this->url ?? null, 'method' => $this->method ?? null, 'client_ip' => $this->clientIpAddress ?? null, 'user_agent' => $this->userAgent ?? null]), 'response' => array_filter(['status' => $this->responseCode ?? null])];\n+        return ['request' => array_filter(['url' => $this->url ?? null, 'method' => $this->method ?? null, 'client_ip' => null ?? $this->clientIpAddress, 'user_agent' => $this->userAgent ?? null]), 'response' => array_filter(['status' => $this->responseCode ?? null])];\n     }\n }","processOutput":"PHPUnit 9.5.10 by Sebastian Bergmann and contributors.\n\nRuntime:       PHP 8.0.13\nConfiguration: \/tmp\/tmp-folder\/infection\/phpunitConfiguration.21e5b762c29043353b17d2710fc474bd.infection.xml\n\nE\n\nTime: 00:00.004, Memory: 8.00 MB\n\nThere was 1 error:\n\n1) Fido\\PHPXray\\HttpSegmentTest::testSerialisesCorrectly\nError: Typed property Fido\\PHPXray\\HttpSegment::$clientIpAddress must not be accessed before initialization\n\n\/home\/ranpafin\/php-xray\/src\/HttpTrait.php:32\n\/home\/ranpafin\/php-xray\/src\/HttpSegment.php:16\n\/home\/ranpafin\/php-xray\/tests\/HttpSegmentTest.php:18\n\nERRORS!\nTests: 1, Assertions: 0, Errors: 1."},{"mutator":{"mutatorName":"Coalesce","originalSourceCode":"<?php\n\nnamespace Fido\\PHPXray;\n\ntrait HttpTrait\n{\n    protected string $url;\n    protected string $method;\n    protected string $clientIpAddress;\n    protected string $userAgent;\n    protected int $responseCode;\n    public function setUrl(string $url) : self\n    {\n        $this->url = $url;\n        return $this;\n    }\n    public function setMethod(string $method) : self\n    {\n        $this->method = $method;\n        return $this;\n    }\n    public function setResponseCode(int $responseCode) : self\n    {\n        $this->responseCode = $responseCode;\n        return $this;\n    }\n    \/**\n     * @return array{request: array<string, mixed>, response: array<string, mixed>}\n     *\/\n    protected function serialiseHttpData() : array\n    {\n        return ['request' => array_filter(['url' => $this->url ?? null, 'method' => $this->method ?? null, 'client_ip' => $this->clientIpAddress ?? null, 'user_agent' => $this->userAgent ?? null]), 'response' => array_filter(['status' => $this->responseCode ?? null])];\n    }\n}","mutatedSourceCode":"<?php\n\nnamespace Fido\\PHPXray;\n\ntrait HttpTrait\n{\n    protected string $url;\n    protected string $method;\n    protected string $clientIpAddress;\n    protected string $userAgent;\n    protected int $responseCode;\n    public function setUrl(string $url) : self\n    {\n        $this->url = $url;\n        return $this;\n    }\n    public function setMethod(string $method) : self\n    {\n        $this->method = $method;\n        return $this;\n    }\n    public function setResponseCode(int $responseCode) : self\n    {\n        $this->responseCode = $responseCode;\n        return $this;\n    }\n    \/**\n     * @return array{request: array<string, mixed>, response: array<string, mixed>}\n     *\/\n    protected function serialiseHttpData() : array\n    {\n        return ['request' => array_filter(['url' => $this->url ?? null, 'method' => $this->method ?? null, 'client_ip' => $this->clientIpAddress ?? null, 'user_agent' => null ?? $this->userAgent]), 'response' => array_filter(['status' => $this->responseCode ?? null])];\n    }\n}","originalFilePath":"\/home\/ranpafin\/php-xray\/src\/HttpTrait.php","originalStartLine":44},"diff":"--- Original\n+++ New\n@@ @@\n      *\/\n     protected function serialiseHttpData() : array\n     {\n-        return ['request' => array_filter(['url' => $this->url ?? null, 'method' => $this->method ?? null, 'client_ip' => $this->clientIpAddress ?? null, 'user_agent' => $this->userAgent ?? null]), 'response' => array_filter(['status' => $this->responseCode ?? null])];\n+        return ['request' => array_filter(['url' => $this->url ?? null, 'method' => $this->method ?? null, 'client_ip' => $this->clientIpAddress ?? null, 'user_agent' => null ?? $this->userAgent]), 'response' => array_filter(['status' => $this->responseCode ?? null])];\n     }\n }","processOutput":"PHPUnit 9.5.10 by Sebastian Bergmann and contributors.\n\nRuntime:       PHP 8.0.13\nConfiguration: \/tmp\/tmp-folder\/infection\/phpunitConfiguration.b37646410b92cd6a7be15fcf3631c5f5.infection.xml\n\nE\n\nTime: 00:00.004, Memory: 8.00 MB\n\nThere was 1 error:\n\n1) Fido\\PHPXray\\HttpSegmentTest::testSerialisesCorrectly\nError: Typed property Fido\\PHPXray\\HttpSegment::$userAgent must not be accessed before initialization\n\n\/home\/ranpafin\/php-xray\/src\/HttpTrait.php:32\n\/home\/ranpafin\/php-xray\/src\/HttpSegment.php:16\n\/home\/ranpafin\/php-xray\/tests\/HttpSegmentTest.php:18\n\nERRORS!\nTests: 1, Assertions: 0, Errors: 1."},{"mutator":{"mutatorName":"ArrayItemRemoval","originalSourceCode":"<?php\n\nnamespace Fido\\PHPXray;\n\ntrait HttpTrait\n{\n    protected string $url;\n    protected string $method;\n    protected string $clientIpAddress;\n    protected string $userAgent;\n    protected int $responseCode;\n    public function setUrl(string $url) : self\n    {\n        $this->url = $url;\n        return $this;\n    }\n    public function setMethod(string $method) : self\n    {\n        $this->method = $method;\n        return $this;\n    }\n    public function setResponseCode(int $responseCode) : self\n    {\n        $this->responseCode = $responseCode;\n        return $this;\n    }\n    \/**\n     * @return array{request: array<string, mixed>, response: array<string, mixed>}\n     *\/\n    protected function serialiseHttpData() : array\n    {\n        return ['request' => array_filter(['url' => $this->url ?? null, 'method' => $this->method ?? null, 'client_ip' => $this->clientIpAddress ?? null, 'user_agent' => $this->userAgent ?? null]), 'response' => array_filter(['status' => $this->responseCode ?? null])];\n    }\n}","mutatedSourceCode":"<?php\n\nnamespace Fido\\PHPXray;\n\ntrait HttpTrait\n{\n    protected string $url;\n    protected string $method;\n    protected string $clientIpAddress;\n    protected string $userAgent;\n    protected int $responseCode;\n    public function setUrl(string $url) : self\n    {\n        $this->url = $url;\n        return $this;\n    }\n    public function setMethod(string $method) : self\n    {\n        $this->method = $method;\n        return $this;\n    }\n    public function setResponseCode(int $responseCode) : self\n    {\n        $this->responseCode = $responseCode;\n        return $this;\n    }\n    \/**\n     * @return array{request: array<string, mixed>, response: array<string, mixed>}\n     *\/\n    protected function serialiseHttpData() : array\n    {\n        return ['request' => array_filter(['url' => $this->url ?? null, 'method' => $this->method ?? null, 'client_ip' => $this->clientIpAddress ?? null, 'user_agent' => $this->userAgent ?? null]), 'response' => array_filter([])];\n    }\n}","originalFilePath":"\/home\/ranpafin\/php-xray\/src\/HttpTrait.php","originalStartLine":46},"diff":"--- Original\n+++ New\n@@ @@\n      *\/\n     protected function serialiseHttpData() : array\n     {\n-        return ['request' => array_filter(['url' => $this->url ?? null, 'method' => $this->method ?? null, 'client_ip' => $this->clientIpAddress ?? null, 'user_agent' => $this->userAgent ?? null]), 'response' => array_filter(['status' => $this->responseCode ?? null])];\n+        return ['request' => array_filter(['url' => $this->url ?? null, 'method' => $this->method ?? null, 'client_ip' => $this->clientIpAddress ?? null, 'user_agent' => $this->userAgent ?? null]), 'response' => array_filter([])];\n     }\n }","processOutput":"PHPUnit 9.5.10 by Sebastian Bergmann and contributors.\n\nRuntime:       PHP 8.0.13\nConfiguration: \/tmp\/tmp-folder\/infection\/phpunitConfiguration.38681ac408845919be6afa6f09330394.infection.xml\n\nE\n\nTime: 00:00.003, Memory: 8.00 MB\n\nThere was 1 error:\n\n1) Fido\\PHPXray\\HttpSegmentTest::testSerialisesCorrectly\nUndefined array key \"status\"\n\n\/home\/ranpafin\/php-xray\/tests\/HttpSegmentTest.php:23\n\nERRORS!\nTests: 1, Assertions: 3, Errors: 1."},{"mutator":{"mutatorName":"UnwrapArrayFilter","originalSourceCode":"<?php\n\nnamespace Fido\\PHPXray;\n\ntrait HttpTrait\n{\n    protected string $url;\n    protected string $method;\n    protected string $clientIpAddress;\n    protected string $userAgent;\n    protected int $responseCode;\n    public function setUrl(string $url) : self\n    {\n        $this->url = $url;\n        return $this;\n    }\n    public function setMethod(string $method) : self\n    {\n        $this->method = $method;\n        return $this;\n    }\n    public function setResponseCode(int $responseCode) : self\n    {\n        $this->responseCode = $responseCode;\n        return $this;\n    }\n    \/**\n     * @return array{request: array<string, mixed>, response: array<string, mixed>}\n     *\/\n    protected function serialiseHttpData() : array\n    {\n        return ['request' => array_filter(['url' => $this->url ?? null, 'method' => $this->method ?? null, 'client_ip' => $this->clientIpAddress ?? null, 'user_agent' => $this->userAgent ?? null]), 'response' => array_filter(['status' => $this->responseCode ?? null])];\n    }\n}","mutatedSourceCode":"<?php\n\nnamespace Fido\\PHPXray;\n\ntrait HttpTrait\n{\n    protected string $url;\n    protected string $method;\n    protected string $clientIpAddress;\n    protected string $userAgent;\n    protected int $responseCode;\n    public function setUrl(string $url) : self\n    {\n        $this->url = $url;\n        return $this;\n    }\n    public function setMethod(string $method) : self\n    {\n        $this->method = $method;\n        return $this;\n    }\n    public function setResponseCode(int $responseCode) : self\n    {\n        $this->responseCode = $responseCode;\n        return $this;\n    }\n    \/**\n     * @return array{request: array<string, mixed>, response: array<string, mixed>}\n     *\/\n    protected function serialiseHttpData() : array\n    {\n        return ['request' => array_filter(['url' => $this->url ?? null, 'method' => $this->method ?? null, 'client_ip' => $this->clientIpAddress ?? null, 'user_agent' => $this->userAgent ?? null]), 'response' => ['status' => $this->responseCode ?? null]];\n    }\n}","originalFilePath":"\/home\/ranpafin\/php-xray\/src\/HttpTrait.php","originalStartLine":46},"diff":"--- Original\n+++ New\n@@ @@\n      *\/\n     protected function serialiseHttpData() : array\n     {\n-        return ['request' => array_filter(['url' => $this->url ?? null, 'method' => $this->method ?? null, 'client_ip' => $this->clientIpAddress ?? null, 'user_agent' => $this->userAgent ?? null]), 'response' => array_filter(['status' => $this->responseCode ?? null])];\n+        return ['request' => array_filter(['url' => $this->url ?? null, 'method' => $this->method ?? null, 'client_ip' => $this->clientIpAddress ?? null, 'user_agent' => $this->userAgent ?? null]), 'response' => ['status' => $this->responseCode ?? null]];\n     }\n }","processOutput":"PHPUnit 9.5.10 by Sebastian Bergmann and contributors.\n\nRuntime:       PHP 8.0.13\nConfiguration: \/tmp\/tmp-folder\/infection\/phpunitConfiguration.61d1ee7bc6cd0fbfaf63575f33ff15c7.infection.xml\n\nE\n\nTime: 00:00.004, Memory: 8.00 MB\n\nThere was 1 error:\n\n1) Fido\\PHPXray\\DaemonSegmentSubmitterTest::testSubmitsToDaemon\nsocket_bind(): Unable to bind address [98]: Address already in use\n\n\/home\/ranpafin\/php-xray\/tests\/DaemonSegmentSubmitterTest.php:18\n\nERRORS!\nTests: 1, Assertions: 0, Errors: 1."},{"mutator":{"mutatorName":"ArrayItem","originalSourceCode":"<?php\n\nnamespace Fido\\PHPXray;\n\ntrait HttpTrait\n{\n    protected string $url;\n    protected string $method;\n    protected string $clientIpAddress;\n    protected string $userAgent;\n    protected int $responseCode;\n    public function setUrl(string $url) : self\n    {\n        $this->url = $url;\n        return $this;\n    }\n    public function setMethod(string $method) : self\n    {\n        $this->method = $method;\n        return $this;\n    }\n    public function setResponseCode(int $responseCode) : self\n    {\n        $this->responseCode = $responseCode;\n        return $this;\n    }\n    \/**\n     * @return array{request: array<string, mixed>, response: array<string, mixed>}\n     *\/\n    protected function serialiseHttpData() : array\n    {\n        return ['request' => array_filter(['url' => $this->url ?? null, 'method' => $this->method ?? null, 'client_ip' => $this->clientIpAddress ?? null, 'user_agent' => $this->userAgent ?? null]), 'response' => array_filter(['status' => $this->responseCode ?? null])];\n    }\n}","mutatedSourceCode":"<?php\n\nnamespace Fido\\PHPXray;\n\ntrait HttpTrait\n{\n    protected string $url;\n    protected string $method;\n    protected string $clientIpAddress;\n    protected string $userAgent;\n    protected int $responseCode;\n    public function setUrl(string $url) : self\n    {\n        $this->url = $url;\n        return $this;\n    }\n    public function setMethod(string $method) : self\n    {\n        $this->method = $method;\n        return $this;\n    }\n    public function setResponseCode(int $responseCode) : self\n    {\n        $this->responseCode = $responseCode;\n        return $this;\n    }\n    \/**\n     * @return array{request: array<string, mixed>, response: array<string, mixed>}\n     *\/\n    protected function serialiseHttpData() : array\n    {\n        return ['request' => array_filter(['url' => $this->url ?? null, 'method' => $this->method ?? null, 'client_ip' => $this->clientIpAddress ?? null, 'user_agent' => $this->userAgent ?? null]), 'response' > array_filter(['status' => $this->responseCode ?? null])];\n    }\n}","originalFilePath":"\/home\/ranpafin\/php-xray\/src\/HttpTrait.php","originalStartLine":46},"diff":"--- Original\n+++ New\n@@ @@\n      *\/\n     protected function serialiseHttpData() : array\n     {\n-        return ['request' => array_filter(['url' => $this->url ?? null, 'method' => $this->method ?? null, 'client_ip' => $this->clientIpAddress ?? null, 'user_agent' => $this->userAgent ?? null]), 'response' => array_filter(['status' => $this->responseCode ?? null])];\n+        return ['request' => array_filter(['url' => $this->url ?? null, 'method' => $this->method ?? null, 'client_ip' => $this->clientIpAddress ?? null, 'user_agent' => $this->userAgent ?? null]), 'response' > array_filter(['status' => $this->responseCode ?? null])];\n     }\n }","processOutput":"PHPUnit 9.5.10 by Sebastian Bergmann and contributors.\n\nRuntime:       PHP 8.0.13\nConfiguration: \/tmp\/tmp-folder\/infection\/phpunitConfiguration.31ae56345730c6c41f234f3053da278e.infection.xml\n\nE\n\nTime: 00:00.004, Memory: 8.00 MB\n\nThere was 1 error:\n\n1) Fido\\PHPXray\\HttpSegmentTest::testSerialisesCorrectly\nUndefined array key \"response\"\n\n\/home\/ranpafin\/php-xray\/tests\/HttpSegmentTest.php:23\n\nERRORS!\nTests: 1, Assertions: 3, Errors: 1."},{"mutator":{"mutatorName":"Coalesce","originalSourceCode":"<?php\n\nnamespace Fido\\PHPXray;\n\ntrait HttpTrait\n{\n    protected string $url;\n    protected string $method;\n    protected string $clientIpAddress;\n    protected string $userAgent;\n    protected int $responseCode;\n    public function setUrl(string $url) : self\n    {\n        $this->url = $url;\n        return $this;\n    }\n    public function setMethod(string $method) : self\n    {\n        $this->method = $method;\n        return $this;\n    }\n    public function setResponseCode(int $responseCode) : self\n    {\n        $this->responseCode = $responseCode;\n        return $this;\n    }\n    \/**\n     * @return array{request: array<string, mixed>, response: array<string, mixed>}\n     *\/\n    protected function serialiseHttpData() : array\n    {\n        return ['request' => array_filter(['url' => $this->url ?? null, 'method' => $this->method ?? null, 'client_ip' => $this->clientIpAddress ?? null, 'user_agent' => $this->userAgent ?? null]), 'response' => array_filter(['status' => $this->responseCode ?? null])];\n    }\n}","mutatedSourceCode":"<?php\n\nnamespace Fido\\PHPXray;\n\ntrait HttpTrait\n{\n    protected string $url;\n    protected string $method;\n    protected string $clientIpAddress;\n    protected string $userAgent;\n    protected int $responseCode;\n    public function setUrl(string $url) : self\n    {\n        $this->url = $url;\n        return $this;\n    }\n    public function setMethod(string $method) : self\n    {\n        $this->method = $method;\n        return $this;\n    }\n    public function setResponseCode(int $responseCode) : self\n    {\n        $this->responseCode = $responseCode;\n        return $this;\n    }\n    \/**\n     * @return array{request: array<string, mixed>, response: array<string, mixed>}\n     *\/\n    protected function serialiseHttpData() : array\n    {\n        return ['request' => array_filter(['url' => $this->url ?? null, 'method' => $this->method ?? null, 'client_ip' => $this->clientIpAddress ?? null, 'user_agent' => $this->userAgent ?? null]), 'response' => array_filter(['status' => null ?? $this->responseCode])];\n    }\n}","originalFilePath":"\/home\/ranpafin\/php-xray\/src\/HttpTrait.php","originalStartLine":47},"diff":"--- Original\n+++ New\n@@ @@\n      *\/\n     protected function serialiseHttpData() : array\n     {\n-        return ['request' => array_filter(['url' => $this->url ?? null, 'method' => $this->method ?? null, 'client_ip' => $this->clientIpAddress ?? null, 'user_agent' => $this->userAgent ?? null]), 'response' => array_filter(['status' => $this->responseCode ?? null])];\n+        return ['request' => array_filter(['url' => $this->url ?? null, 'method' => $this->method ?? null, 'client_ip' => $this->clientIpAddress ?? null, 'user_agent' => $this->userAgent ?? null]), 'response' => array_filter(['status' => null ?? $this->responseCode])];\n     }\n }","processOutput":"PHPUnit 9.5.10 by Sebastian Bergmann and contributors.\n\nRuntime:       PHP 8.0.13\nConfiguration: \/tmp\/tmp-folder\/infection\/phpunitConfiguration.15fde9e778979dffc1cb962ec6798499.infection.xml\n\nE\n\nTime: 00:00.003, Memory: 8.00 MB\n\nThere was 1 error:\n\n1) Fido\\PHPXray\\DaemonSegmentSubmitterTest::testSubmitsToDaemon\nsocket_bind(): Unable to bind address [98]: Address already in use\n\n\/home\/ranpafin\/php-xray\/tests\/DaemonSegmentSubmitterTest.php:18\n\nERRORS!\nTests: 1, Assertions: 0, Errors: 1."},{"mutator":{"mutatorName":"PublicVisibility","originalSourceCode":"<?php\n\nnamespace Fido\\PHPXray;\n\nclass RemoteSegment extends Segment\n{\n    protected bool $traced = false;\n    public function setTraced(bool $traced) : self\n    {\n        $this->traced = $traced;\n        return $this;\n    }\n    \/**\n     * @inheritdoc\n     *\/\n    public function jsonSerialize() : array\n    {\n        $data = parent::jsonSerialize();\n        $data['namespace'] = 'remote';\n        $data['traced'] = $this->traced;\n        return array_filter($data);\n    }\n}","mutatedSourceCode":"<?php\n\nnamespace Fido\\PHPXray;\n\nclass RemoteSegment extends Segment\n{\n    protected bool $traced = false;\n    protected function setTraced(bool $traced) : self\n    {\n        $this->traced = $traced;\n        return $this;\n    }\n    \/**\n     * @inheritdoc\n     *\/\n    public function jsonSerialize() : array\n    {\n        $data = parent::jsonSerialize();\n        $data['namespace'] = 'remote';\n        $data['traced'] = $this->traced;\n        return array_filter($data);\n    }\n}","originalFilePath":"\/home\/ranpafin\/php-xray\/src\/RemoteSegment.php","originalStartLine":9},"diff":"--- Original\n+++ New\n@@ @@\n class RemoteSegment extends Segment\n {\n     protected bool $traced = false;\n-    public function setTraced(bool $traced) : self\n+    protected function setTraced(bool $traced) : self\n     {\n         $this->traced = $traced;\n         return $this;","processOutput":"PHPUnit 9.5.10 by Sebastian Bergmann and contributors.\n\nRuntime:       PHP 8.0.13\nConfiguration: \/tmp\/tmp-folder\/infection\/phpunitConfiguration.d76d45d539b468f8e7c07cb226b0d4b2.infection.xml\n\nE\n\nTime: 00:00.003, Memory: 8.00 MB\n\nThere was 1 error:\n\n1) Fido\\PHPXray\\RemoteSegmentTest::testTracedSegmentSerialisesCorrectly\nError: Call to protected method Fido\\PHPXray\\RemoteSegment::setTraced() from scope Fido\\PHPXray\\RemoteSegmentTest\n\n\/home\/ranpafin\/php-xray\/tests\/RemoteSegmentTest.php:23\n\nERRORS!\nTests: 1, Assertions: 0, Errors: 1."},{"mutator":{"mutatorName":"UnwrapArrayFilter","originalSourceCode":"<?php\n\nnamespace Fido\\PHPXray;\n\nclass RemoteSegment extends Segment\n{\n    protected bool $traced = false;\n    public function setTraced(bool $traced) : self\n    {\n        $this->traced = $traced;\n        return $this;\n    }\n    \/**\n     * @inheritdoc\n     *\/\n    public function jsonSerialize() : array\n    {\n        $data = parent::jsonSerialize();\n        $data['namespace'] = 'remote';\n        $data['traced'] = $this->traced;\n        return array_filter($data);\n    }\n}","mutatedSourceCode":"<?php\n\nnamespace Fido\\PHPXray;\n\nclass RemoteSegment extends Segment\n{\n    protected bool $traced = false;\n    public function setTraced(bool $traced) : self\n    {\n        $this->traced = $traced;\n        return $this;\n    }\n    \/**\n     * @inheritdoc\n     *\/\n    public function jsonSerialize() : array\n    {\n        $data = parent::jsonSerialize();\n        $data['namespace'] = 'remote';\n        $data['traced'] = $this->traced;\n        return $data;\n    }\n}","originalFilePath":"\/home\/ranpafin\/php-xray\/src\/RemoteSegment.php","originalStartLine":26},"diff":"--- Original\n+++ New\n@@ @@\n         $data = parent::jsonSerialize();\n         $data['namespace'] = 'remote';\n         $data['traced'] = $this->traced;\n-        return array_filter($data);\n+        return $data;\n     }\n }","processOutput":"PHPUnit 9.5.10 by Sebastian Bergmann and contributors.\n\nRuntime:       PHP 8.0.13\nConfiguration: \/tmp\/tmp-folder\/infection\/phpunitConfiguration.89070650f2f8520c6329e4590c2e959e.infection.xml\n\nE\n\nTime: 00:00.003, Memory: 8.00 MB\n\nThere was 1 error:\n\n1) Fido\\PHPXray\\DaemonSegmentSubmitterTest::testSubmitsToDaemon\nsocket_bind(): Unable to bind address [98]: Address already in use\n\n\/home\/ranpafin\/php-xray\/tests\/DaemonSegmentSubmitterTest.php:18\n\nERRORS!\nTests: 1, Assertions: 0, Errors: 1."},{"mutator":{"mutatorName":"DecrementInteger","originalSourceCode":"<?php\n\nnamespace Fido\\PHPXray;\n\nuse JsonSerializable;\nuse Fido\\PHPXray\\Submission\\SegmentSubmitter;\nclass Segment implements JsonSerializable\n{\n    protected string $id;\n    protected ?string $parentId = null;\n    protected string $traceId;\n    protected ?string $name = null;\n    protected float $startTime;\n    protected float $endTime;\n    \/** @var Segment[] *\/\n    protected array $subsegments = [];\n    protected bool $error = false;\n    protected bool $fault = false;\n    protected bool $sampled = false;\n    protected bool $independent = false;\n    \/** @var array<string, mixed> *\/\n    private array $annotations;\n    \/** @var array<string, mixed> *\/\n    private array $metadata;\n    private int $lastOpenSegment = 0;\n    \/**\n     * @throws \\Exception if an appropriate source of randomness cannot be found.\n     *\/\n    public function __construct()\n    {\n        $this->id = bin2hex(random_bytes(8));\n    }\n    public function setTraceHeader(string $traceHeader = null) : self\n    {\n        if (is_null($traceHeader)) {\n            return $this;\n        }\n        $parts = explode(';', $traceHeader);\n        $variables = array_map(function ($str) : array {\n            return explode('=', $str);\n        }, $parts);\n        $variables = array_column($variables, 1, 0);\n        if (isset($variables['Root'])) {\n            $this->setTraceId($variables['Root']);\n        }\n        if (isset($variables['Sampled'])) {\n            $this->setSampled((bool) $variables['Sampled'] ?? false);\n        }\n        if (isset($variables['Parent'])) {\n            $this->setParentId($variables['Parent'] ?? null);\n        }\n        return $this;\n    }\n    public function begin() : self\n    {\n        $this->startTime = microtime(true);\n        return $this;\n    }\n    public function end() : self\n    {\n        $this->endTime = microtime(true);\n        return $this;\n    }\n    public function setName(string $name) : self\n    {\n        $this->name = $name;\n        return $this;\n    }\n    public function setError(bool $error) : self\n    {\n        $this->error = $error;\n        return $this;\n    }\n    public function setFault(bool $fault) : self\n    {\n        $this->fault = $fault;\n        return $this;\n    }\n    public function addSubsegment(Segment $subsegment) : self\n    {\n        if (!$this->isOpen()) {\n            return $this;\n        }\n        $this->subsegments[] = $subsegment;\n        $subsegment->setSampled($this->isSampled());\n        return $this;\n    }\n    public function submit(SegmentSubmitter $submitter) : void\n    {\n        if (!$this->isSampled()) {\n            return;\n        }\n        $submitter->submitSegment($this);\n    }\n    public function isSampled() : bool\n    {\n        return $this->sampled;\n    }\n    public function setSampled(bool $sampled) : self\n    {\n        $this->sampled = $sampled;\n        return $this;\n    }\n    public function getId() : string\n    {\n        return $this->id;\n    }\n    public function setParentId(?string $parentId) : self\n    {\n        $this->parentId = $parentId;\n        return $this;\n    }\n    public function setTraceId(string $traceId) : self\n    {\n        $this->traceId = $traceId;\n        return $this;\n    }\n    public function getTraceId() : string\n    {\n        return $this->traceId;\n    }\n    public function isOpen() : bool\n    {\n        return isset($this->startTime) && !isset($this->endTime);\n    }\n    public function setIndependent(bool $independent) : self\n    {\n        $this->independent = $independent;\n        return $this;\n    }\n    public function addAnnotation(string $key, string $value) : self\n    {\n        $this->annotations[$key] = $value;\n        return $this;\n    }\n    public function addMetadata(string $key, mixed $value) : self\n    {\n        $this->metadata[$key] = $value;\n        return $this;\n    }\n    public function getCurrentSegment() : self\n    {\n        for ($max = count($this->subsegments); $this->lastOpenSegment < $max; $this->lastOpenSegment++) {\n            if ($this->subsegments[$this->lastOpenSegment]->isOpen()) {\n                return $this->subsegments[$this->lastOpenSegment]->getCurrentSegment();\n            }\n        }\n        return $this;\n    }\n    \/**\n     * @inheritDoc\n     * @return array<string, mixed>\n     *\/\n    public function jsonSerialize() : array\n    {\n        return array_filter(['id' => $this->id, 'parent_id' => $this->parentId, 'trace_id' => $this->traceId ?? null, 'name' => $this->name, 'start_time' => $this->startTime ?? null, 'end_time' => $this->endTime ?? null, 'subsegments' => $this->subsegments ?? null ?: null, 'type' => $this->independent ? 'subsegment' : null, 'fault' => $this->fault ?? null, 'error' => $this->error ?? null, 'annotations' => $this->annotations ?? null ?: null, 'metadata' => $this->metadata ?? null ?: null]);\n    }\n}","mutatedSourceCode":"<?php\n\nnamespace Fido\\PHPXray;\n\nuse JsonSerializable;\nuse Fido\\PHPXray\\Submission\\SegmentSubmitter;\nclass Segment implements JsonSerializable\n{\n    protected string $id;\n    protected ?string $parentId = null;\n    protected string $traceId;\n    protected ?string $name = null;\n    protected float $startTime;\n    protected float $endTime;\n    \/** @var Segment[] *\/\n    protected array $subsegments = [];\n    protected bool $error = false;\n    protected bool $fault = false;\n    protected bool $sampled = false;\n    protected bool $independent = false;\n    \/** @var array<string, mixed> *\/\n    private array $annotations;\n    \/** @var array<string, mixed> *\/\n    private array $metadata;\n    private int $lastOpenSegment = 0;\n    \/**\n     * @throws \\Exception if an appropriate source of randomness cannot be found.\n     *\/\n    public function __construct()\n    {\n        $this->id = bin2hex(random_bytes(7));\n    }\n    public function setTraceHeader(string $traceHeader = null) : self\n    {\n        if (is_null($traceHeader)) {\n            return $this;\n        }\n        $parts = explode(';', $traceHeader);\n        $variables = array_map(function ($str) : array {\n            return explode('=', $str);\n        }, $parts);\n        $variables = array_column($variables, 1, 0);\n        if (isset($variables['Root'])) {\n            $this->setTraceId($variables['Root']);\n        }\n        if (isset($variables['Sampled'])) {\n            $this->setSampled((bool) $variables['Sampled'] ?? false);\n        }\n        if (isset($variables['Parent'])) {\n            $this->setParentId($variables['Parent'] ?? null);\n        }\n        return $this;\n    }\n    public function begin() : self\n    {\n        $this->startTime = microtime(true);\n        return $this;\n    }\n    public function end() : self\n    {\n        $this->endTime = microtime(true);\n        return $this;\n    }\n    public function setName(string $name) : self\n    {\n        $this->name = $name;\n        return $this;\n    }\n    public function setError(bool $error) : self\n    {\n        $this->error = $error;\n        return $this;\n    }\n    public function setFault(bool $fault) : self\n    {\n        $this->fault = $fault;\n        return $this;\n    }\n    public function addSubsegment(Segment $subsegment) : self\n    {\n        if (!$this->isOpen()) {\n            return $this;\n        }\n        $this->subsegments[] = $subsegment;\n        $subsegment->setSampled($this->isSampled());\n        return $this;\n    }\n    public function submit(SegmentSubmitter $submitter) : void\n    {\n        if (!$this->isSampled()) {\n            return;\n        }\n        $submitter->submitSegment($this);\n    }\n    public function isSampled() : bool\n    {\n        return $this->sampled;\n    }\n    public function setSampled(bool $sampled) : self\n    {\n        $this->sampled = $sampled;\n        return $this;\n    }\n    public function getId() : string\n    {\n        return $this->id;\n    }\n    public function setParentId(?string $parentId) : self\n    {\n        $this->parentId = $parentId;\n        return $this;\n    }\n    public function setTraceId(string $traceId) : self\n    {\n        $this->traceId = $traceId;\n        return $this;\n    }\n    public function getTraceId() : string\n    {\n        return $this->traceId;\n    }\n    public function isOpen() : bool\n    {\n        return isset($this->startTime) && !isset($this->endTime);\n    }\n    public function setIndependent(bool $independent) : self\n    {\n        $this->independent = $independent;\n        return $this;\n    }\n    public function addAnnotation(string $key, string $value) : self\n    {\n        $this->annotations[$key] = $value;\n        return $this;\n    }\n    public function addMetadata(string $key, mixed $value) : self\n    {\n        $this->metadata[$key] = $value;\n        return $this;\n    }\n    public function getCurrentSegment() : self\n    {\n        for ($max = count($this->subsegments); $this->lastOpenSegment < $max; $this->lastOpenSegment++) {\n            if ($this->subsegments[$this->lastOpenSegment]->isOpen()) {\n                return $this->subsegments[$this->lastOpenSegment]->getCurrentSegment();\n            }\n        }\n        return $this;\n    }\n    \/**\n     * @inheritDoc\n     * @return array<string, mixed>\n     *\/\n    public function jsonSerialize() : array\n    {\n        return array_filter(['id' => $this->id, 'parent_id' => $this->parentId, 'trace_id' => $this->traceId ?? null, 'name' => $this->name, 'start_time' => $this->startTime ?? null, 'end_time' => $this->endTime ?? null, 'subsegments' => $this->subsegments ?? null ?: null, 'type' => $this->independent ? 'subsegment' : null, 'fault' => $this->fault ?? null, 'error' => $this->error ?? null, 'annotations' => $this->annotations ?? null ?: null, 'metadata' => $this->metadata ?? null ?: null]);\n    }\n}","originalFilePath":"\/home\/ranpafin\/php-xray\/src\/Segment.php","originalStartLine":33},"diff":"--- Original\n+++ New\n@@ @@\n      *\/\n     public function __construct()\n     {\n-        $this->id = bin2hex(random_bytes(8));\n+        $this->id = bin2hex(random_bytes(7));\n     }\n     public function setTraceHeader(string $traceHeader = null) : self\n     {","processOutput":"PHPUnit 9.5.10 by Sebastian Bergmann and contributors.\n\nRuntime:       PHP 8.0.13\nConfiguration: \/tmp\/tmp-folder\/infection\/phpunitConfiguration.98d07266229f3fc4424ae220602c03af.infection.xml\n\nE\n\nTime: 00:00.003, Memory: 8.00 MB\n\nThere was 1 error:\n\n1) Fido\\PHPXray\\DaemonSegmentSubmitterTest::testSubmitsToDaemon\nsocket_bind(): Unable to bind address [98]: Address already in use\n\n\/home\/ranpafin\/php-xray\/tests\/DaemonSegmentSubmitterTest.php:18\n\nERRORS!\nTests: 1, Assertions: 0, Errors: 1."},{"mutator":{"mutatorName":"IncrementInteger","originalSourceCode":"<?php\n\nnamespace Fido\\PHPXray;\n\nuse JsonSerializable;\nuse Fido\\PHPXray\\Submission\\SegmentSubmitter;\nclass Segment implements JsonSerializable\n{\n    protected string $id;\n    protected ?string $parentId = null;\n    protected string $traceId;\n    protected ?string $name = null;\n    protected float $startTime;\n    protected float $endTime;\n    \/** @var Segment[] *\/\n    protected array $subsegments = [];\n    protected bool $error = false;\n    protected bool $fault = false;\n    protected bool $sampled = false;\n    protected bool $independent = false;\n    \/** @var array<string, mixed> *\/\n    private array $annotations;\n    \/** @var array<string, mixed> *\/\n    private array $metadata;\n    private int $lastOpenSegment = 0;\n    \/**\n     * @throws \\Exception if an appropriate source of randomness cannot be found.\n     *\/\n    public function __construct()\n    {\n        $this->id = bin2hex(random_bytes(8));\n    }\n    public function setTraceHeader(string $traceHeader = null) : self\n    {\n        if (is_null($traceHeader)) {\n            return $this;\n        }\n        $parts = explode(';', $traceHeader);\n        $variables = array_map(function ($str) : array {\n            return explode('=', $str);\n        }, $parts);\n        $variables = array_column($variables, 1, 0);\n        if (isset($variables['Root'])) {\n            $this->setTraceId($variables['Root']);\n        }\n        if (isset($variables['Sampled'])) {\n            $this->setSampled((bool) $variables['Sampled'] ?? false);\n        }\n        if (isset($variables['Parent'])) {\n            $this->setParentId($variables['Parent'] ?? null);\n        }\n        return $this;\n    }\n    public function begin() : self\n    {\n        $this->startTime = microtime(true);\n        return $this;\n    }\n    public function end() : self\n    {\n        $this->endTime = microtime(true);\n        return $this;\n    }\n    public function setName(string $name) : self\n    {\n        $this->name = $name;\n        return $this;\n    }\n    public function setError(bool $error) : self\n    {\n        $this->error = $error;\n        return $this;\n    }\n    public function setFault(bool $fault) : self\n    {\n        $this->fault = $fault;\n        return $this;\n    }\n    public function addSubsegment(Segment $subsegment) : self\n    {\n        if (!$this->isOpen()) {\n            return $this;\n        }\n        $this->subsegments[] = $subsegment;\n        $subsegment->setSampled($this->isSampled());\n        return $this;\n    }\n    public function submit(SegmentSubmitter $submitter) : void\n    {\n        if (!$this->isSampled()) {\n            return;\n        }\n        $submitter->submitSegment($this);\n    }\n    public function isSampled() : bool\n    {\n        return $this->sampled;\n    }\n    public function setSampled(bool $sampled) : self\n    {\n        $this->sampled = $sampled;\n        return $this;\n    }\n    public function getId() : string\n    {\n        return $this->id;\n    }\n    public function setParentId(?string $parentId) : self\n    {\n        $this->parentId = $parentId;\n        return $this;\n    }\n    public function setTraceId(string $traceId) : self\n    {\n        $this->traceId = $traceId;\n        return $this;\n    }\n    public function getTraceId() : string\n    {\n        return $this->traceId;\n    }\n    public function isOpen() : bool\n    {\n        return isset($this->startTime) && !isset($this->endTime);\n    }\n    public function setIndependent(bool $independent) : self\n    {\n        $this->independent = $independent;\n        return $this;\n    }\n    public function addAnnotation(string $key, string $value) : self\n    {\n        $this->annotations[$key] = $value;\n        return $this;\n    }\n    public function addMetadata(string $key, mixed $value) : self\n    {\n        $this->metadata[$key] = $value;\n        return $this;\n    }\n    public function getCurrentSegment() : self\n    {\n        for ($max = count($this->subsegments); $this->lastOpenSegment < $max; $this->lastOpenSegment++) {\n            if ($this->subsegments[$this->lastOpenSegment]->isOpen()) {\n                return $this->subsegments[$this->lastOpenSegment]->getCurrentSegment();\n            }\n        }\n        return $this;\n    }\n    \/**\n     * @inheritDoc\n     * @return array<string, mixed>\n     *\/\n    public function jsonSerialize() : array\n    {\n        return array_filter(['id' => $this->id, 'parent_id' => $this->parentId, 'trace_id' => $this->traceId ?? null, 'name' => $this->name, 'start_time' => $this->startTime ?? null, 'end_time' => $this->endTime ?? null, 'subsegments' => $this->subsegments ?? null ?: null, 'type' => $this->independent ? 'subsegment' : null, 'fault' => $this->fault ?? null, 'error' => $this->error ?? null, 'annotations' => $this->annotations ?? null ?: null, 'metadata' => $this->metadata ?? null ?: null]);\n    }\n}","mutatedSourceCode":"<?php\n\nnamespace Fido\\PHPXray;\n\nuse JsonSerializable;\nuse Fido\\PHPXray\\Submission\\SegmentSubmitter;\nclass Segment implements JsonSerializable\n{\n    protected string $id;\n    protected ?string $parentId = null;\n    protected string $traceId;\n    protected ?string $name = null;\n    protected float $startTime;\n    protected float $endTime;\n    \/** @var Segment[] *\/\n    protected array $subsegments = [];\n    protected bool $error = false;\n    protected bool $fault = false;\n    protected bool $sampled = false;\n    protected bool $independent = false;\n    \/** @var array<string, mixed> *\/\n    private array $annotations;\n    \/** @var array<string, mixed> *\/\n    private array $metadata;\n    private int $lastOpenSegment = 0;\n    \/**\n     * @throws \\Exception if an appropriate source of randomness cannot be found.\n     *\/\n    public function __construct()\n    {\n        $this->id = bin2hex(random_bytes(9));\n    }\n    public function setTraceHeader(string $traceHeader = null) : self\n    {\n        if (is_null($traceHeader)) {\n            return $this;\n        }\n        $parts = explode(';', $traceHeader);\n        $variables = array_map(function ($str) : array {\n            return explode('=', $str);\n        }, $parts);\n        $variables = array_column($variables, 1, 0);\n        if (isset($variables['Root'])) {\n            $this->setTraceId($variables['Root']);\n        }\n        if (isset($variables['Sampled'])) {\n            $this->setSampled((bool) $variables['Sampled'] ?? false);\n        }\n        if (isset($variables['Parent'])) {\n            $this->setParentId($variables['Parent'] ?? null);\n        }\n        return $this;\n    }\n    public function begin() : self\n    {\n        $this->startTime = microtime(true);\n        return $this;\n    }\n    public function end() : self\n    {\n        $this->endTime = microtime(true);\n        return $this;\n    }\n    public function setName(string $name) : self\n    {\n        $this->name = $name;\n        return $this;\n    }\n    public function setError(bool $error) : self\n    {\n        $this->error = $error;\n        return $this;\n    }\n    public function setFault(bool $fault) : self\n    {\n        $this->fault = $fault;\n        return $this;\n    }\n    public function addSubsegment(Segment $subsegment) : self\n    {\n        if (!$this->isOpen()) {\n            return $this;\n        }\n        $this->subsegments[] = $subsegment;\n        $subsegment->setSampled($this->isSampled());\n        return $this;\n    }\n    public function submit(SegmentSubmitter $submitter) : void\n    {\n        if (!$this->isSampled()) {\n            return;\n        }\n        $submitter->submitSegment($this);\n    }\n    public function isSampled() : bool\n    {\n        return $this->sampled;\n    }\n    public function setSampled(bool $sampled) : self\n    {\n        $this->sampled = $sampled;\n        return $this;\n    }\n    public function getId() : string\n    {\n        return $this->id;\n    }\n    public function setParentId(?string $parentId) : self\n    {\n        $this->parentId = $parentId;\n        return $this;\n    }\n    public function setTraceId(string $traceId) : self\n    {\n        $this->traceId = $traceId;\n        return $this;\n    }\n    public function getTraceId() : string\n    {\n        return $this->traceId;\n    }\n    public function isOpen() : bool\n    {\n        return isset($this->startTime) && !isset($this->endTime);\n    }\n    public function setIndependent(bool $independent) : self\n    {\n        $this->independent = $independent;\n        return $this;\n    }\n    public function addAnnotation(string $key, string $value) : self\n    {\n        $this->annotations[$key] = $value;\n        return $this;\n    }\n    public function addMetadata(string $key, mixed $value) : self\n    {\n        $this->metadata[$key] = $value;\n        return $this;\n    }\n    public function getCurrentSegment() : self\n    {\n        for ($max = count($this->subsegments); $this->lastOpenSegment < $max; $this->lastOpenSegment++) {\n            if ($this->subsegments[$this->lastOpenSegment]->isOpen()) {\n                return $this->subsegments[$this->lastOpenSegment]->getCurrentSegment();\n            }\n        }\n        return $this;\n    }\n    \/**\n     * @inheritDoc\n     * @return array<string, mixed>\n     *\/\n    public function jsonSerialize() : array\n    {\n        return array_filter(['id' => $this->id, 'parent_id' => $this->parentId, 'trace_id' => $this->traceId ?? null, 'name' => $this->name, 'start_time' => $this->startTime ?? null, 'end_time' => $this->endTime ?? null, 'subsegments' => $this->subsegments ?? null ?: null, 'type' => $this->independent ? 'subsegment' : null, 'fault' => $this->fault ?? null, 'error' => $this->error ?? null, 'annotations' => $this->annotations ?? null ?: null, 'metadata' => $this->metadata ?? null ?: null]);\n    }\n}","originalFilePath":"\/home\/ranpafin\/php-xray\/src\/Segment.php","originalStartLine":33},"diff":"--- Original\n+++ New\n@@ @@\n      *\/\n     public function __construct()\n     {\n-        $this->id = bin2hex(random_bytes(8));\n+        $this->id = bin2hex(random_bytes(9));\n     }\n     public function setTraceHeader(string $traceHeader = null) : self\n     {","processOutput":"PHPUnit 9.5.10 by Sebastian Bergmann and contributors.\n\nRuntime:       PHP 8.0.13\nConfiguration: \/tmp\/tmp-folder\/infection\/phpunitConfiguration.1e3b8bfd14bc187b92d213ed0c58e807.infection.xml\n\nE\n\nTime: 00:00.003, Memory: 8.00 MB\n\nThere was 1 error:\n\n1) Fido\\PHPXray\\DaemonSegmentSubmitterTest::testSubmitsToDaemon\nsocket_bind(): Unable to bind address [98]: Address already in use\n\n\/home\/ranpafin\/php-xray\/tests\/DaemonSegmentSubmitterTest.php:18\n\nERRORS!\nTests: 1, Assertions: 0, Errors: 1."},{"mutator":{"mutatorName":"PublicVisibility","originalSourceCode":"<?php\n\nnamespace Fido\\PHPXray;\n\nuse JsonSerializable;\nuse Fido\\PHPXray\\Submission\\SegmentSubmitter;\nclass Segment implements JsonSerializable\n{\n    protected string $id;\n    protected ?string $parentId = null;\n    protected string $traceId;\n    protected ?string $name = null;\n    protected float $startTime;\n    protected float $endTime;\n    \/** @var Segment[] *\/\n    protected array $subsegments = [];\n    protected bool $error = false;\n    protected bool $fault = false;\n    protected bool $sampled = false;\n    protected bool $independent = false;\n    \/** @var array<string, mixed> *\/\n    private array $annotations;\n    \/** @var array<string, mixed> *\/\n    private array $metadata;\n    private int $lastOpenSegment = 0;\n    \/**\n     * @throws \\Exception if an appropriate source of randomness cannot be found.\n     *\/\n    public function __construct()\n    {\n        $this->id = bin2hex(random_bytes(8));\n    }\n    public function setTraceHeader(string $traceHeader = null) : self\n    {\n        if (is_null($traceHeader)) {\n            return $this;\n        }\n        $parts = explode(';', $traceHeader);\n        $variables = array_map(function ($str) : array {\n            return explode('=', $str);\n        }, $parts);\n        $variables = array_column($variables, 1, 0);\n        if (isset($variables['Root'])) {\n            $this->setTraceId($variables['Root']);\n        }\n        if (isset($variables['Sampled'])) {\n            $this->setSampled((bool) $variables['Sampled'] ?? false);\n        }\n        if (isset($variables['Parent'])) {\n            $this->setParentId($variables['Parent'] ?? null);\n        }\n        return $this;\n    }\n    public function begin() : self\n    {\n        $this->startTime = microtime(true);\n        return $this;\n    }\n    public function end() : self\n    {\n        $this->endTime = microtime(true);\n        return $this;\n    }\n    public function setName(string $name) : self\n    {\n        $this->name = $name;\n        return $this;\n    }\n    public function setError(bool $error) : self\n    {\n        $this->error = $error;\n        return $this;\n    }\n    public function setFault(bool $fault) : self\n    {\n        $this->fault = $fault;\n        return $this;\n    }\n    public function addSubsegment(Segment $subsegment) : self\n    {\n        if (!$this->isOpen()) {\n            return $this;\n        }\n        $this->subsegments[] = $subsegment;\n        $subsegment->setSampled($this->isSampled());\n        return $this;\n    }\n    public function submit(SegmentSubmitter $submitter) : void\n    {\n        if (!$this->isSampled()) {\n            return;\n        }\n        $submitter->submitSegment($this);\n    }\n    public function isSampled() : bool\n    {\n        return $this->sampled;\n    }\n    public function setSampled(bool $sampled) : self\n    {\n        $this->sampled = $sampled;\n        return $this;\n    }\n    public function getId() : string\n    {\n        return $this->id;\n    }\n    public function setParentId(?string $parentId) : self\n    {\n        $this->parentId = $parentId;\n        return $this;\n    }\n    public function setTraceId(string $traceId) : self\n    {\n        $this->traceId = $traceId;\n        return $this;\n    }\n    public function getTraceId() : string\n    {\n        return $this->traceId;\n    }\n    public function isOpen() : bool\n    {\n        return isset($this->startTime) && !isset($this->endTime);\n    }\n    public function setIndependent(bool $independent) : self\n    {\n        $this->independent = $independent;\n        return $this;\n    }\n    public function addAnnotation(string $key, string $value) : self\n    {\n        $this->annotations[$key] = $value;\n        return $this;\n    }\n    public function addMetadata(string $key, mixed $value) : self\n    {\n        $this->metadata[$key] = $value;\n        return $this;\n    }\n    public function getCurrentSegment() : self\n    {\n        for ($max = count($this->subsegments); $this->lastOpenSegment < $max; $this->lastOpenSegment++) {\n            if ($this->subsegments[$this->lastOpenSegment]->isOpen()) {\n                return $this->subsegments[$this->lastOpenSegment]->getCurrentSegment();\n            }\n        }\n        return $this;\n    }\n    \/**\n     * @inheritDoc\n     * @return array<string, mixed>\n     *\/\n    public function jsonSerialize() : array\n    {\n        return array_filter(['id' => $this->id, 'parent_id' => $this->parentId, 'trace_id' => $this->traceId ?? null, 'name' => $this->name, 'start_time' => $this->startTime ?? null, 'end_time' => $this->endTime ?? null, 'subsegments' => $this->subsegments ?? null ?: null, 'type' => $this->independent ? 'subsegment' : null, 'fault' => $this->fault ?? null, 'error' => $this->error ?? null, 'annotations' => $this->annotations ?? null ?: null, 'metadata' => $this->metadata ?? null ?: null]);\n    }\n}","mutatedSourceCode":"<?php\n\nnamespace Fido\\PHPXray;\n\nuse JsonSerializable;\nuse Fido\\PHPXray\\Submission\\SegmentSubmitter;\nclass Segment implements JsonSerializable\n{\n    protected string $id;\n    protected ?string $parentId = null;\n    protected string $traceId;\n    protected ?string $name = null;\n    protected float $startTime;\n    protected float $endTime;\n    \/** @var Segment[] *\/\n    protected array $subsegments = [];\n    protected bool $error = false;\n    protected bool $fault = false;\n    protected bool $sampled = false;\n    protected bool $independent = false;\n    \/** @var array<string, mixed> *\/\n    private array $annotations;\n    \/** @var array<string, mixed> *\/\n    private array $metadata;\n    private int $lastOpenSegment = 0;\n    \/**\n     * @throws \\Exception if an appropriate source of randomness cannot be found.\n     *\/\n    public function __construct()\n    {\n        $this->id = bin2hex(random_bytes(8));\n    }\n    protected function setTraceHeader(string $traceHeader = null) : self\n    {\n        if (is_null($traceHeader)) {\n            return $this;\n        }\n        $parts = explode(';', $traceHeader);\n        $variables = array_map(function ($str) : array {\n            return explode('=', $str);\n        }, $parts);\n        $variables = array_column($variables, 1, 0);\n        if (isset($variables['Root'])) {\n            $this->setTraceId($variables['Root']);\n        }\n        if (isset($variables['Sampled'])) {\n            $this->setSampled((bool) $variables['Sampled'] ?? false);\n        }\n        if (isset($variables['Parent'])) {\n            $this->setParentId($variables['Parent'] ?? null);\n        }\n        return $this;\n    }\n    public function begin() : self\n    {\n        $this->startTime = microtime(true);\n        return $this;\n    }\n    public function end() : self\n    {\n        $this->endTime = microtime(true);\n        return $this;\n    }\n    public function setName(string $name) : self\n    {\n        $this->name = $name;\n        return $this;\n    }\n    public function setError(bool $error) : self\n    {\n        $this->error = $error;\n        return $this;\n    }\n    public function setFault(bool $fault) : self\n    {\n        $this->fault = $fault;\n        return $this;\n    }\n    public function addSubsegment(Segment $subsegment) : self\n    {\n        if (!$this->isOpen()) {\n            return $this;\n        }\n        $this->subsegments[] = $subsegment;\n        $subsegment->setSampled($this->isSampled());\n        return $this;\n    }\n    public function submit(SegmentSubmitter $submitter) : void\n    {\n        if (!$this->isSampled()) {\n            return;\n        }\n        $submitter->submitSegment($this);\n    }\n    public function isSampled() : bool\n    {\n        return $this->sampled;\n    }\n    public function setSampled(bool $sampled) : self\n    {\n        $this->sampled = $sampled;\n        return $this;\n    }\n    public function getId() : string\n    {\n        return $this->id;\n    }\n    public function setParentId(?string $parentId) : self\n    {\n        $this->parentId = $parentId;\n        return $this;\n    }\n    public function setTraceId(string $traceId) : self\n    {\n        $this->traceId = $traceId;\n        return $this;\n    }\n    public function getTraceId() : string\n    {\n        return $this->traceId;\n    }\n    public function isOpen() : bool\n    {\n        return isset($this->startTime) && !isset($this->endTime);\n    }\n    public function setIndependent(bool $independent) : self\n    {\n        $this->independent = $independent;\n        return $this;\n    }\n    public function addAnnotation(string $key, string $value) : self\n    {\n        $this->annotations[$key] = $value;\n        return $this;\n    }\n    public function addMetadata(string $key, mixed $value) : self\n    {\n        $this->metadata[$key] = $value;\n        return $this;\n    }\n    public function getCurrentSegment() : self\n    {\n        for ($max = count($this->subsegments); $this->lastOpenSegment < $max; $this->lastOpenSegment++) {\n            if ($this->subsegments[$this->lastOpenSegment]->isOpen()) {\n                return $this->subsegments[$this->lastOpenSegment]->getCurrentSegment();\n            }\n        }\n        return $this;\n    }\n    \/**\n     * @inheritDoc\n     * @return array<string, mixed>\n     *\/\n    public function jsonSerialize() : array\n    {\n        return array_filter(['id' => $this->id, 'parent_id' => $this->parentId, 'trace_id' => $this->traceId ?? null, 'name' => $this->name, 'start_time' => $this->startTime ?? null, 'end_time' => $this->endTime ?? null, 'subsegments' => $this->subsegments ?? null ?: null, 'type' => $this->independent ? 'subsegment' : null, 'fault' => $this->fault ?? null, 'error' => $this->error ?? null, 'annotations' => $this->annotations ?? null ?: null, 'metadata' => $this->metadata ?? null ?: null]);\n    }\n}","originalFilePath":"\/home\/ranpafin\/php-xray\/src\/Segment.php","originalStartLine":36},"diff":"--- Original\n+++ New\n@@ @@\n     {\n         $this->id = bin2hex(random_bytes(8));\n     }\n-    public function setTraceHeader(string $traceHeader = null) : self\n+    protected function setTraceHeader(string $traceHeader = null) : self\n     {\n         if (is_null($traceHeader)) {\n             return $this;","processOutput":"PHPUnit 9.5.10 by Sebastian Bergmann and contributors.\n\nRuntime:       PHP 8.0.13\nConfiguration: \/tmp\/tmp-folder\/infection\/phpunitConfiguration.5c2968055a5719921c8b063a89a7f75e.infection.xml\n\nE\n\nTime: 00:00.004, Memory: 8.00 MB\n\nThere was 1 error:\n\n1) Fido\\PHPXray\\TraceTest::testGivenIdHeaderSetsId\nError: Call to protected method Fido\\PHPXray\\Segment::setTraceHeader() from scope Fido\\PHPXray\\TraceTest\n\n\/home\/ranpafin\/php-xray\/tests\/TraceTest.php:71\n\nERRORS!\nTests: 1, Assertions: 0, Errors: 1."},{"mutator":{"mutatorName":"UnwrapArrayMap","originalSourceCode":"<?php\n\nnamespace Fido\\PHPXray;\n\nuse JsonSerializable;\nuse Fido\\PHPXray\\Submission\\SegmentSubmitter;\nclass Segment implements JsonSerializable\n{\n    protected string $id;\n    protected ?string $parentId = null;\n    protected string $traceId;\n    protected ?string $name = null;\n    protected float $startTime;\n    protected float $endTime;\n    \/** @var Segment[] *\/\n    protected array $subsegments = [];\n    protected bool $error = false;\n    protected bool $fault = false;\n    protected bool $sampled = false;\n    protected bool $independent = false;\n    \/** @var array<string, mixed> *\/\n    private array $annotations;\n    \/** @var array<string, mixed> *\/\n    private array $metadata;\n    private int $lastOpenSegment = 0;\n    \/**\n     * @throws \\Exception if an appropriate source of randomness cannot be found.\n     *\/\n    public function __construct()\n    {\n        $this->id = bin2hex(random_bytes(8));\n    }\n    public function setTraceHeader(string $traceHeader = null) : self\n    {\n        if (is_null($traceHeader)) {\n            return $this;\n        }\n        $parts = explode(';', $traceHeader);\n        $variables = array_map(function ($str) : array {\n            return explode('=', $str);\n        }, $parts);\n        $variables = array_column($variables, 1, 0);\n        if (isset($variables['Root'])) {\n            $this->setTraceId($variables['Root']);\n        }\n        if (isset($variables['Sampled'])) {\n            $this->setSampled((bool) $variables['Sampled'] ?? false);\n        }\n        if (isset($variables['Parent'])) {\n            $this->setParentId($variables['Parent'] ?? null);\n        }\n        return $this;\n    }\n    public function begin() : self\n    {\n        $this->startTime = microtime(true);\n        return $this;\n    }\n    public function end() : self\n    {\n        $this->endTime = microtime(true);\n        return $this;\n    }\n    public function setName(string $name) : self\n    {\n        $this->name = $name;\n        return $this;\n    }\n    public function setError(bool $error) : self\n    {\n        $this->error = $error;\n        return $this;\n    }\n    public function setFault(bool $fault) : self\n    {\n        $this->fault = $fault;\n        return $this;\n    }\n    public function addSubsegment(Segment $subsegment) : self\n    {\n        if (!$this->isOpen()) {\n            return $this;\n        }\n        $this->subsegments[] = $subsegment;\n        $subsegment->setSampled($this->isSampled());\n        return $this;\n    }\n    public function submit(SegmentSubmitter $submitter) : void\n    {\n        if (!$this->isSampled()) {\n            return;\n        }\n        $submitter->submitSegment($this);\n    }\n    public function isSampled() : bool\n    {\n        return $this->sampled;\n    }\n    public function setSampled(bool $sampled) : self\n    {\n        $this->sampled = $sampled;\n        return $this;\n    }\n    public function getId() : string\n    {\n        return $this->id;\n    }\n    public function setParentId(?string $parentId) : self\n    {\n        $this->parentId = $parentId;\n        return $this;\n    }\n    public function setTraceId(string $traceId) : self\n    {\n        $this->traceId = $traceId;\n        return $this;\n    }\n    public function getTraceId() : string\n    {\n        return $this->traceId;\n    }\n    public function isOpen() : bool\n    {\n        return isset($this->startTime) && !isset($this->endTime);\n    }\n    public function setIndependent(bool $independent) : self\n    {\n        $this->independent = $independent;\n        return $this;\n    }\n    public function addAnnotation(string $key, string $value) : self\n    {\n        $this->annotations[$key] = $value;\n        return $this;\n    }\n    public function addMetadata(string $key, mixed $value) : self\n    {\n        $this->metadata[$key] = $value;\n        return $this;\n    }\n    public function getCurrentSegment() : self\n    {\n        for ($max = count($this->subsegments); $this->lastOpenSegment < $max; $this->lastOpenSegment++) {\n            if ($this->subsegments[$this->lastOpenSegment]->isOpen()) {\n                return $this->subsegments[$this->lastOpenSegment]->getCurrentSegment();\n            }\n        }\n        return $this;\n    }\n    \/**\n     * @inheritDoc\n     * @return array<string, mixed>\n     *\/\n    public function jsonSerialize() : array\n    {\n        return array_filter(['id' => $this->id, 'parent_id' => $this->parentId, 'trace_id' => $this->traceId ?? null, 'name' => $this->name, 'start_time' => $this->startTime ?? null, 'end_time' => $this->endTime ?? null, 'subsegments' => $this->subsegments ?? null ?: null, 'type' => $this->independent ? 'subsegment' : null, 'fault' => $this->fault ?? null, 'error' => $this->error ?? null, 'annotations' => $this->annotations ?? null ?: null, 'metadata' => $this->metadata ?? null ?: null]);\n    }\n}","mutatedSourceCode":"<?php\n\nnamespace Fido\\PHPXray;\n\nuse JsonSerializable;\nuse Fido\\PHPXray\\Submission\\SegmentSubmitter;\nclass Segment implements JsonSerializable\n{\n    protected string $id;\n    protected ?string $parentId = null;\n    protected string $traceId;\n    protected ?string $name = null;\n    protected float $startTime;\n    protected float $endTime;\n    \/** @var Segment[] *\/\n    protected array $subsegments = [];\n    protected bool $error = false;\n    protected bool $fault = false;\n    protected bool $sampled = false;\n    protected bool $independent = false;\n    \/** @var array<string, mixed> *\/\n    private array $annotations;\n    \/** @var array<string, mixed> *\/\n    private array $metadata;\n    private int $lastOpenSegment = 0;\n    \/**\n     * @throws \\Exception if an appropriate source of randomness cannot be found.\n     *\/\n    public function __construct()\n    {\n        $this->id = bin2hex(random_bytes(8));\n    }\n    public function setTraceHeader(string $traceHeader = null) : self\n    {\n        if (is_null($traceHeader)) {\n            return $this;\n        }\n        $parts = explode(';', $traceHeader);\n        $variables = $parts;\n        $variables = array_column($variables, 1, 0);\n        if (isset($variables['Root'])) {\n            $this->setTraceId($variables['Root']);\n        }\n        if (isset($variables['Sampled'])) {\n            $this->setSampled((bool) $variables['Sampled'] ?? false);\n        }\n        if (isset($variables['Parent'])) {\n            $this->setParentId($variables['Parent'] ?? null);\n        }\n        return $this;\n    }\n    public function begin() : self\n    {\n        $this->startTime = microtime(true);\n        return $this;\n    }\n    public function end() : self\n    {\n        $this->endTime = microtime(true);\n        return $this;\n    }\n    public function setName(string $name) : self\n    {\n        $this->name = $name;\n        return $this;\n    }\n    public function setError(bool $error) : self\n    {\n        $this->error = $error;\n        return $this;\n    }\n    public function setFault(bool $fault) : self\n    {\n        $this->fault = $fault;\n        return $this;\n    }\n    public function addSubsegment(Segment $subsegment) : self\n    {\n        if (!$this->isOpen()) {\n            return $this;\n        }\n        $this->subsegments[] = $subsegment;\n        $subsegment->setSampled($this->isSampled());\n        return $this;\n    }\n    public function submit(SegmentSubmitter $submitter) : void\n    {\n        if (!$this->isSampled()) {\n            return;\n        }\n        $submitter->submitSegment($this);\n    }\n    public function isSampled() : bool\n    {\n        return $this->sampled;\n    }\n    public function setSampled(bool $sampled) : self\n    {\n        $this->sampled = $sampled;\n        return $this;\n    }\n    public function getId() : string\n    {\n        return $this->id;\n    }\n    public function setParentId(?string $parentId) : self\n    {\n        $this->parentId = $parentId;\n        return $this;\n    }\n    public function setTraceId(string $traceId) : self\n    {\n        $this->traceId = $traceId;\n        return $this;\n    }\n    public function getTraceId() : string\n    {\n        return $this->traceId;\n    }\n    public function isOpen() : bool\n    {\n        return isset($this->startTime) && !isset($this->endTime);\n    }\n    public function setIndependent(bool $independent) : self\n    {\n        $this->independent = $independent;\n        return $this;\n    }\n    public function addAnnotation(string $key, string $value) : self\n    {\n        $this->annotations[$key] = $value;\n        return $this;\n    }\n    public function addMetadata(string $key, mixed $value) : self\n    {\n        $this->metadata[$key] = $value;\n        return $this;\n    }\n    public function getCurrentSegment() : self\n    {\n        for ($max = count($this->subsegments); $this->lastOpenSegment < $max; $this->lastOpenSegment++) {\n            if ($this->subsegments[$this->lastOpenSegment]->isOpen()) {\n                return $this->subsegments[$this->lastOpenSegment]->getCurrentSegment();\n            }\n        }\n        return $this;\n    }\n    \/**\n     * @inheritDoc\n     * @return array<string, mixed>\n     *\/\n    public function jsonSerialize() : array\n    {\n        return array_filter(['id' => $this->id, 'parent_id' => $this->parentId, 'trace_id' => $this->traceId ?? null, 'name' => $this->name, 'start_time' => $this->startTime ?? null, 'end_time' => $this->endTime ?? null, 'subsegments' => $this->subsegments ?? null ?: null, 'type' => $this->independent ? 'subsegment' : null, 'fault' => $this->fault ?? null, 'error' => $this->error ?? null, 'annotations' => $this->annotations ?? null ?: null, 'metadata' => $this->metadata ?? null ?: null]);\n    }\n}","originalFilePath":"\/home\/ranpafin\/php-xray\/src\/Segment.php","originalStartLine":44},"diff":"--- Original\n+++ New\n@@ @@\n             return $this;\n         }\n         $parts = explode(';', $traceHeader);\n-        $variables = array_map(function ($str) : array {\n-            return explode('=', $str);\n-        }, $parts);\n+        $variables = $parts;\n         $variables = array_column($variables, 1, 0);\n         if (isset($variables['Root'])) {\n             $this->setTraceId($variables['Root']);","processOutput":"PHPUnit 9.5.10 by Sebastian Bergmann and contributors.\n\nRuntime:       PHP 8.0.13\nConfiguration: \/tmp\/tmp-folder\/infection\/phpunitConfiguration.5dbe94a25a8005b860bccfde9a46a308.infection.xml\n\nE\n\nTime: 00:00.004, Memory: 8.00 MB\n\nThere was 1 error:\n\n1) Fido\\PHPXray\\TraceTest::testGivenIdHeaderSetsId\nError: Typed property Fido\\PHPXray\\Segment::$traceId must not be accessed before initialization\n\n\/home\/ranpafin\/php-xray\/src\/Segment.php:118\n\/home\/ranpafin\/php-xray\/tests\/TraceTest.php:73\n\nERRORS!\nTests: 1, Assertions: 0, Errors: 1."},{"mutator":{"mutatorName":"DecrementInteger","originalSourceCode":"<?php\n\nnamespace Fido\\PHPXray;\n\nuse JsonSerializable;\nuse Fido\\PHPXray\\Submission\\SegmentSubmitter;\nclass Segment implements JsonSerializable\n{\n    protected string $id;\n    protected ?string $parentId = null;\n    protected string $traceId;\n    protected ?string $name = null;\n    protected float $startTime;\n    protected float $endTime;\n    \/** @var Segment[] *\/\n    protected array $subsegments = [];\n    protected bool $error = false;\n    protected bool $fault = false;\n    protected bool $sampled = false;\n    protected bool $independent = false;\n    \/** @var array<string, mixed> *\/\n    private array $annotations;\n    \/** @var array<string, mixed> *\/\n    private array $metadata;\n    private int $lastOpenSegment = 0;\n    \/**\n     * @throws \\Exception if an appropriate source of randomness cannot be found.\n     *\/\n    public function __construct()\n    {\n        $this->id = bin2hex(random_bytes(8));\n    }\n    public function setTraceHeader(string $traceHeader = null) : self\n    {\n        if (is_null($traceHeader)) {\n            return $this;\n        }\n        $parts = explode(';', $traceHeader);\n        $variables = array_map(function ($str) : array {\n            return explode('=', $str);\n        }, $parts);\n        $variables = array_column($variables, 1, 0);\n        if (isset($variables['Root'])) {\n            $this->setTraceId($variables['Root']);\n        }\n        if (isset($variables['Sampled'])) {\n            $this->setSampled((bool) $variables['Sampled'] ?? false);\n        }\n        if (isset($variables['Parent'])) {\n            $this->setParentId($variables['Parent'] ?? null);\n        }\n        return $this;\n    }\n    public function begin() : self\n    {\n        $this->startTime = microtime(true);\n        return $this;\n    }\n    public function end() : self\n    {\n        $this->endTime = microtime(true);\n        return $this;\n    }\n    public function setName(string $name) : self\n    {\n        $this->name = $name;\n        return $this;\n    }\n    public function setError(bool $error) : self\n    {\n        $this->error = $error;\n        return $this;\n    }\n    public function setFault(bool $fault) : self\n    {\n        $this->fault = $fault;\n        return $this;\n    }\n    public function addSubsegment(Segment $subsegment) : self\n    {\n        if (!$this->isOpen()) {\n            return $this;\n        }\n        $this->subsegments[] = $subsegment;\n        $subsegment->setSampled($this->isSampled());\n        return $this;\n    }\n    public function submit(SegmentSubmitter $submitter) : void\n    {\n        if (!$this->isSampled()) {\n            return;\n        }\n        $submitter->submitSegment($this);\n    }\n    public function isSampled() : bool\n    {\n        return $this->sampled;\n    }\n    public function setSampled(bool $sampled) : self\n    {\n        $this->sampled = $sampled;\n        return $this;\n    }\n    public function getId() : string\n    {\n        return $this->id;\n    }\n    public function setParentId(?string $parentId) : self\n    {\n        $this->parentId = $parentId;\n        return $this;\n    }\n    public function setTraceId(string $traceId) : self\n    {\n        $this->traceId = $traceId;\n        return $this;\n    }\n    public function getTraceId() : string\n    {\n        return $this->traceId;\n    }\n    public function isOpen() : bool\n    {\n        return isset($this->startTime) && !isset($this->endTime);\n    }\n    public function setIndependent(bool $independent) : self\n    {\n        $this->independent = $independent;\n        return $this;\n    }\n    public function addAnnotation(string $key, string $value) : self\n    {\n        $this->annotations[$key] = $value;\n        return $this;\n    }\n    public function addMetadata(string $key, mixed $value) : self\n    {\n        $this->metadata[$key] = $value;\n        return $this;\n    }\n    public function getCurrentSegment() : self\n    {\n        for ($max = count($this->subsegments); $this->lastOpenSegment < $max; $this->lastOpenSegment++) {\n            if ($this->subsegments[$this->lastOpenSegment]->isOpen()) {\n                return $this->subsegments[$this->lastOpenSegment]->getCurrentSegment();\n            }\n        }\n        return $this;\n    }\n    \/**\n     * @inheritDoc\n     * @return array<string, mixed>\n     *\/\n    public function jsonSerialize() : array\n    {\n        return array_filter(['id' => $this->id, 'parent_id' => $this->parentId, 'trace_id' => $this->traceId ?? null, 'name' => $this->name, 'start_time' => $this->startTime ?? null, 'end_time' => $this->endTime ?? null, 'subsegments' => $this->subsegments ?? null ?: null, 'type' => $this->independent ? 'subsegment' : null, 'fault' => $this->fault ?? null, 'error' => $this->error ?? null, 'annotations' => $this->annotations ?? null ?: null, 'metadata' => $this->metadata ?? null ?: null]);\n    }\n}","mutatedSourceCode":"<?php\n\nnamespace Fido\\PHPXray;\n\nuse JsonSerializable;\nuse Fido\\PHPXray\\Submission\\SegmentSubmitter;\nclass Segment implements JsonSerializable\n{\n    protected string $id;\n    protected ?string $parentId = null;\n    protected string $traceId;\n    protected ?string $name = null;\n    protected float $startTime;\n    protected float $endTime;\n    \/** @var Segment[] *\/\n    protected array $subsegments = [];\n    protected bool $error = false;\n    protected bool $fault = false;\n    protected bool $sampled = false;\n    protected bool $independent = false;\n    \/** @var array<string, mixed> *\/\n    private array $annotations;\n    \/** @var array<string, mixed> *\/\n    private array $metadata;\n    private int $lastOpenSegment = 0;\n    \/**\n     * @throws \\Exception if an appropriate source of randomness cannot be found.\n     *\/\n    public function __construct()\n    {\n        $this->id = bin2hex(random_bytes(8));\n    }\n    public function setTraceHeader(string $traceHeader = null) : self\n    {\n        if (is_null($traceHeader)) {\n            return $this;\n        }\n        $parts = explode(';', $traceHeader);\n        $variables = array_map(function ($str) : array {\n            return explode('=', $str);\n        }, $parts);\n        $variables = array_column($variables, 0, 0);\n        if (isset($variables['Root'])) {\n            $this->setTraceId($variables['Root']);\n        }\n        if (isset($variables['Sampled'])) {\n            $this->setSampled((bool) $variables['Sampled'] ?? false);\n        }\n        if (isset($variables['Parent'])) {\n            $this->setParentId($variables['Parent'] ?? null);\n        }\n        return $this;\n    }\n    public function begin() : self\n    {\n        $this->startTime = microtime(true);\n        return $this;\n    }\n    public function end() : self\n    {\n        $this->endTime = microtime(true);\n        return $this;\n    }\n    public function setName(string $name) : self\n    {\n        $this->name = $name;\n        return $this;\n    }\n    public function setError(bool $error) : self\n    {\n        $this->error = $error;\n        return $this;\n    }\n    public function setFault(bool $fault) : self\n    {\n        $this->fault = $fault;\n        return $this;\n    }\n    public function addSubsegment(Segment $subsegment) : self\n    {\n        if (!$this->isOpen()) {\n            return $this;\n        }\n        $this->subsegments[] = $subsegment;\n        $subsegment->setSampled($this->isSampled());\n        return $this;\n    }\n    public function submit(SegmentSubmitter $submitter) : void\n    {\n        if (!$this->isSampled()) {\n            return;\n        }\n        $submitter->submitSegment($this);\n    }\n    public function isSampled() : bool\n    {\n        return $this->sampled;\n    }\n    public function setSampled(bool $sampled) : self\n    {\n        $this->sampled = $sampled;\n        return $this;\n    }\n    public function getId() : string\n    {\n        return $this->id;\n    }\n    public function setParentId(?string $parentId) : self\n    {\n        $this->parentId = $parentId;\n        return $this;\n    }\n    public function setTraceId(string $traceId) : self\n    {\n        $this->traceId = $traceId;\n        return $this;\n    }\n    public function getTraceId() : string\n    {\n        return $this->traceId;\n    }\n    public function isOpen() : bool\n    {\n        return isset($this->startTime) && !isset($this->endTime);\n    }\n    public function setIndependent(bool $independent) : self\n    {\n        $this->independent = $independent;\n        return $this;\n    }\n    public function addAnnotation(string $key, string $value) : self\n    {\n        $this->annotations[$key] = $value;\n        return $this;\n    }\n    public function addMetadata(string $key, mixed $value) : self\n    {\n        $this->metadata[$key] = $value;\n        return $this;\n    }\n    public function getCurrentSegment() : self\n    {\n        for ($max = count($this->subsegments); $this->lastOpenSegment < $max; $this->lastOpenSegment++) {\n            if ($this->subsegments[$this->lastOpenSegment]->isOpen()) {\n                return $this->subsegments[$this->lastOpenSegment]->getCurrentSegment();\n            }\n        }\n        return $this;\n    }\n    \/**\n     * @inheritDoc\n     * @return array<string, mixed>\n     *\/\n    public function jsonSerialize() : array\n    {\n        return array_filter(['id' => $this->id, 'parent_id' => $this->parentId, 'trace_id' => $this->traceId ?? null, 'name' => $this->name, 'start_time' => $this->startTime ?? null, 'end_time' => $this->endTime ?? null, 'subsegments' => $this->subsegments ?? null ?: null, 'type' => $this->independent ? 'subsegment' : null, 'fault' => $this->fault ?? null, 'error' => $this->error ?? null, 'annotations' => $this->annotations ?? null ?: null, 'metadata' => $this->metadata ?? null ?: null]);\n    }\n}","originalFilePath":"\/home\/ranpafin\/php-xray\/src\/Segment.php","originalStartLine":48},"diff":"--- Original\n+++ New\n@@ @@\n         $variables = array_map(function ($str) : array {\n             return explode('=', $str);\n         }, $parts);\n-        $variables = array_column($variables, 1, 0);\n+        $variables = array_column($variables, 0, 0);\n         if (isset($variables['Root'])) {\n             $this->setTraceId($variables['Root']);\n         }","processOutput":"PHPUnit 9.5.10 by Sebastian Bergmann and contributors.\n\nRuntime:       PHP 8.0.13\nConfiguration: \/tmp\/tmp-folder\/infection\/phpunitConfiguration.aded93a6678bccf8b30026c1f4a11aa7.infection.xml\n\nF\n\nTime: 00:00.004, Memory: 8.00 MB\n\nThere was 1 failure:\n\n1) Fido\\PHPXray\\TraceTest::testGivenIdHeaderSetsId\nFailed asserting that two strings are equal.\n--- Expected\n+++ Actual\n@@ @@\n-'1-ab3169f3-1b7f38ac63d9037ef1843ca4'\n+'Root'\n\n\/home\/ranpafin\/php-xray\/tests\/TraceTest.php:73\n\nFAILURES!\nTests: 1, Assertions: 1, Failures: 1."},{"mutator":{"mutatorName":"IncrementInteger","originalSourceCode":"<?php\n\nnamespace Fido\\PHPXray;\n\nuse JsonSerializable;\nuse Fido\\PHPXray\\Submission\\SegmentSubmitter;\nclass Segment implements JsonSerializable\n{\n    protected string $id;\n    protected ?string $parentId = null;\n    protected string $traceId;\n    protected ?string $name = null;\n    protected float $startTime;\n    protected float $endTime;\n    \/** @var Segment[] *\/\n    protected array $subsegments = [];\n    protected bool $error = false;\n    protected bool $fault = false;\n    protected bool $sampled = false;\n    protected bool $independent = false;\n    \/** @var array<string, mixed> *\/\n    private array $annotations;\n    \/** @var array<string, mixed> *\/\n    private array $metadata;\n    private int $lastOpenSegment = 0;\n    \/**\n     * @throws \\Exception if an appropriate source of randomness cannot be found.\n     *\/\n    public function __construct()\n    {\n        $this->id = bin2hex(random_bytes(8));\n    }\n    public function setTraceHeader(string $traceHeader = null) : self\n    {\n        if (is_null($traceHeader)) {\n            return $this;\n        }\n        $parts = explode(';', $traceHeader);\n        $variables = array_map(function ($str) : array {\n            return explode('=', $str);\n        }, $parts);\n        $variables = array_column($variables, 1, 0);\n        if (isset($variables['Root'])) {\n            $this->setTraceId($variables['Root']);\n        }\n        if (isset($variables['Sampled'])) {\n            $this->setSampled((bool) $variables['Sampled'] ?? false);\n        }\n        if (isset($variables['Parent'])) {\n            $this->setParentId($variables['Parent'] ?? null);\n        }\n        return $this;\n    }\n    public function begin() : self\n    {\n        $this->startTime = microtime(true);\n        return $this;\n    }\n    public function end() : self\n    {\n        $this->endTime = microtime(true);\n        return $this;\n    }\n    public function setName(string $name) : self\n    {\n        $this->name = $name;\n        return $this;\n    }\n    public function setError(bool $error) : self\n    {\n        $this->error = $error;\n        return $this;\n    }\n    public function setFault(bool $fault) : self\n    {\n        $this->fault = $fault;\n        return $this;\n    }\n    public function addSubsegment(Segment $subsegment) : self\n    {\n        if (!$this->isOpen()) {\n            return $this;\n        }\n        $this->subsegments[] = $subsegment;\n        $subsegment->setSampled($this->isSampled());\n        return $this;\n    }\n    public function submit(SegmentSubmitter $submitter) : void\n    {\n        if (!$this->isSampled()) {\n            return;\n        }\n        $submitter->submitSegment($this);\n    }\n    public function isSampled() : bool\n    {\n        return $this->sampled;\n    }\n    public function setSampled(bool $sampled) : self\n    {\n        $this->sampled = $sampled;\n        return $this;\n    }\n    public function getId() : string\n    {\n        return $this->id;\n    }\n    public function setParentId(?string $parentId) : self\n    {\n        $this->parentId = $parentId;\n        return $this;\n    }\n    public function setTraceId(string $traceId) : self\n    {\n        $this->traceId = $traceId;\n        return $this;\n    }\n    public function getTraceId() : string\n    {\n        return $this->traceId;\n    }\n    public function isOpen() : bool\n    {\n        return isset($this->startTime) && !isset($this->endTime);\n    }\n    public function setIndependent(bool $independent) : self\n    {\n        $this->independent = $independent;\n        return $this;\n    }\n    public function addAnnotation(string $key, string $value) : self\n    {\n        $this->annotations[$key] = $value;\n        return $this;\n    }\n    public function addMetadata(string $key, mixed $value) : self\n    {\n        $this->metadata[$key] = $value;\n        return $this;\n    }\n    public function getCurrentSegment() : self\n    {\n        for ($max = count($this->subsegments); $this->lastOpenSegment < $max; $this->lastOpenSegment++) {\n            if ($this->subsegments[$this->lastOpenSegment]->isOpen()) {\n                return $this->subsegments[$this->lastOpenSegment]->getCurrentSegment();\n            }\n        }\n        return $this;\n    }\n    \/**\n     * @inheritDoc\n     * @return array<string, mixed>\n     *\/\n    public function jsonSerialize() : array\n    {\n        return array_filter(['id' => $this->id, 'parent_id' => $this->parentId, 'trace_id' => $this->traceId ?? null, 'name' => $this->name, 'start_time' => $this->startTime ?? null, 'end_time' => $this->endTime ?? null, 'subsegments' => $this->subsegments ?? null ?: null, 'type' => $this->independent ? 'subsegment' : null, 'fault' => $this->fault ?? null, 'error' => $this->error ?? null, 'annotations' => $this->annotations ?? null ?: null, 'metadata' => $this->metadata ?? null ?: null]);\n    }\n}","mutatedSourceCode":"<?php\n\nnamespace Fido\\PHPXray;\n\nuse JsonSerializable;\nuse Fido\\PHPXray\\Submission\\SegmentSubmitter;\nclass Segment implements JsonSerializable\n{\n    protected string $id;\n    protected ?string $parentId = null;\n    protected string $traceId;\n    protected ?string $name = null;\n    protected float $startTime;\n    protected float $endTime;\n    \/** @var Segment[] *\/\n    protected array $subsegments = [];\n    protected bool $error = false;\n    protected bool $fault = false;\n    protected bool $sampled = false;\n    protected bool $independent = false;\n    \/** @var array<string, mixed> *\/\n    private array $annotations;\n    \/** @var array<string, mixed> *\/\n    private array $metadata;\n    private int $lastOpenSegment = 0;\n    \/**\n     * @throws \\Exception if an appropriate source of randomness cannot be found.\n     *\/\n    public function __construct()\n    {\n        $this->id = bin2hex(random_bytes(8));\n    }\n    public function setTraceHeader(string $traceHeader = null) : self\n    {\n        if (is_null($traceHeader)) {\n            return $this;\n        }\n        $parts = explode(';', $traceHeader);\n        $variables = array_map(function ($str) : array {\n            return explode('=', $str);\n        }, $parts);\n        $variables = array_column($variables, 2, 0);\n        if (isset($variables['Root'])) {\n            $this->setTraceId($variables['Root']);\n        }\n        if (isset($variables['Sampled'])) {\n            $this->setSampled((bool) $variables['Sampled'] ?? false);\n        }\n        if (isset($variables['Parent'])) {\n            $this->setParentId($variables['Parent'] ?? null);\n        }\n        return $this;\n    }\n    public function begin() : self\n    {\n        $this->startTime = microtime(true);\n        return $this;\n    }\n    public function end() : self\n    {\n        $this->endTime = microtime(true);\n        return $this;\n    }\n    public function setName(string $name) : self\n    {\n        $this->name = $name;\n        return $this;\n    }\n    public function setError(bool $error) : self\n    {\n        $this->error = $error;\n        return $this;\n    }\n    public function setFault(bool $fault) : self\n    {\n        $this->fault = $fault;\n        return $this;\n    }\n    public function addSubsegment(Segment $subsegment) : self\n    {\n        if (!$this->isOpen()) {\n            return $this;\n        }\n        $this->subsegments[] = $subsegment;\n        $subsegment->setSampled($this->isSampled());\n        return $this;\n    }\n    public function submit(SegmentSubmitter $submitter) : void\n    {\n        if (!$this->isSampled()) {\n            return;\n        }\n        $submitter->submitSegment($this);\n    }\n    public function isSampled() : bool\n    {\n        return $this->sampled;\n    }\n    public function setSampled(bool $sampled) : self\n    {\n        $this->sampled = $sampled;\n        return $this;\n    }\n    public function getId() : string\n    {\n        return $this->id;\n    }\n    public function setParentId(?string $parentId) : self\n    {\n        $this->parentId = $parentId;\n        return $this;\n    }\n    public function setTraceId(string $traceId) : self\n    {\n        $this->traceId = $traceId;\n        return $this;\n    }\n    public function getTraceId() : string\n    {\n        return $this->traceId;\n    }\n    public function isOpen() : bool\n    {\n        return isset($this->startTime) && !isset($this->endTime);\n    }\n    public function setIndependent(bool $independent) : self\n    {\n        $this->independent = $independent;\n        return $this;\n    }\n    public function addAnnotation(string $key, string $value) : self\n    {\n        $this->annotations[$key] = $value;\n        return $this;\n    }\n    public function addMetadata(string $key, mixed $value) : self\n    {\n        $this->metadata[$key] = $value;\n        return $this;\n    }\n    public function getCurrentSegment() : self\n    {\n        for ($max = count($this->subsegments); $this->lastOpenSegment < $max; $this->lastOpenSegment++) {\n            if ($this->subsegments[$this->lastOpenSegment]->isOpen()) {\n                return $this->subsegments[$this->lastOpenSegment]->getCurrentSegment();\n            }\n        }\n        return $this;\n    }\n    \/**\n     * @inheritDoc\n     * @return array<string, mixed>\n     *\/\n    public function jsonSerialize() : array\n    {\n        return array_filter(['id' => $this->id, 'parent_id' => $this->parentId, 'trace_id' => $this->traceId ?? null, 'name' => $this->name, 'start_time' => $this->startTime ?? null, 'end_time' => $this->endTime ?? null, 'subsegments' => $this->subsegments ?? null ?: null, 'type' => $this->independent ? 'subsegment' : null, 'fault' => $this->fault ?? null, 'error' => $this->error ?? null, 'annotations' => $this->annotations ?? null ?: null, 'metadata' => $this->metadata ?? null ?: null]);\n    }\n}","originalFilePath":"\/home\/ranpafin\/php-xray\/src\/Segment.php","originalStartLine":48},"diff":"--- Original\n+++ New\n@@ @@\n         $variables = array_map(function ($str) : array {\n             return explode('=', $str);\n         }, $parts);\n-        $variables = array_column($variables, 1, 0);\n+        $variables = array_column($variables, 2, 0);\n         if (isset($variables['Root'])) {\n             $this->setTraceId($variables['Root']);\n         }","processOutput":"PHPUnit 9.5.10 by Sebastian Bergmann and contributors.\n\nRuntime:       PHP 8.0.13\nConfiguration: \/tmp\/tmp-folder\/infection\/phpunitConfiguration.33ef03b63d96f7cfaaa13173e116009c.infection.xml\n\nE\n\nTime: 00:00.004, Memory: 8.00 MB\n\nThere was 1 error:\n\n1) Fido\\PHPXray\\TraceTest::testGivenIdHeaderSetsId\nError: Typed property Fido\\PHPXray\\Segment::$traceId must not be accessed before initialization\n\n\/home\/ranpafin\/php-xray\/src\/Segment.php:120\n\/home\/ranpafin\/php-xray\/tests\/TraceTest.php:73\n\nERRORS!\nTests: 1, Assertions: 0, Errors: 1."},{"mutator":{"mutatorName":"DecrementInteger","originalSourceCode":"<?php\n\nnamespace Fido\\PHPXray;\n\nuse JsonSerializable;\nuse Fido\\PHPXray\\Submission\\SegmentSubmitter;\nclass Segment implements JsonSerializable\n{\n    protected string $id;\n    protected ?string $parentId = null;\n    protected string $traceId;\n    protected ?string $name = null;\n    protected float $startTime;\n    protected float $endTime;\n    \/** @var Segment[] *\/\n    protected array $subsegments = [];\n    protected bool $error = false;\n    protected bool $fault = false;\n    protected bool $sampled = false;\n    protected bool $independent = false;\n    \/** @var array<string, mixed> *\/\n    private array $annotations;\n    \/** @var array<string, mixed> *\/\n    private array $metadata;\n    private int $lastOpenSegment = 0;\n    \/**\n     * @throws \\Exception if an appropriate source of randomness cannot be found.\n     *\/\n    public function __construct()\n    {\n        $this->id = bin2hex(random_bytes(8));\n    }\n    public function setTraceHeader(string $traceHeader = null) : self\n    {\n        if (is_null($traceHeader)) {\n            return $this;\n        }\n        $parts = explode(';', $traceHeader);\n        $variables = array_map(function ($str) : array {\n            return explode('=', $str);\n        }, $parts);\n        $variables = array_column($variables, 1, 0);\n        if (isset($variables['Root'])) {\n            $this->setTraceId($variables['Root']);\n        }\n        if (isset($variables['Sampled'])) {\n            $this->setSampled((bool) $variables['Sampled'] ?? false);\n        }\n        if (isset($variables['Parent'])) {\n            $this->setParentId($variables['Parent'] ?? null);\n        }\n        return $this;\n    }\n    public function begin() : self\n    {\n        $this->startTime = microtime(true);\n        return $this;\n    }\n    public function end() : self\n    {\n        $this->endTime = microtime(true);\n        return $this;\n    }\n    public function setName(string $name) : self\n    {\n        $this->name = $name;\n        return $this;\n    }\n    public function setError(bool $error) : self\n    {\n        $this->error = $error;\n        return $this;\n    }\n    public function setFault(bool $fault) : self\n    {\n        $this->fault = $fault;\n        return $this;\n    }\n    public function addSubsegment(Segment $subsegment) : self\n    {\n        if (!$this->isOpen()) {\n            return $this;\n        }\n        $this->subsegments[] = $subsegment;\n        $subsegment->setSampled($this->isSampled());\n        return $this;\n    }\n    public function submit(SegmentSubmitter $submitter) : void\n    {\n        if (!$this->isSampled()) {\n            return;\n        }\n        $submitter->submitSegment($this);\n    }\n    public function isSampled() : bool\n    {\n        return $this->sampled;\n    }\n    public function setSampled(bool $sampled) : self\n    {\n        $this->sampled = $sampled;\n        return $this;\n    }\n    public function getId() : string\n    {\n        return $this->id;\n    }\n    public function setParentId(?string $parentId) : self\n    {\n        $this->parentId = $parentId;\n        return $this;\n    }\n    public function setTraceId(string $traceId) : self\n    {\n        $this->traceId = $traceId;\n        return $this;\n    }\n    public function getTraceId() : string\n    {\n        return $this->traceId;\n    }\n    public function isOpen() : bool\n    {\n        return isset($this->startTime) && !isset($this->endTime);\n    }\n    public function setIndependent(bool $independent) : self\n    {\n        $this->independent = $independent;\n        return $this;\n    }\n    public function addAnnotation(string $key, string $value) : self\n    {\n        $this->annotations[$key] = $value;\n        return $this;\n    }\n    public function addMetadata(string $key, mixed $value) : self\n    {\n        $this->metadata[$key] = $value;\n        return $this;\n    }\n    public function getCurrentSegment() : self\n    {\n        for ($max = count($this->subsegments); $this->lastOpenSegment < $max; $this->lastOpenSegment++) {\n            if ($this->subsegments[$this->lastOpenSegment]->isOpen()) {\n                return $this->subsegments[$this->lastOpenSegment]->getCurrentSegment();\n            }\n        }\n        return $this;\n    }\n    \/**\n     * @inheritDoc\n     * @return array<string, mixed>\n     *\/\n    public function jsonSerialize() : array\n    {\n        return array_filter(['id' => $this->id, 'parent_id' => $this->parentId, 'trace_id' => $this->traceId ?? null, 'name' => $this->name, 'start_time' => $this->startTime ?? null, 'end_time' => $this->endTime ?? null, 'subsegments' => $this->subsegments ?? null ?: null, 'type' => $this->independent ? 'subsegment' : null, 'fault' => $this->fault ?? null, 'error' => $this->error ?? null, 'annotations' => $this->annotations ?? null ?: null, 'metadata' => $this->metadata ?? null ?: null]);\n    }\n}","mutatedSourceCode":"<?php\n\nnamespace Fido\\PHPXray;\n\nuse JsonSerializable;\nuse Fido\\PHPXray\\Submission\\SegmentSubmitter;\nclass Segment implements JsonSerializable\n{\n    protected string $id;\n    protected ?string $parentId = null;\n    protected string $traceId;\n    protected ?string $name = null;\n    protected float $startTime;\n    protected float $endTime;\n    \/** @var Segment[] *\/\n    protected array $subsegments = [];\n    protected bool $error = false;\n    protected bool $fault = false;\n    protected bool $sampled = false;\n    protected bool $independent = false;\n    \/** @var array<string, mixed> *\/\n    private array $annotations;\n    \/** @var array<string, mixed> *\/\n    private array $metadata;\n    private int $lastOpenSegment = 0;\n    \/**\n     * @throws \\Exception if an appropriate source of randomness cannot be found.\n     *\/\n    public function __construct()\n    {\n        $this->id = bin2hex(random_bytes(8));\n    }\n    public function setTraceHeader(string $traceHeader = null) : self\n    {\n        if (is_null($traceHeader)) {\n            return $this;\n        }\n        $parts = explode(';', $traceHeader);\n        $variables = array_map(function ($str) : array {\n            return explode('=', $str);\n        }, $parts);\n        $variables = array_column($variables, 1, -1);\n        if (isset($variables['Root'])) {\n            $this->setTraceId($variables['Root']);\n        }\n        if (isset($variables['Sampled'])) {\n            $this->setSampled((bool) $variables['Sampled'] ?? false);\n        }\n        if (isset($variables['Parent'])) {\n            $this->setParentId($variables['Parent'] ?? null);\n        }\n        return $this;\n    }\n    public function begin() : self\n    {\n        $this->startTime = microtime(true);\n        return $this;\n    }\n    public function end() : self\n    {\n        $this->endTime = microtime(true);\n        return $this;\n    }\n    public function setName(string $name) : self\n    {\n        $this->name = $name;\n        return $this;\n    }\n    public function setError(bool $error) : self\n    {\n        $this->error = $error;\n        return $this;\n    }\n    public function setFault(bool $fault) : self\n    {\n        $this->fault = $fault;\n        return $this;\n    }\n    public function addSubsegment(Segment $subsegment) : self\n    {\n        if (!$this->isOpen()) {\n            return $this;\n        }\n        $this->subsegments[] = $subsegment;\n        $subsegment->setSampled($this->isSampled());\n        return $this;\n    }\n    public function submit(SegmentSubmitter $submitter) : void\n    {\n        if (!$this->isSampled()) {\n            return;\n        }\n        $submitter->submitSegment($this);\n    }\n    public function isSampled() : bool\n    {\n        return $this->sampled;\n    }\n    public function setSampled(bool $sampled) : self\n    {\n        $this->sampled = $sampled;\n        return $this;\n    }\n    public function getId() : string\n    {\n        return $this->id;\n    }\n    public function setParentId(?string $parentId) : self\n    {\n        $this->parentId = $parentId;\n        return $this;\n    }\n    public function setTraceId(string $traceId) : self\n    {\n        $this->traceId = $traceId;\n        return $this;\n    }\n    public function getTraceId() : string\n    {\n        return $this->traceId;\n    }\n    public function isOpen() : bool\n    {\n        return isset($this->startTime) && !isset($this->endTime);\n    }\n    public function setIndependent(bool $independent) : self\n    {\n        $this->independent = $independent;\n        return $this;\n    }\n    public function addAnnotation(string $key, string $value) : self\n    {\n        $this->annotations[$key] = $value;\n        return $this;\n    }\n    public function addMetadata(string $key, mixed $value) : self\n    {\n        $this->metadata[$key] = $value;\n        return $this;\n    }\n    public function getCurrentSegment() : self\n    {\n        for ($max = count($this->subsegments); $this->lastOpenSegment < $max; $this->lastOpenSegment++) {\n            if ($this->subsegments[$this->lastOpenSegment]->isOpen()) {\n                return $this->subsegments[$this->lastOpenSegment]->getCurrentSegment();\n            }\n        }\n        return $this;\n    }\n    \/**\n     * @inheritDoc\n     * @return array<string, mixed>\n     *\/\n    public function jsonSerialize() : array\n    {\n        return array_filter(['id' => $this->id, 'parent_id' => $this->parentId, 'trace_id' => $this->traceId ?? null, 'name' => $this->name, 'start_time' => $this->startTime ?? null, 'end_time' => $this->endTime ?? null, 'subsegments' => $this->subsegments ?? null ?: null, 'type' => $this->independent ? 'subsegment' : null, 'fault' => $this->fault ?? null, 'error' => $this->error ?? null, 'annotations' => $this->annotations ?? null ?: null, 'metadata' => $this->metadata ?? null ?: null]);\n    }\n}","originalFilePath":"\/home\/ranpafin\/php-xray\/src\/Segment.php","originalStartLine":48},"diff":"--- Original\n+++ New\n@@ @@\n         $variables = array_map(function ($str) : array {\n             return explode('=', $str);\n         }, $parts);\n-        $variables = array_column($variables, 1, 0);\n+        $variables = array_column($variables, 1, -1);\n         if (isset($variables['Root'])) {\n             $this->setTraceId($variables['Root']);\n         }","processOutput":"PHPUnit 9.5.10 by Sebastian Bergmann and contributors.\n\nRuntime:       PHP 8.0.13\nConfiguration: \/tmp\/tmp-folder\/infection\/phpunitConfiguration.e6e2decf89d1a210935165a5c336755e.infection.xml\n\nE\n\nTime: 00:00.004, Memory: 8.00 MB\n\nThere was 1 error:\n\n1) Fido\\PHPXray\\TraceTest::testGivenIdHeaderSetsId\nError: Typed property Fido\\PHPXray\\Segment::$traceId must not be accessed before initialization\n\n\/home\/ranpafin\/php-xray\/src\/Segment.php:120\n\/home\/ranpafin\/php-xray\/tests\/TraceTest.php:73\n\nERRORS!\nTests: 1, Assertions: 0, Errors: 1."},{"mutator":{"mutatorName":"IncrementInteger","originalSourceCode":"<?php\n\nnamespace Fido\\PHPXray;\n\nuse JsonSerializable;\nuse Fido\\PHPXray\\Submission\\SegmentSubmitter;\nclass Segment implements JsonSerializable\n{\n    protected string $id;\n    protected ?string $parentId = null;\n    protected string $traceId;\n    protected ?string $name = null;\n    protected float $startTime;\n    protected float $endTime;\n    \/** @var Segment[] *\/\n    protected array $subsegments = [];\n    protected bool $error = false;\n    protected bool $fault = false;\n    protected bool $sampled = false;\n    protected bool $independent = false;\n    \/** @var array<string, mixed> *\/\n    private array $annotations;\n    \/** @var array<string, mixed> *\/\n    private array $metadata;\n    private int $lastOpenSegment = 0;\n    \/**\n     * @throws \\Exception if an appropriate source of randomness cannot be found.\n     *\/\n    public function __construct()\n    {\n        $this->id = bin2hex(random_bytes(8));\n    }\n    public function setTraceHeader(string $traceHeader = null) : self\n    {\n        if (is_null($traceHeader)) {\n            return $this;\n        }\n        $parts = explode(';', $traceHeader);\n        $variables = array_map(function ($str) : array {\n            return explode('=', $str);\n        }, $parts);\n        $variables = array_column($variables, 1, 0);\n        if (isset($variables['Root'])) {\n            $this->setTraceId($variables['Root']);\n        }\n        if (isset($variables['Sampled'])) {\n            $this->setSampled((bool) $variables['Sampled'] ?? false);\n        }\n        if (isset($variables['Parent'])) {\n            $this->setParentId($variables['Parent'] ?? null);\n        }\n        return $this;\n    }\n    public function begin() : self\n    {\n        $this->startTime = microtime(true);\n        return $this;\n    }\n    public function end() : self\n    {\n        $this->endTime = microtime(true);\n        return $this;\n    }\n    public function setName(string $name) : self\n    {\n        $this->name = $name;\n        return $this;\n    }\n    public function setError(bool $error) : self\n    {\n        $this->error = $error;\n        return $this;\n    }\n    public function setFault(bool $fault) : self\n    {\n        $this->fault = $fault;\n        return $this;\n    }\n    public function addSubsegment(Segment $subsegment) : self\n    {\n        if (!$this->isOpen()) {\n            return $this;\n        }\n        $this->subsegments[] = $subsegment;\n        $subsegment->setSampled($this->isSampled());\n        return $this;\n    }\n    public function submit(SegmentSubmitter $submitter) : void\n    {\n        if (!$this->isSampled()) {\n            return;\n        }\n        $submitter->submitSegment($this);\n    }\n    public function isSampled() : bool\n    {\n        return $this->sampled;\n    }\n    public function setSampled(bool $sampled) : self\n    {\n        $this->sampled = $sampled;\n        return $this;\n    }\n    public function getId() : string\n    {\n        return $this->id;\n    }\n    public function setParentId(?string $parentId) : self\n    {\n        $this->parentId = $parentId;\n        return $this;\n    }\n    public function setTraceId(string $traceId) : self\n    {\n        $this->traceId = $traceId;\n        return $this;\n    }\n    public function getTraceId() : string\n    {\n        return $this->traceId;\n    }\n    public function isOpen() : bool\n    {\n        return isset($this->startTime) && !isset($this->endTime);\n    }\n    public function setIndependent(bool $independent) : self\n    {\n        $this->independent = $independent;\n        return $this;\n    }\n    public function addAnnotation(string $key, string $value) : self\n    {\n        $this->annotations[$key] = $value;\n        return $this;\n    }\n    public function addMetadata(string $key, mixed $value) : self\n    {\n        $this->metadata[$key] = $value;\n        return $this;\n    }\n    public function getCurrentSegment() : self\n    {\n        for ($max = count($this->subsegments); $this->lastOpenSegment < $max; $this->lastOpenSegment++) {\n            if ($this->subsegments[$this->lastOpenSegment]->isOpen()) {\n                return $this->subsegments[$this->lastOpenSegment]->getCurrentSegment();\n            }\n        }\n        return $this;\n    }\n    \/**\n     * @inheritDoc\n     * @return array<string, mixed>\n     *\/\n    public function jsonSerialize() : array\n    {\n        return array_filter(['id' => $this->id, 'parent_id' => $this->parentId, 'trace_id' => $this->traceId ?? null, 'name' => $this->name, 'start_time' => $this->startTime ?? null, 'end_time' => $this->endTime ?? null, 'subsegments' => $this->subsegments ?? null ?: null, 'type' => $this->independent ? 'subsegment' : null, 'fault' => $this->fault ?? null, 'error' => $this->error ?? null, 'annotations' => $this->annotations ?? null ?: null, 'metadata' => $this->metadata ?? null ?: null]);\n    }\n}","mutatedSourceCode":"<?php\n\nnamespace Fido\\PHPXray;\n\nuse JsonSerializable;\nuse Fido\\PHPXray\\Submission\\SegmentSubmitter;\nclass Segment implements JsonSerializable\n{\n    protected string $id;\n    protected ?string $parentId = null;\n    protected string $traceId;\n    protected ?string $name = null;\n    protected float $startTime;\n    protected float $endTime;\n    \/** @var Segment[] *\/\n    protected array $subsegments = [];\n    protected bool $error = false;\n    protected bool $fault = false;\n    protected bool $sampled = false;\n    protected bool $independent = false;\n    \/** @var array<string, mixed> *\/\n    private array $annotations;\n    \/** @var array<string, mixed> *\/\n    private array $metadata;\n    private int $lastOpenSegment = 0;\n    \/**\n     * @throws \\Exception if an appropriate source of randomness cannot be found.\n     *\/\n    public function __construct()\n    {\n        $this->id = bin2hex(random_bytes(8));\n    }\n    public function setTraceHeader(string $traceHeader = null) : self\n    {\n        if (is_null($traceHeader)) {\n            return $this;\n        }\n        $parts = explode(';', $traceHeader);\n        $variables = array_map(function ($str) : array {\n            return explode('=', $str);\n        }, $parts);\n        $variables = array_column($variables, 1, 1);\n        if (isset($variables['Root'])) {\n            $this->setTraceId($variables['Root']);\n        }\n        if (isset($variables['Sampled'])) {\n            $this->setSampled((bool) $variables['Sampled'] ?? false);\n        }\n        if (isset($variables['Parent'])) {\n            $this->setParentId($variables['Parent'] ?? null);\n        }\n        return $this;\n    }\n    public function begin() : self\n    {\n        $this->startTime = microtime(true);\n        return $this;\n    }\n    public function end() : self\n    {\n        $this->endTime = microtime(true);\n        return $this;\n    }\n    public function setName(string $name) : self\n    {\n        $this->name = $name;\n        return $this;\n    }\n    public function setError(bool $error) : self\n    {\n        $this->error = $error;\n        return $this;\n    }\n    public function setFault(bool $fault) : self\n    {\n        $this->fault = $fault;\n        return $this;\n    }\n    public function addSubsegment(Segment $subsegment) : self\n    {\n        if (!$this->isOpen()) {\n            return $this;\n        }\n        $this->subsegments[] = $subsegment;\n        $subsegment->setSampled($this->isSampled());\n        return $this;\n    }\n    public function submit(SegmentSubmitter $submitter) : void\n    {\n        if (!$this->isSampled()) {\n            return;\n        }\n        $submitter->submitSegment($this);\n    }\n    public function isSampled() : bool\n    {\n        return $this->sampled;\n    }\n    public function setSampled(bool $sampled) : self\n    {\n        $this->sampled = $sampled;\n        return $this;\n    }\n    public function getId() : string\n    {\n        return $this->id;\n    }\n    public function setParentId(?string $parentId) : self\n    {\n        $this->parentId = $parentId;\n        return $this;\n    }\n    public function setTraceId(string $traceId) : self\n    {\n        $this->traceId = $traceId;\n        return $this;\n    }\n    public function getTraceId() : string\n    {\n        return $this->traceId;\n    }\n    public function isOpen() : bool\n    {\n        return isset($this->startTime) && !isset($this->endTime);\n    }\n    public function setIndependent(bool $independent) : self\n    {\n        $this->independent = $independent;\n        return $this;\n    }\n    public function addAnnotation(string $key, string $value) : self\n    {\n        $this->annotations[$key] = $value;\n        return $this;\n    }\n    public function addMetadata(string $key, mixed $value) : self\n    {\n        $this->metadata[$key] = $value;\n        return $this;\n    }\n    public function getCurrentSegment() : self\n    {\n        for ($max = count($this->subsegments); $this->lastOpenSegment < $max; $this->lastOpenSegment++) {\n            if ($this->subsegments[$this->lastOpenSegment]->isOpen()) {\n                return $this->subsegments[$this->lastOpenSegment]->getCurrentSegment();\n            }\n        }\n        return $this;\n    }\n    \/**\n     * @inheritDoc\n     * @return array<string, mixed>\n     *\/\n    public function jsonSerialize() : array\n    {\n        return array_filter(['id' => $this->id, 'parent_id' => $this->parentId, 'trace_id' => $this->traceId ?? null, 'name' => $this->name, 'start_time' => $this->startTime ?? null, 'end_time' => $this->endTime ?? null, 'subsegments' => $this->subsegments ?? null ?: null, 'type' => $this->independent ? 'subsegment' : null, 'fault' => $this->fault ?? null, 'error' => $this->error ?? null, 'annotations' => $this->annotations ?? null ?: null, 'metadata' => $this->metadata ?? null ?: null]);\n    }\n}","originalFilePath":"\/home\/ranpafin\/php-xray\/src\/Segment.php","originalStartLine":48},"diff":"--- Original\n+++ New\n@@ @@\n         $variables = array_map(function ($str) : array {\n             return explode('=', $str);\n         }, $parts);\n-        $variables = array_column($variables, 1, 0);\n+        $variables = array_column($variables, 1, 1);\n         if (isset($variables['Root'])) {\n             $this->setTraceId($variables['Root']);\n         }","processOutput":"PHPUnit 9.5.10 by Sebastian Bergmann and contributors.\n\nRuntime:       PHP 8.0.13\nConfiguration: \/tmp\/tmp-folder\/infection\/phpunitConfiguration.2796777a41970aaabe81abfb784da4ce.infection.xml\n\nE\n\nTime: 00:00.004, Memory: 8.00 MB\n\nThere was 1 error:\n\n1) Fido\\PHPXray\\TraceTest::testGivenIdHeaderSetsId\nError: Typed property Fido\\PHPXray\\Segment::$traceId must not be accessed before initialization\n\n\/home\/ranpafin\/php-xray\/src\/Segment.php:120\n\/home\/ranpafin\/php-xray\/tests\/TraceTest.php:73\n\nERRORS!\nTests: 1, Assertions: 0, Errors: 1."},{"mutator":{"mutatorName":"UnwrapArrayColumn","originalSourceCode":"<?php\n\nnamespace Fido\\PHPXray;\n\nuse JsonSerializable;\nuse Fido\\PHPXray\\Submission\\SegmentSubmitter;\nclass Segment implements JsonSerializable\n{\n    protected string $id;\n    protected ?string $parentId = null;\n    protected string $traceId;\n    protected ?string $name = null;\n    protected float $startTime;\n    protected float $endTime;\n    \/** @var Segment[] *\/\n    protected array $subsegments = [];\n    protected bool $error = false;\n    protected bool $fault = false;\n    protected bool $sampled = false;\n    protected bool $independent = false;\n    \/** @var array<string, mixed> *\/\n    private array $annotations;\n    \/** @var array<string, mixed> *\/\n    private array $metadata;\n    private int $lastOpenSegment = 0;\n    \/**\n     * @throws \\Exception if an appropriate source of randomness cannot be found.\n     *\/\n    public function __construct()\n    {\n        $this->id = bin2hex(random_bytes(8));\n    }\n    public function setTraceHeader(string $traceHeader = null) : self\n    {\n        if (is_null($traceHeader)) {\n            return $this;\n        }\n        $parts = explode(';', $traceHeader);\n        $variables = array_map(function ($str) : array {\n            return explode('=', $str);\n        }, $parts);\n        $variables = array_column($variables, 1, 0);\n        if (isset($variables['Root'])) {\n            $this->setTraceId($variables['Root']);\n        }\n        if (isset($variables['Sampled'])) {\n            $this->setSampled((bool) $variables['Sampled'] ?? false);\n        }\n        if (isset($variables['Parent'])) {\n            $this->setParentId($variables['Parent'] ?? null);\n        }\n        return $this;\n    }\n    public function begin() : self\n    {\n        $this->startTime = microtime(true);\n        return $this;\n    }\n    public function end() : self\n    {\n        $this->endTime = microtime(true);\n        return $this;\n    }\n    public function setName(string $name) : self\n    {\n        $this->name = $name;\n        return $this;\n    }\n    public function setError(bool $error) : self\n    {\n        $this->error = $error;\n        return $this;\n    }\n    public function setFault(bool $fault) : self\n    {\n        $this->fault = $fault;\n        return $this;\n    }\n    public function addSubsegment(Segment $subsegment) : self\n    {\n        if (!$this->isOpen()) {\n            return $this;\n        }\n        $this->subsegments[] = $subsegment;\n        $subsegment->setSampled($this->isSampled());\n        return $this;\n    }\n    public function submit(SegmentSubmitter $submitter) : void\n    {\n        if (!$this->isSampled()) {\n            return;\n        }\n        $submitter->submitSegment($this);\n    }\n    public function isSampled() : bool\n    {\n        return $this->sampled;\n    }\n    public function setSampled(bool $sampled) : self\n    {\n        $this->sampled = $sampled;\n        return $this;\n    }\n    public function getId() : string\n    {\n        return $this->id;\n    }\n    public function setParentId(?string $parentId) : self\n    {\n        $this->parentId = $parentId;\n        return $this;\n    }\n    public function setTraceId(string $traceId) : self\n    {\n        $this->traceId = $traceId;\n        return $this;\n    }\n    public function getTraceId() : string\n    {\n        return $this->traceId;\n    }\n    public function isOpen() : bool\n    {\n        return isset($this->startTime) && !isset($this->endTime);\n    }\n    public function setIndependent(bool $independent) : self\n    {\n        $this->independent = $independent;\n        return $this;\n    }\n    public function addAnnotation(string $key, string $value) : self\n    {\n        $this->annotations[$key] = $value;\n        return $this;\n    }\n    public function addMetadata(string $key, mixed $value) : self\n    {\n        $this->metadata[$key] = $value;\n        return $this;\n    }\n    public function getCurrentSegment() : self\n    {\n        for ($max = count($this->subsegments); $this->lastOpenSegment < $max; $this->lastOpenSegment++) {\n            if ($this->subsegments[$this->lastOpenSegment]->isOpen()) {\n                return $this->subsegments[$this->lastOpenSegment]->getCurrentSegment();\n            }\n        }\n        return $this;\n    }\n    \/**\n     * @inheritDoc\n     * @return array<string, mixed>\n     *\/\n    public function jsonSerialize() : array\n    {\n        return array_filter(['id' => $this->id, 'parent_id' => $this->parentId, 'trace_id' => $this->traceId ?? null, 'name' => $this->name, 'start_time' => $this->startTime ?? null, 'end_time' => $this->endTime ?? null, 'subsegments' => $this->subsegments ?? null ?: null, 'type' => $this->independent ? 'subsegment' : null, 'fault' => $this->fault ?? null, 'error' => $this->error ?? null, 'annotations' => $this->annotations ?? null ?: null, 'metadata' => $this->metadata ?? null ?: null]);\n    }\n}","mutatedSourceCode":"<?php\n\nnamespace Fido\\PHPXray;\n\nuse JsonSerializable;\nuse Fido\\PHPXray\\Submission\\SegmentSubmitter;\nclass Segment implements JsonSerializable\n{\n    protected string $id;\n    protected ?string $parentId = null;\n    protected string $traceId;\n    protected ?string $name = null;\n    protected float $startTime;\n    protected float $endTime;\n    \/** @var Segment[] *\/\n    protected array $subsegments = [];\n    protected bool $error = false;\n    protected bool $fault = false;\n    protected bool $sampled = false;\n    protected bool $independent = false;\n    \/** @var array<string, mixed> *\/\n    private array $annotations;\n    \/** @var array<string, mixed> *\/\n    private array $metadata;\n    private int $lastOpenSegment = 0;\n    \/**\n     * @throws \\Exception if an appropriate source of randomness cannot be found.\n     *\/\n    public function __construct()\n    {\n        $this->id = bin2hex(random_bytes(8));\n    }\n    public function setTraceHeader(string $traceHeader = null) : self\n    {\n        if (is_null($traceHeader)) {\n            return $this;\n        }\n        $parts = explode(';', $traceHeader);\n        $variables = array_map(function ($str) : array {\n            return explode('=', $str);\n        }, $parts);\n        $variables = $variables;\n        if (isset($variables['Root'])) {\n            $this->setTraceId($variables['Root']);\n        }\n        if (isset($variables['Sampled'])) {\n            $this->setSampled((bool) $variables['Sampled'] ?? false);\n        }\n        if (isset($variables['Parent'])) {\n            $this->setParentId($variables['Parent'] ?? null);\n        }\n        return $this;\n    }\n    public function begin() : self\n    {\n        $this->startTime = microtime(true);\n        return $this;\n    }\n    public function end() : self\n    {\n        $this->endTime = microtime(true);\n        return $this;\n    }\n    public function setName(string $name) : self\n    {\n        $this->name = $name;\n        return $this;\n    }\n    public function setError(bool $error) : self\n    {\n        $this->error = $error;\n        return $this;\n    }\n    public function setFault(bool $fault) : self\n    {\n        $this->fault = $fault;\n        return $this;\n    }\n    public function addSubsegment(Segment $subsegment) : self\n    {\n        if (!$this->isOpen()) {\n            return $this;\n        }\n        $this->subsegments[] = $subsegment;\n        $subsegment->setSampled($this->isSampled());\n        return $this;\n    }\n    public function submit(SegmentSubmitter $submitter) : void\n    {\n        if (!$this->isSampled()) {\n            return;\n        }\n        $submitter->submitSegment($this);\n    }\n    public function isSampled() : bool\n    {\n        return $this->sampled;\n    }\n    public function setSampled(bool $sampled) : self\n    {\n        $this->sampled = $sampled;\n        return $this;\n    }\n    public function getId() : string\n    {\n        return $this->id;\n    }\n    public function setParentId(?string $parentId) : self\n    {\n        $this->parentId = $parentId;\n        return $this;\n    }\n    public function setTraceId(string $traceId) : self\n    {\n        $this->traceId = $traceId;\n        return $this;\n    }\n    public function getTraceId() : string\n    {\n        return $this->traceId;\n    }\n    public function isOpen() : bool\n    {\n        return isset($this->startTime) && !isset($this->endTime);\n    }\n    public function setIndependent(bool $independent) : self\n    {\n        $this->independent = $independent;\n        return $this;\n    }\n    public function addAnnotation(string $key, string $value) : self\n    {\n        $this->annotations[$key] = $value;\n        return $this;\n    }\n    public function addMetadata(string $key, mixed $value) : self\n    {\n        $this->metadata[$key] = $value;\n        return $this;\n    }\n    public function getCurrentSegment() : self\n    {\n        for ($max = count($this->subsegments); $this->lastOpenSegment < $max; $this->lastOpenSegment++) {\n            if ($this->subsegments[$this->lastOpenSegment]->isOpen()) {\n                return $this->subsegments[$this->lastOpenSegment]->getCurrentSegment();\n            }\n        }\n        return $this;\n    }\n    \/**\n     * @inheritDoc\n     * @return array<string, mixed>\n     *\/\n    public function jsonSerialize() : array\n    {\n        return array_filter(['id' => $this->id, 'parent_id' => $this->parentId, 'trace_id' => $this->traceId ?? null, 'name' => $this->name, 'start_time' => $this->startTime ?? null, 'end_time' => $this->endTime ?? null, 'subsegments' => $this->subsegments ?? null ?: null, 'type' => $this->independent ? 'subsegment' : null, 'fault' => $this->fault ?? null, 'error' => $this->error ?? null, 'annotations' => $this->annotations ?? null ?: null, 'metadata' => $this->metadata ?? null ?: null]);\n    }\n}","originalFilePath":"\/home\/ranpafin\/php-xray\/src\/Segment.php","originalStartLine":48},"diff":"--- Original\n+++ New\n@@ @@\n         $variables = array_map(function ($str) : array {\n             return explode('=', $str);\n         }, $parts);\n-        $variables = array_column($variables, 1, 0);\n+        $variables = $variables;\n         if (isset($variables['Root'])) {\n             $this->setTraceId($variables['Root']);\n         }","processOutput":"PHPUnit 9.5.10 by Sebastian Bergmann and contributors.\n\nRuntime:       PHP 8.0.13\nConfiguration: \/tmp\/tmp-folder\/infection\/phpunitConfiguration.14b1b9f4ec8989b575d2ba78a570ad97.infection.xml\n\nE\n\nTime: 00:00.004, Memory: 8.00 MB\n\nThere was 1 error:\n\n1) Fido\\PHPXray\\TraceTest::testGivenIdHeaderSetsId\nError: Typed property Fido\\PHPXray\\Segment::$traceId must not be accessed before initialization\n\n\/home\/ranpafin\/php-xray\/src\/Segment.php:120\n\/home\/ranpafin\/php-xray\/tests\/TraceTest.php:73\n\nERRORS!\nTests: 1, Assertions: 0, Errors: 1."},{"mutator":{"mutatorName":"MethodCallRemoval","originalSourceCode":"<?php\n\nnamespace Fido\\PHPXray;\n\nuse JsonSerializable;\nuse Fido\\PHPXray\\Submission\\SegmentSubmitter;\nclass Segment implements JsonSerializable\n{\n    protected string $id;\n    protected ?string $parentId = null;\n    protected string $traceId;\n    protected ?string $name = null;\n    protected float $startTime;\n    protected float $endTime;\n    \/** @var Segment[] *\/\n    protected array $subsegments = [];\n    protected bool $error = false;\n    protected bool $fault = false;\n    protected bool $sampled = false;\n    protected bool $independent = false;\n    \/** @var array<string, mixed> *\/\n    private array $annotations;\n    \/** @var array<string, mixed> *\/\n    private array $metadata;\n    private int $lastOpenSegment = 0;\n    \/**\n     * @throws \\Exception if an appropriate source of randomness cannot be found.\n     *\/\n    public function __construct()\n    {\n        $this->id = bin2hex(random_bytes(8));\n    }\n    public function setTraceHeader(string $traceHeader = null) : self\n    {\n        if (is_null($traceHeader)) {\n            return $this;\n        }\n        $parts = explode(';', $traceHeader);\n        $variables = array_map(function ($str) : array {\n            return explode('=', $str);\n        }, $parts);\n        $variables = array_column($variables, 1, 0);\n        if (isset($variables['Root'])) {\n            $this->setTraceId($variables['Root']);\n        }\n        if (isset($variables['Sampled'])) {\n            $this->setSampled((bool) $variables['Sampled'] ?? false);\n        }\n        if (isset($variables['Parent'])) {\n            $this->setParentId($variables['Parent'] ?? null);\n        }\n        return $this;\n    }\n    public function begin() : self\n    {\n        $this->startTime = microtime(true);\n        return $this;\n    }\n    public function end() : self\n    {\n        $this->endTime = microtime(true);\n        return $this;\n    }\n    public function setName(string $name) : self\n    {\n        $this->name = $name;\n        return $this;\n    }\n    public function setError(bool $error) : self\n    {\n        $this->error = $error;\n        return $this;\n    }\n    public function setFault(bool $fault) : self\n    {\n        $this->fault = $fault;\n        return $this;\n    }\n    public function addSubsegment(Segment $subsegment) : self\n    {\n        if (!$this->isOpen()) {\n            return $this;\n        }\n        $this->subsegments[] = $subsegment;\n        $subsegment->setSampled($this->isSampled());\n        return $this;\n    }\n    public function submit(SegmentSubmitter $submitter) : void\n    {\n        if (!$this->isSampled()) {\n            return;\n        }\n        $submitter->submitSegment($this);\n    }\n    public function isSampled() : bool\n    {\n        return $this->sampled;\n    }\n    public function setSampled(bool $sampled) : self\n    {\n        $this->sampled = $sampled;\n        return $this;\n    }\n    public function getId() : string\n    {\n        return $this->id;\n    }\n    public function setParentId(?string $parentId) : self\n    {\n        $this->parentId = $parentId;\n        return $this;\n    }\n    public function setTraceId(string $traceId) : self\n    {\n        $this->traceId = $traceId;\n        return $this;\n    }\n    public function getTraceId() : string\n    {\n        return $this->traceId;\n    }\n    public function isOpen() : bool\n    {\n        return isset($this->startTime) && !isset($this->endTime);\n    }\n    public function setIndependent(bool $independent) : self\n    {\n        $this->independent = $independent;\n        return $this;\n    }\n    public function addAnnotation(string $key, string $value) : self\n    {\n        $this->annotations[$key] = $value;\n        return $this;\n    }\n    public function addMetadata(string $key, mixed $value) : self\n    {\n        $this->metadata[$key] = $value;\n        return $this;\n    }\n    public function getCurrentSegment() : self\n    {\n        for ($max = count($this->subsegments); $this->lastOpenSegment < $max; $this->lastOpenSegment++) {\n            if ($this->subsegments[$this->lastOpenSegment]->isOpen()) {\n                return $this->subsegments[$this->lastOpenSegment]->getCurrentSegment();\n            }\n        }\n        return $this;\n    }\n    \/**\n     * @inheritDoc\n     * @return array<string, mixed>\n     *\/\n    public function jsonSerialize() : array\n    {\n        return array_filter(['id' => $this->id, 'parent_id' => $this->parentId, 'trace_id' => $this->traceId ?? null, 'name' => $this->name, 'start_time' => $this->startTime ?? null, 'end_time' => $this->endTime ?? null, 'subsegments' => $this->subsegments ?? null ?: null, 'type' => $this->independent ? 'subsegment' : null, 'fault' => $this->fault ?? null, 'error' => $this->error ?? null, 'annotations' => $this->annotations ?? null ?: null, 'metadata' => $this->metadata ?? null ?: null]);\n    }\n}","mutatedSourceCode":"<?php\n\nnamespace Fido\\PHPXray;\n\nuse JsonSerializable;\nuse Fido\\PHPXray\\Submission\\SegmentSubmitter;\nclass Segment implements JsonSerializable\n{\n    protected string $id;\n    protected ?string $parentId = null;\n    protected string $traceId;\n    protected ?string $name = null;\n    protected float $startTime;\n    protected float $endTime;\n    \/** @var Segment[] *\/\n    protected array $subsegments = [];\n    protected bool $error = false;\n    protected bool $fault = false;\n    protected bool $sampled = false;\n    protected bool $independent = false;\n    \/** @var array<string, mixed> *\/\n    private array $annotations;\n    \/** @var array<string, mixed> *\/\n    private array $metadata;\n    private int $lastOpenSegment = 0;\n    \/**\n     * @throws \\Exception if an appropriate source of randomness cannot be found.\n     *\/\n    public function __construct()\n    {\n        $this->id = bin2hex(random_bytes(8));\n    }\n    public function setTraceHeader(string $traceHeader = null) : self\n    {\n        if (is_null($traceHeader)) {\n            return $this;\n        }\n        $parts = explode(';', $traceHeader);\n        $variables = array_map(function ($str) : array {\n            return explode('=', $str);\n        }, $parts);\n        $variables = array_column($variables, 1, 0);\n        if (isset($variables['Root'])) {\n            \n        }\n        if (isset($variables['Sampled'])) {\n            $this->setSampled((bool) $variables['Sampled'] ?? false);\n        }\n        if (isset($variables['Parent'])) {\n            $this->setParentId($variables['Parent'] ?? null);\n        }\n        return $this;\n    }\n    public function begin() : self\n    {\n        $this->startTime = microtime(true);\n        return $this;\n    }\n    public function end() : self\n    {\n        $this->endTime = microtime(true);\n        return $this;\n    }\n    public function setName(string $name) : self\n    {\n        $this->name = $name;\n        return $this;\n    }\n    public function setError(bool $error) : self\n    {\n        $this->error = $error;\n        return $this;\n    }\n    public function setFault(bool $fault) : self\n    {\n        $this->fault = $fault;\n        return $this;\n    }\n    public function addSubsegment(Segment $subsegment) : self\n    {\n        if (!$this->isOpen()) {\n            return $this;\n        }\n        $this->subsegments[] = $subsegment;\n        $subsegment->setSampled($this->isSampled());\n        return $this;\n    }\n    public function submit(SegmentSubmitter $submitter) : void\n    {\n        if (!$this->isSampled()) {\n            return;\n        }\n        $submitter->submitSegment($this);\n    }\n    public function isSampled() : bool\n    {\n        return $this->sampled;\n    }\n    public function setSampled(bool $sampled) : self\n    {\n        $this->sampled = $sampled;\n        return $this;\n    }\n    public function getId() : string\n    {\n        return $this->id;\n    }\n    public function setParentId(?string $parentId) : self\n    {\n        $this->parentId = $parentId;\n        return $this;\n    }\n    public function setTraceId(string $traceId) : self\n    {\n        $this->traceId = $traceId;\n        return $this;\n    }\n    public function getTraceId() : string\n    {\n        return $this->traceId;\n    }\n    public function isOpen() : bool\n    {\n        return isset($this->startTime) && !isset($this->endTime);\n    }\n    public function setIndependent(bool $independent) : self\n    {\n        $this->independent = $independent;\n        return $this;\n    }\n    public function addAnnotation(string $key, string $value) : self\n    {\n        $this->annotations[$key] = $value;\n        return $this;\n    }\n    public function addMetadata(string $key, mixed $value) : self\n    {\n        $this->metadata[$key] = $value;\n        return $this;\n    }\n    public function getCurrentSegment() : self\n    {\n        for ($max = count($this->subsegments); $this->lastOpenSegment < $max; $this->lastOpenSegment++) {\n            if ($this->subsegments[$this->lastOpenSegment]->isOpen()) {\n                return $this->subsegments[$this->lastOpenSegment]->getCurrentSegment();\n            }\n        }\n        return $this;\n    }\n    \/**\n     * @inheritDoc\n     * @return array<string, mixed>\n     *\/\n    public function jsonSerialize() : array\n    {\n        return array_filter(['id' => $this->id, 'parent_id' => $this->parentId, 'trace_id' => $this->traceId ?? null, 'name' => $this->name, 'start_time' => $this->startTime ?? null, 'end_time' => $this->endTime ?? null, 'subsegments' => $this->subsegments ?? null ?: null, 'type' => $this->independent ? 'subsegment' : null, 'fault' => $this->fault ?? null, 'error' => $this->error ?? null, 'annotations' => $this->annotations ?? null ?: null, 'metadata' => $this->metadata ?? null ?: null]);\n    }\n}","originalFilePath":"\/home\/ranpafin\/php-xray\/src\/Segment.php","originalStartLine":51},"diff":"--- Original\n+++ New\n@@ @@\n         }, $parts);\n         $variables = array_column($variables, 1, 0);\n         if (isset($variables['Root'])) {\n-            $this->setTraceId($variables['Root']);\n+            \n         }\n         if (isset($variables['Sampled'])) {\n             $this->setSampled((bool) $variables['Sampled'] ?? false);","processOutput":"PHPUnit 9.5.10 by Sebastian Bergmann and contributors.\n\nRuntime:       PHP 8.0.13\nConfiguration: \/tmp\/tmp-folder\/infection\/phpunitConfiguration.68a8d3cc269a9e87fa0f94fc5dc75569.infection.xml\n\nE\n\nTime: 00:00.004, Memory: 8.00 MB\n\nThere was 1 error:\n\n1) Fido\\PHPXray\\TraceTest::testGivenIdHeaderSetsId\nError: Typed property Fido\\PHPXray\\Segment::$traceId must not be accessed before initialization\n\n\/home\/ranpafin\/php-xray\/src\/Segment.php:120\n\/home\/ranpafin\/php-xray\/tests\/TraceTest.php:73\n\nERRORS!\nTests: 1, Assertions: 0, Errors: 1."},{"mutator":{"mutatorName":"Coalesce","originalSourceCode":"<?php\n\nnamespace Fido\\PHPXray;\n\nuse JsonSerializable;\nuse Fido\\PHPXray\\Submission\\SegmentSubmitter;\nclass Segment implements JsonSerializable\n{\n    protected string $id;\n    protected ?string $parentId = null;\n    protected string $traceId;\n    protected ?string $name = null;\n    protected float $startTime;\n    protected float $endTime;\n    \/** @var Segment[] *\/\n    protected array $subsegments = [];\n    protected bool $error = false;\n    protected bool $fault = false;\n    protected bool $sampled = false;\n    protected bool $independent = false;\n    \/** @var array<string, mixed> *\/\n    private array $annotations;\n    \/** @var array<string, mixed> *\/\n    private array $metadata;\n    private int $lastOpenSegment = 0;\n    \/**\n     * @throws \\Exception if an appropriate source of randomness cannot be found.\n     *\/\n    public function __construct()\n    {\n        $this->id = bin2hex(random_bytes(8));\n    }\n    public function setTraceHeader(string $traceHeader = null) : self\n    {\n        if (is_null($traceHeader)) {\n            return $this;\n        }\n        $parts = explode(';', $traceHeader);\n        $variables = array_map(function ($str) : array {\n            return explode('=', $str);\n        }, $parts);\n        $variables = array_column($variables, 1, 0);\n        if (isset($variables['Root'])) {\n            $this->setTraceId($variables['Root']);\n        }\n        if (isset($variables['Sampled'])) {\n            $this->setSampled((bool) $variables['Sampled'] ?? false);\n        }\n        if (isset($variables['Parent'])) {\n            $this->setParentId($variables['Parent'] ?? null);\n        }\n        return $this;\n    }\n    public function begin() : self\n    {\n        $this->startTime = microtime(true);\n        return $this;\n    }\n    public function end() : self\n    {\n        $this->endTime = microtime(true);\n        return $this;\n    }\n    public function setName(string $name) : self\n    {\n        $this->name = $name;\n        return $this;\n    }\n    public function setError(bool $error) : self\n    {\n        $this->error = $error;\n        return $this;\n    }\n    public function setFault(bool $fault) : self\n    {\n        $this->fault = $fault;\n        return $this;\n    }\n    public function addSubsegment(Segment $subsegment) : self\n    {\n        if (!$this->isOpen()) {\n            return $this;\n        }\n        $this->subsegments[] = $subsegment;\n        $subsegment->setSampled($this->isSampled());\n        return $this;\n    }\n    public function submit(SegmentSubmitter $submitter) : void\n    {\n        if (!$this->isSampled()) {\n            return;\n        }\n        $submitter->submitSegment($this);\n    }\n    public function isSampled() : bool\n    {\n        return $this->sampled;\n    }\n    public function setSampled(bool $sampled) : self\n    {\n        $this->sampled = $sampled;\n        return $this;\n    }\n    public function getId() : string\n    {\n        return $this->id;\n    }\n    public function setParentId(?string $parentId) : self\n    {\n        $this->parentId = $parentId;\n        return $this;\n    }\n    public function setTraceId(string $traceId) : self\n    {\n        $this->traceId = $traceId;\n        return $this;\n    }\n    public function getTraceId() : string\n    {\n        return $this->traceId;\n    }\n    public function isOpen() : bool\n    {\n        return isset($this->startTime) && !isset($this->endTime);\n    }\n    public function setIndependent(bool $independent) : self\n    {\n        $this->independent = $independent;\n        return $this;\n    }\n    public function addAnnotation(string $key, string $value) : self\n    {\n        $this->annotations[$key] = $value;\n        return $this;\n    }\n    public function addMetadata(string $key, mixed $value) : self\n    {\n        $this->metadata[$key] = $value;\n        return $this;\n    }\n    public function getCurrentSegment() : self\n    {\n        for ($max = count($this->subsegments); $this->lastOpenSegment < $max; $this->lastOpenSegment++) {\n            if ($this->subsegments[$this->lastOpenSegment]->isOpen()) {\n                return $this->subsegments[$this->lastOpenSegment]->getCurrentSegment();\n            }\n        }\n        return $this;\n    }\n    \/**\n     * @inheritDoc\n     * @return array<string, mixed>\n     *\/\n    public function jsonSerialize() : array\n    {\n        return array_filter(['id' => $this->id, 'parent_id' => $this->parentId, 'trace_id' => $this->traceId ?? null, 'name' => $this->name, 'start_time' => $this->startTime ?? null, 'end_time' => $this->endTime ?? null, 'subsegments' => $this->subsegments ?? null ?: null, 'type' => $this->independent ? 'subsegment' : null, 'fault' => $this->fault ?? null, 'error' => $this->error ?? null, 'annotations' => $this->annotations ?? null ?: null, 'metadata' => $this->metadata ?? null ?: null]);\n    }\n}","mutatedSourceCode":"<?php\n\nnamespace Fido\\PHPXray;\n\nuse JsonSerializable;\nuse Fido\\PHPXray\\Submission\\SegmentSubmitter;\nclass Segment implements JsonSerializable\n{\n    protected string $id;\n    protected ?string $parentId = null;\n    protected string $traceId;\n    protected ?string $name = null;\n    protected float $startTime;\n    protected float $endTime;\n    \/** @var Segment[] *\/\n    protected array $subsegments = [];\n    protected bool $error = false;\n    protected bool $fault = false;\n    protected bool $sampled = false;\n    protected bool $independent = false;\n    \/** @var array<string, mixed> *\/\n    private array $annotations;\n    \/** @var array<string, mixed> *\/\n    private array $metadata;\n    private int $lastOpenSegment = 0;\n    \/**\n     * @throws \\Exception if an appropriate source of randomness cannot be found.\n     *\/\n    public function __construct()\n    {\n        $this->id = bin2hex(random_bytes(8));\n    }\n    public function setTraceHeader(string $traceHeader = null) : self\n    {\n        if (is_null($traceHeader)) {\n            return $this;\n        }\n        $parts = explode(';', $traceHeader);\n        $variables = array_map(function ($str) : array {\n            return explode('=', $str);\n        }, $parts);\n        $variables = array_column($variables, 1, 0);\n        if (isset($variables['Root'])) {\n            $this->setTraceId($variables['Root']);\n        }\n        if (isset($variables['Sampled'])) {\n            $this->setSampled(false ?? (bool) $variables['Sampled']);\n        }\n        if (isset($variables['Parent'])) {\n            $this->setParentId($variables['Parent'] ?? null);\n        }\n        return $this;\n    }\n    public function begin() : self\n    {\n        $this->startTime = microtime(true);\n        return $this;\n    }\n    public function end() : self\n    {\n        $this->endTime = microtime(true);\n        return $this;\n    }\n    public function setName(string $name) : self\n    {\n        $this->name = $name;\n        return $this;\n    }\n    public function setError(bool $error) : self\n    {\n        $this->error = $error;\n        return $this;\n    }\n    public function setFault(bool $fault) : self\n    {\n        $this->fault = $fault;\n        return $this;\n    }\n    public function addSubsegment(Segment $subsegment) : self\n    {\n        if (!$this->isOpen()) {\n            return $this;\n        }\n        $this->subsegments[] = $subsegment;\n        $subsegment->setSampled($this->isSampled());\n        return $this;\n    }\n    public function submit(SegmentSubmitter $submitter) : void\n    {\n        if (!$this->isSampled()) {\n            return;\n        }\n        $submitter->submitSegment($this);\n    }\n    public function isSampled() : bool\n    {\n        return $this->sampled;\n    }\n    public function setSampled(bool $sampled) : self\n    {\n        $this->sampled = $sampled;\n        return $this;\n    }\n    public function getId() : string\n    {\n        return $this->id;\n    }\n    public function setParentId(?string $parentId) : self\n    {\n        $this->parentId = $parentId;\n        return $this;\n    }\n    public function setTraceId(string $traceId) : self\n    {\n        $this->traceId = $traceId;\n        return $this;\n    }\n    public function getTraceId() : string\n    {\n        return $this->traceId;\n    }\n    public function isOpen() : bool\n    {\n        return isset($this->startTime) && !isset($this->endTime);\n    }\n    public function setIndependent(bool $independent) : self\n    {\n        $this->independent = $independent;\n        return $this;\n    }\n    public function addAnnotation(string $key, string $value) : self\n    {\n        $this->annotations[$key] = $value;\n        return $this;\n    }\n    public function addMetadata(string $key, mixed $value) : self\n    {\n        $this->metadata[$key] = $value;\n        return $this;\n    }\n    public function getCurrentSegment() : self\n    {\n        for ($max = count($this->subsegments); $this->lastOpenSegment < $max; $this->lastOpenSegment++) {\n            if ($this->subsegments[$this->lastOpenSegment]->isOpen()) {\n                return $this->subsegments[$this->lastOpenSegment]->getCurrentSegment();\n            }\n        }\n        return $this;\n    }\n    \/**\n     * @inheritDoc\n     * @return array<string, mixed>\n     *\/\n    public function jsonSerialize() : array\n    {\n        return array_filter(['id' => $this->id, 'parent_id' => $this->parentId, 'trace_id' => $this->traceId ?? null, 'name' => $this->name, 'start_time' => $this->startTime ?? null, 'end_time' => $this->endTime ?? null, 'subsegments' => $this->subsegments ?? null ?: null, 'type' => $this->independent ? 'subsegment' : null, 'fault' => $this->fault ?? null, 'error' => $this->error ?? null, 'annotations' => $this->annotations ?? null ?: null, 'metadata' => $this->metadata ?? null ?: null]);\n    }\n}","originalFilePath":"\/home\/ranpafin\/php-xray\/src\/Segment.php","originalStartLine":54},"diff":"--- Original\n+++ New\n@@ @@\n             $this->setTraceId($variables['Root']);\n         }\n         if (isset($variables['Sampled'])) {\n-            $this->setSampled((bool) $variables['Sampled'] ?? false);\n+            $this->setSampled(false ?? (bool) $variables['Sampled']);\n         }\n         if (isset($variables['Parent'])) {\n             $this->setParentId($variables['Parent'] ?? null);","processOutput":"PHPUnit 9.5.10 by Sebastian Bergmann and contributors.\n\nRuntime:       PHP 8.0.13\nConfiguration: \/tmp\/tmp-folder\/infection\/phpunitConfiguration.dff964bcc6b8911f9ea611e9baa62b63.infection.xml\n\nF\n\nTime: 00:00.003, Memory: 8.00 MB\n\nThere was 1 failure:\n\n1) Fido\\PHPXray\\TraceTest::testGivenSampledHeaderSetsSampled\nFailed asserting that false is true.\n\n\/home\/ranpafin\/php-xray\/tests\/TraceTest.php:86\n\nFAILURES!\nTests: 1, Assertions: 2, Failures: 1."},{"mutator":{"mutatorName":"MethodCallRemoval","originalSourceCode":"<?php\n\nnamespace Fido\\PHPXray;\n\nuse JsonSerializable;\nuse Fido\\PHPXray\\Submission\\SegmentSubmitter;\nclass Segment implements JsonSerializable\n{\n    protected string $id;\n    protected ?string $parentId = null;\n    protected string $traceId;\n    protected ?string $name = null;\n    protected float $startTime;\n    protected float $endTime;\n    \/** @var Segment[] *\/\n    protected array $subsegments = [];\n    protected bool $error = false;\n    protected bool $fault = false;\n    protected bool $sampled = false;\n    protected bool $independent = false;\n    \/** @var array<string, mixed> *\/\n    private array $annotations;\n    \/** @var array<string, mixed> *\/\n    private array $metadata;\n    private int $lastOpenSegment = 0;\n    \/**\n     * @throws \\Exception if an appropriate source of randomness cannot be found.\n     *\/\n    public function __construct()\n    {\n        $this->id = bin2hex(random_bytes(8));\n    }\n    public function setTraceHeader(string $traceHeader = null) : self\n    {\n        if (is_null($traceHeader)) {\n            return $this;\n        }\n        $parts = explode(';', $traceHeader);\n        $variables = array_map(function ($str) : array {\n            return explode('=', $str);\n        }, $parts);\n        $variables = array_column($variables, 1, 0);\n        if (isset($variables['Root'])) {\n            $this->setTraceId($variables['Root']);\n        }\n        if (isset($variables['Sampled'])) {\n            $this->setSampled((bool) $variables['Sampled'] ?? false);\n        }\n        if (isset($variables['Parent'])) {\n            $this->setParentId($variables['Parent'] ?? null);\n        }\n        return $this;\n    }\n    public function begin() : self\n    {\n        $this->startTime = microtime(true);\n        return $this;\n    }\n    public function end() : self\n    {\n        $this->endTime = microtime(true);\n        return $this;\n    }\n    public function setName(string $name) : self\n    {\n        $this->name = $name;\n        return $this;\n    }\n    public function setError(bool $error) : self\n    {\n        $this->error = $error;\n        return $this;\n    }\n    public function setFault(bool $fault) : self\n    {\n        $this->fault = $fault;\n        return $this;\n    }\n    public function addSubsegment(Segment $subsegment) : self\n    {\n        if (!$this->isOpen()) {\n            return $this;\n        }\n        $this->subsegments[] = $subsegment;\n        $subsegment->setSampled($this->isSampled());\n        return $this;\n    }\n    public function submit(SegmentSubmitter $submitter) : void\n    {\n        if (!$this->isSampled()) {\n            return;\n        }\n        $submitter->submitSegment($this);\n    }\n    public function isSampled() : bool\n    {\n        return $this->sampled;\n    }\n    public function setSampled(bool $sampled) : self\n    {\n        $this->sampled = $sampled;\n        return $this;\n    }\n    public function getId() : string\n    {\n        return $this->id;\n    }\n    public function setParentId(?string $parentId) : self\n    {\n        $this->parentId = $parentId;\n        return $this;\n    }\n    public function setTraceId(string $traceId) : self\n    {\n        $this->traceId = $traceId;\n        return $this;\n    }\n    public function getTraceId() : string\n    {\n        return $this->traceId;\n    }\n    public function isOpen() : bool\n    {\n        return isset($this->startTime) && !isset($this->endTime);\n    }\n    public function setIndependent(bool $independent) : self\n    {\n        $this->independent = $independent;\n        return $this;\n    }\n    public function addAnnotation(string $key, string $value) : self\n    {\n        $this->annotations[$key] = $value;\n        return $this;\n    }\n    public function addMetadata(string $key, mixed $value) : self\n    {\n        $this->metadata[$key] = $value;\n        return $this;\n    }\n    public function getCurrentSegment() : self\n    {\n        for ($max = count($this->subsegments); $this->lastOpenSegment < $max; $this->lastOpenSegment++) {\n            if ($this->subsegments[$this->lastOpenSegment]->isOpen()) {\n                return $this->subsegments[$this->lastOpenSegment]->getCurrentSegment();\n            }\n        }\n        return $this;\n    }\n    \/**\n     * @inheritDoc\n     * @return array<string, mixed>\n     *\/\n    public function jsonSerialize() : array\n    {\n        return array_filter(['id' => $this->id, 'parent_id' => $this->parentId, 'trace_id' => $this->traceId ?? null, 'name' => $this->name, 'start_time' => $this->startTime ?? null, 'end_time' => $this->endTime ?? null, 'subsegments' => $this->subsegments ?? null ?: null, 'type' => $this->independent ? 'subsegment' : null, 'fault' => $this->fault ?? null, 'error' => $this->error ?? null, 'annotations' => $this->annotations ?? null ?: null, 'metadata' => $this->metadata ?? null ?: null]);\n    }\n}","mutatedSourceCode":"<?php\n\nnamespace Fido\\PHPXray;\n\nuse JsonSerializable;\nuse Fido\\PHPXray\\Submission\\SegmentSubmitter;\nclass Segment implements JsonSerializable\n{\n    protected string $id;\n    protected ?string $parentId = null;\n    protected string $traceId;\n    protected ?string $name = null;\n    protected float $startTime;\n    protected float $endTime;\n    \/** @var Segment[] *\/\n    protected array $subsegments = [];\n    protected bool $error = false;\n    protected bool $fault = false;\n    protected bool $sampled = false;\n    protected bool $independent = false;\n    \/** @var array<string, mixed> *\/\n    private array $annotations;\n    \/** @var array<string, mixed> *\/\n    private array $metadata;\n    private int $lastOpenSegment = 0;\n    \/**\n     * @throws \\Exception if an appropriate source of randomness cannot be found.\n     *\/\n    public function __construct()\n    {\n        $this->id = bin2hex(random_bytes(8));\n    }\n    public function setTraceHeader(string $traceHeader = null) : self\n    {\n        if (is_null($traceHeader)) {\n            return $this;\n        }\n        $parts = explode(';', $traceHeader);\n        $variables = array_map(function ($str) : array {\n            return explode('=', $str);\n        }, $parts);\n        $variables = array_column($variables, 1, 0);\n        if (isset($variables['Root'])) {\n            $this->setTraceId($variables['Root']);\n        }\n        if (isset($variables['Sampled'])) {\n            \n        }\n        if (isset($variables['Parent'])) {\n            $this->setParentId($variables['Parent'] ?? null);\n        }\n        return $this;\n    }\n    public function begin() : self\n    {\n        $this->startTime = microtime(true);\n        return $this;\n    }\n    public function end() : self\n    {\n        $this->endTime = microtime(true);\n        return $this;\n    }\n    public function setName(string $name) : self\n    {\n        $this->name = $name;\n        return $this;\n    }\n    public function setError(bool $error) : self\n    {\n        $this->error = $error;\n        return $this;\n    }\n    public function setFault(bool $fault) : self\n    {\n        $this->fault = $fault;\n        return $this;\n    }\n    public function addSubsegment(Segment $subsegment) : self\n    {\n        if (!$this->isOpen()) {\n            return $this;\n        }\n        $this->subsegments[] = $subsegment;\n        $subsegment->setSampled($this->isSampled());\n        return $this;\n    }\n    public function submit(SegmentSubmitter $submitter) : void\n    {\n        if (!$this->isSampled()) {\n            return;\n        }\n        $submitter->submitSegment($this);\n    }\n    public function isSampled() : bool\n    {\n        return $this->sampled;\n    }\n    public function setSampled(bool $sampled) : self\n    {\n        $this->sampled = $sampled;\n        return $this;\n    }\n    public function getId() : string\n    {\n        return $this->id;\n    }\n    public function setParentId(?string $parentId) : self\n    {\n        $this->parentId = $parentId;\n        return $this;\n    }\n    public function setTraceId(string $traceId) : self\n    {\n        $this->traceId = $traceId;\n        return $this;\n    }\n    public function getTraceId() : string\n    {\n        return $this->traceId;\n    }\n    public function isOpen() : bool\n    {\n        return isset($this->startTime) && !isset($this->endTime);\n    }\n    public function setIndependent(bool $independent) : self\n    {\n        $this->independent = $independent;\n        return $this;\n    }\n    public function addAnnotation(string $key, string $value) : self\n    {\n        $this->annotations[$key] = $value;\n        return $this;\n    }\n    public function addMetadata(string $key, mixed $value) : self\n    {\n        $this->metadata[$key] = $value;\n        return $this;\n    }\n    public function getCurrentSegment() : self\n    {\n        for ($max = count($this->subsegments); $this->lastOpenSegment < $max; $this->lastOpenSegment++) {\n            if ($this->subsegments[$this->lastOpenSegment]->isOpen()) {\n                return $this->subsegments[$this->lastOpenSegment]->getCurrentSegment();\n            }\n        }\n        return $this;\n    }\n    \/**\n     * @inheritDoc\n     * @return array<string, mixed>\n     *\/\n    public function jsonSerialize() : array\n    {\n        return array_filter(['id' => $this->id, 'parent_id' => $this->parentId, 'trace_id' => $this->traceId ?? null, 'name' => $this->name, 'start_time' => $this->startTime ?? null, 'end_time' => $this->endTime ?? null, 'subsegments' => $this->subsegments ?? null ?: null, 'type' => $this->independent ? 'subsegment' : null, 'fault' => $this->fault ?? null, 'error' => $this->error ?? null, 'annotations' => $this->annotations ?? null ?: null, 'metadata' => $this->metadata ?? null ?: null]);\n    }\n}","originalFilePath":"\/home\/ranpafin\/php-xray\/src\/Segment.php","originalStartLine":54},"diff":"--- Original\n+++ New\n@@ @@\n             $this->setTraceId($variables['Root']);\n         }\n         if (isset($variables['Sampled'])) {\n-            $this->setSampled((bool) $variables['Sampled'] ?? false);\n+            \n         }\n         if (isset($variables['Parent'])) {\n             $this->setParentId($variables['Parent'] ?? null);","processOutput":"PHPUnit 9.5.10 by Sebastian Bergmann and contributors.\n\nRuntime:       PHP 8.0.13\nConfiguration: \/tmp\/tmp-folder\/infection\/phpunitConfiguration.2eaf3bc6be3375c63a66c45c316eaaf8.infection.xml\n\nF\n\nTime: 00:00.006, Memory: 8.00 MB\n\nThere was 1 failure:\n\n1) Fido\\PHPXray\\TraceTest::testGivenSampledHeaderSetsSampled\nFailed asserting that false is true.\n\n\/home\/ranpafin\/php-xray\/tests\/TraceTest.php:86\n\nFAILURES!\nTests: 1, Assertions: 2, Failures: 1."},{"mutator":{"mutatorName":"MethodCallRemoval","originalSourceCode":"<?php\n\nnamespace Fido\\PHPXray;\n\nuse JsonSerializable;\nuse Fido\\PHPXray\\Submission\\SegmentSubmitter;\nclass Segment implements JsonSerializable\n{\n    protected string $id;\n    protected ?string $parentId = null;\n    protected string $traceId;\n    protected ?string $name = null;\n    protected float $startTime;\n    protected float $endTime;\n    \/** @var Segment[] *\/\n    protected array $subsegments = [];\n    protected bool $error = false;\n    protected bool $fault = false;\n    protected bool $sampled = false;\n    protected bool $independent = false;\n    \/** @var array<string, mixed> *\/\n    private array $annotations;\n    \/** @var array<string, mixed> *\/\n    private array $metadata;\n    private int $lastOpenSegment = 0;\n    \/**\n     * @throws \\Exception if an appropriate source of randomness cannot be found.\n     *\/\n    public function __construct()\n    {\n        $this->id = bin2hex(random_bytes(8));\n    }\n    public function setTraceHeader(string $traceHeader = null) : self\n    {\n        if (is_null($traceHeader)) {\n            return $this;\n        }\n        $parts = explode(';', $traceHeader);\n        $variables = array_map(function ($str) : array {\n            return explode('=', $str);\n        }, $parts);\n        $variables = array_column($variables, 1, 0);\n        if (isset($variables['Root'])) {\n            $this->setTraceId($variables['Root']);\n        }\n        if (isset($variables['Sampled'])) {\n            $this->setSampled((bool) $variables['Sampled'] ?? false);\n        }\n        if (isset($variables['Parent'])) {\n            $this->setParentId($variables['Parent'] ?? null);\n        }\n        return $this;\n    }\n    public function begin() : self\n    {\n        $this->startTime = microtime(true);\n        return $this;\n    }\n    public function end() : self\n    {\n        $this->endTime = microtime(true);\n        return $this;\n    }\n    public function setName(string $name) : self\n    {\n        $this->name = $name;\n        return $this;\n    }\n    public function setError(bool $error) : self\n    {\n        $this->error = $error;\n        return $this;\n    }\n    public function setFault(bool $fault) : self\n    {\n        $this->fault = $fault;\n        return $this;\n    }\n    public function addSubsegment(Segment $subsegment) : self\n    {\n        if (!$this->isOpen()) {\n            return $this;\n        }\n        $this->subsegments[] = $subsegment;\n        $subsegment->setSampled($this->isSampled());\n        return $this;\n    }\n    public function submit(SegmentSubmitter $submitter) : void\n    {\n        if (!$this->isSampled()) {\n            return;\n        }\n        $submitter->submitSegment($this);\n    }\n    public function isSampled() : bool\n    {\n        return $this->sampled;\n    }\n    public function setSampled(bool $sampled) : self\n    {\n        $this->sampled = $sampled;\n        return $this;\n    }\n    public function getId() : string\n    {\n        return $this->id;\n    }\n    public function setParentId(?string $parentId) : self\n    {\n        $this->parentId = $parentId;\n        return $this;\n    }\n    public function setTraceId(string $traceId) : self\n    {\n        $this->traceId = $traceId;\n        return $this;\n    }\n    public function getTraceId() : string\n    {\n        return $this->traceId;\n    }\n    public function isOpen() : bool\n    {\n        return isset($this->startTime) && !isset($this->endTime);\n    }\n    public function setIndependent(bool $independent) : self\n    {\n        $this->independent = $independent;\n        return $this;\n    }\n    public function addAnnotation(string $key, string $value) : self\n    {\n        $this->annotations[$key] = $value;\n        return $this;\n    }\n    public function addMetadata(string $key, mixed $value) : self\n    {\n        $this->metadata[$key] = $value;\n        return $this;\n    }\n    public function getCurrentSegment() : self\n    {\n        for ($max = count($this->subsegments); $this->lastOpenSegment < $max; $this->lastOpenSegment++) {\n            if ($this->subsegments[$this->lastOpenSegment]->isOpen()) {\n                return $this->subsegments[$this->lastOpenSegment]->getCurrentSegment();\n            }\n        }\n        return $this;\n    }\n    \/**\n     * @inheritDoc\n     * @return array<string, mixed>\n     *\/\n    public function jsonSerialize() : array\n    {\n        return array_filter(['id' => $this->id, 'parent_id' => $this->parentId, 'trace_id' => $this->traceId ?? null, 'name' => $this->name, 'start_time' => $this->startTime ?? null, 'end_time' => $this->endTime ?? null, 'subsegments' => $this->subsegments ?? null ?: null, 'type' => $this->independent ? 'subsegment' : null, 'fault' => $this->fault ?? null, 'error' => $this->error ?? null, 'annotations' => $this->annotations ?? null ?: null, 'metadata' => $this->metadata ?? null ?: null]);\n    }\n}","mutatedSourceCode":"<?php\n\nnamespace Fido\\PHPXray;\n\nuse JsonSerializable;\nuse Fido\\PHPXray\\Submission\\SegmentSubmitter;\nclass Segment implements JsonSerializable\n{\n    protected string $id;\n    protected ?string $parentId = null;\n    protected string $traceId;\n    protected ?string $name = null;\n    protected float $startTime;\n    protected float $endTime;\n    \/** @var Segment[] *\/\n    protected array $subsegments = [];\n    protected bool $error = false;\n    protected bool $fault = false;\n    protected bool $sampled = false;\n    protected bool $independent = false;\n    \/** @var array<string, mixed> *\/\n    private array $annotations;\n    \/** @var array<string, mixed> *\/\n    private array $metadata;\n    private int $lastOpenSegment = 0;\n    \/**\n     * @throws \\Exception if an appropriate source of randomness cannot be found.\n     *\/\n    public function __construct()\n    {\n        $this->id = bin2hex(random_bytes(8));\n    }\n    public function setTraceHeader(string $traceHeader = null) : self\n    {\n        if (is_null($traceHeader)) {\n            return $this;\n        }\n        $parts = explode(';', $traceHeader);\n        $variables = array_map(function ($str) : array {\n            return explode('=', $str);\n        }, $parts);\n        $variables = array_column($variables, 1, 0);\n        if (isset($variables['Root'])) {\n            $this->setTraceId($variables['Root']);\n        }\n        if (isset($variables['Sampled'])) {\n            $this->setSampled((bool) $variables['Sampled'] ?? false);\n        }\n        if (isset($variables['Parent'])) {\n            \n        }\n        return $this;\n    }\n    public function begin() : self\n    {\n        $this->startTime = microtime(true);\n        return $this;\n    }\n    public function end() : self\n    {\n        $this->endTime = microtime(true);\n        return $this;\n    }\n    public function setName(string $name) : self\n    {\n        $this->name = $name;\n        return $this;\n    }\n    public function setError(bool $error) : self\n    {\n        $this->error = $error;\n        return $this;\n    }\n    public function setFault(bool $fault) : self\n    {\n        $this->fault = $fault;\n        return $this;\n    }\n    public function addSubsegment(Segment $subsegment) : self\n    {\n        if (!$this->isOpen()) {\n            return $this;\n        }\n        $this->subsegments[] = $subsegment;\n        $subsegment->setSampled($this->isSampled());\n        return $this;\n    }\n    public function submit(SegmentSubmitter $submitter) : void\n    {\n        if (!$this->isSampled()) {\n            return;\n        }\n        $submitter->submitSegment($this);\n    }\n    public function isSampled() : bool\n    {\n        return $this->sampled;\n    }\n    public function setSampled(bool $sampled) : self\n    {\n        $this->sampled = $sampled;\n        return $this;\n    }\n    public function getId() : string\n    {\n        return $this->id;\n    }\n    public function setParentId(?string $parentId) : self\n    {\n        $this->parentId = $parentId;\n        return $this;\n    }\n    public function setTraceId(string $traceId) : self\n    {\n        $this->traceId = $traceId;\n        return $this;\n    }\n    public function getTraceId() : string\n    {\n        return $this->traceId;\n    }\n    public function isOpen() : bool\n    {\n        return isset($this->startTime) && !isset($this->endTime);\n    }\n    public function setIndependent(bool $independent) : self\n    {\n        $this->independent = $independent;\n        return $this;\n    }\n    public function addAnnotation(string $key, string $value) : self\n    {\n        $this->annotations[$key] = $value;\n        return $this;\n    }\n    public function addMetadata(string $key, mixed $value) : self\n    {\n        $this->metadata[$key] = $value;\n        return $this;\n    }\n    public function getCurrentSegment() : self\n    {\n        for ($max = count($this->subsegments); $this->lastOpenSegment < $max; $this->lastOpenSegment++) {\n            if ($this->subsegments[$this->lastOpenSegment]->isOpen()) {\n                return $this->subsegments[$this->lastOpenSegment]->getCurrentSegment();\n            }\n        }\n        return $this;\n    }\n    \/**\n     * @inheritDoc\n     * @return array<string, mixed>\n     *\/\n    public function jsonSerialize() : array\n    {\n        return array_filter(['id' => $this->id, 'parent_id' => $this->parentId, 'trace_id' => $this->traceId ?? null, 'name' => $this->name, 'start_time' => $this->startTime ?? null, 'end_time' => $this->endTime ?? null, 'subsegments' => $this->subsegments ?? null ?: null, 'type' => $this->independent ? 'subsegment' : null, 'fault' => $this->fault ?? null, 'error' => $this->error ?? null, 'annotations' => $this->annotations ?? null ?: null, 'metadata' => $this->metadata ?? null ?: null]);\n    }\n}","originalFilePath":"\/home\/ranpafin\/php-xray\/src\/Segment.php","originalStartLine":57},"diff":"--- Original\n+++ New\n@@ @@\n             $this->setSampled((bool) $variables['Sampled'] ?? false);\n         }\n         if (isset($variables['Parent'])) {\n-            $this->setParentId($variables['Parent'] ?? null);\n+            \n         }\n         return $this;\n     }","processOutput":"PHPUnit 9.5.10 by Sebastian Bergmann and contributors.\n\nRuntime:       PHP 8.0.13\nConfiguration: \/tmp\/tmp-folder\/infection\/phpunitConfiguration.af4f0074877eb799746e2a10526cfa2d.infection.xml\n\nE\n\nTime: 00:00.005, Memory: 8.00 MB\n\nThere was 1 error:\n\n1) Fido\\PHPXray\\TraceTest::testGivenParentHeaderSetsParentId\nUndefined array key \"parent_id\"\n\n\/home\/ranpafin\/php-xray\/tests\/TraceTest.php:100\n\nERRORS!\nTests: 1, Assertions: 2, Errors: 1."},{"mutator":{"mutatorName":"PublicVisibility","originalSourceCode":"<?php\n\nnamespace Fido\\PHPXray;\n\nuse JsonSerializable;\nuse Fido\\PHPXray\\Submission\\SegmentSubmitter;\nclass Segment implements JsonSerializable\n{\n    protected string $id;\n    protected ?string $parentId = null;\n    protected string $traceId;\n    protected ?string $name = null;\n    protected float $startTime;\n    protected float $endTime;\n    \/** @var Segment[] *\/\n    protected array $subsegments = [];\n    protected bool $error = false;\n    protected bool $fault = false;\n    protected bool $sampled = false;\n    protected bool $independent = false;\n    \/** @var array<string, mixed> *\/\n    private array $annotations;\n    \/** @var array<string, mixed> *\/\n    private array $metadata;\n    private int $lastOpenSegment = 0;\n    \/**\n     * @throws \\Exception if an appropriate source of randomness cannot be found.\n     *\/\n    public function __construct()\n    {\n        $this->id = bin2hex(random_bytes(8));\n    }\n    public function setTraceHeader(string $traceHeader = null) : self\n    {\n        if (is_null($traceHeader)) {\n            return $this;\n        }\n        $parts = explode(';', $traceHeader);\n        $variables = array_map(function ($str) : array {\n            return explode('=', $str);\n        }, $parts);\n        $variables = array_column($variables, 1, 0);\n        if (isset($variables['Root'])) {\n            $this->setTraceId($variables['Root']);\n        }\n        if (isset($variables['Sampled'])) {\n            $this->setSampled((bool) $variables['Sampled'] ?? false);\n        }\n        if (isset($variables['Parent'])) {\n            $this->setParentId($variables['Parent'] ?? null);\n        }\n        return $this;\n    }\n    public function begin() : self\n    {\n        $this->startTime = microtime(true);\n        return $this;\n    }\n    public function end() : self\n    {\n        $this->endTime = microtime(true);\n        return $this;\n    }\n    public function setName(string $name) : self\n    {\n        $this->name = $name;\n        return $this;\n    }\n    public function setError(bool $error) : self\n    {\n        $this->error = $error;\n        return $this;\n    }\n    public function setFault(bool $fault) : self\n    {\n        $this->fault = $fault;\n        return $this;\n    }\n    public function addSubsegment(Segment $subsegment) : self\n    {\n        if (!$this->isOpen()) {\n            return $this;\n        }\n        $this->subsegments[] = $subsegment;\n        $subsegment->setSampled($this->isSampled());\n        return $this;\n    }\n    public function submit(SegmentSubmitter $submitter) : void\n    {\n        if (!$this->isSampled()) {\n            return;\n        }\n        $submitter->submitSegment($this);\n    }\n    public function isSampled() : bool\n    {\n        return $this->sampled;\n    }\n    public function setSampled(bool $sampled) : self\n    {\n        $this->sampled = $sampled;\n        return $this;\n    }\n    public function getId() : string\n    {\n        return $this->id;\n    }\n    public function setParentId(?string $parentId) : self\n    {\n        $this->parentId = $parentId;\n        return $this;\n    }\n    public function setTraceId(string $traceId) : self\n    {\n        $this->traceId = $traceId;\n        return $this;\n    }\n    public function getTraceId() : string\n    {\n        return $this->traceId;\n    }\n    public function isOpen() : bool\n    {\n        return isset($this->startTime) && !isset($this->endTime);\n    }\n    public function setIndependent(bool $independent) : self\n    {\n        $this->independent = $independent;\n        return $this;\n    }\n    public function addAnnotation(string $key, string $value) : self\n    {\n        $this->annotations[$key] = $value;\n        return $this;\n    }\n    public function addMetadata(string $key, mixed $value) : self\n    {\n        $this->metadata[$key] = $value;\n        return $this;\n    }\n    public function getCurrentSegment() : self\n    {\n        for ($max = count($this->subsegments); $this->lastOpenSegment < $max; $this->lastOpenSegment++) {\n            if ($this->subsegments[$this->lastOpenSegment]->isOpen()) {\n                return $this->subsegments[$this->lastOpenSegment]->getCurrentSegment();\n            }\n        }\n        return $this;\n    }\n    \/**\n     * @inheritDoc\n     * @return array<string, mixed>\n     *\/\n    public function jsonSerialize() : array\n    {\n        return array_filter(['id' => $this->id, 'parent_id' => $this->parentId, 'trace_id' => $this->traceId ?? null, 'name' => $this->name, 'start_time' => $this->startTime ?? null, 'end_time' => $this->endTime ?? null, 'subsegments' => $this->subsegments ?? null ?: null, 'type' => $this->independent ? 'subsegment' : null, 'fault' => $this->fault ?? null, 'error' => $this->error ?? null, 'annotations' => $this->annotations ?? null ?: null, 'metadata' => $this->metadata ?? null ?: null]);\n    }\n}","mutatedSourceCode":"<?php\n\nnamespace Fido\\PHPXray;\n\nuse JsonSerializable;\nuse Fido\\PHPXray\\Submission\\SegmentSubmitter;\nclass Segment implements JsonSerializable\n{\n    protected string $id;\n    protected ?string $parentId = null;\n    protected string $traceId;\n    protected ?string $name = null;\n    protected float $startTime;\n    protected float $endTime;\n    \/** @var Segment[] *\/\n    protected array $subsegments = [];\n    protected bool $error = false;\n    protected bool $fault = false;\n    protected bool $sampled = false;\n    protected bool $independent = false;\n    \/** @var array<string, mixed> *\/\n    private array $annotations;\n    \/** @var array<string, mixed> *\/\n    private array $metadata;\n    private int $lastOpenSegment = 0;\n    \/**\n     * @throws \\Exception if an appropriate source of randomness cannot be found.\n     *\/\n    public function __construct()\n    {\n        $this->id = bin2hex(random_bytes(8));\n    }\n    public function setTraceHeader(string $traceHeader = null) : self\n    {\n        if (is_null($traceHeader)) {\n            return $this;\n        }\n        $parts = explode(';', $traceHeader);\n        $variables = array_map(function ($str) : array {\n            return explode('=', $str);\n        }, $parts);\n        $variables = array_column($variables, 1, 0);\n        if (isset($variables['Root'])) {\n            $this->setTraceId($variables['Root']);\n        }\n        if (isset($variables['Sampled'])) {\n            $this->setSampled((bool) $variables['Sampled'] ?? false);\n        }\n        if (isset($variables['Parent'])) {\n            $this->setParentId($variables['Parent'] ?? null);\n        }\n        return $this;\n    }\n    protected function begin() : self\n    {\n        $this->startTime = microtime(true);\n        return $this;\n    }\n    public function end() : self\n    {\n        $this->endTime = microtime(true);\n        return $this;\n    }\n    public function setName(string $name) : self\n    {\n        $this->name = $name;\n        return $this;\n    }\n    public function setError(bool $error) : self\n    {\n        $this->error = $error;\n        return $this;\n    }\n    public function setFault(bool $fault) : self\n    {\n        $this->fault = $fault;\n        return $this;\n    }\n    public function addSubsegment(Segment $subsegment) : self\n    {\n        if (!$this->isOpen()) {\n            return $this;\n        }\n        $this->subsegments[] = $subsegment;\n        $subsegment->setSampled($this->isSampled());\n        return $this;\n    }\n    public function submit(SegmentSubmitter $submitter) : void\n    {\n        if (!$this->isSampled()) {\n            return;\n        }\n        $submitter->submitSegment($this);\n    }\n    public function isSampled() : bool\n    {\n        return $this->sampled;\n    }\n    public function setSampled(bool $sampled) : self\n    {\n        $this->sampled = $sampled;\n        return $this;\n    }\n    public function getId() : string\n    {\n        return $this->id;\n    }\n    public function setParentId(?string $parentId) : self\n    {\n        $this->parentId = $parentId;\n        return $this;\n    }\n    public function setTraceId(string $traceId) : self\n    {\n        $this->traceId = $traceId;\n        return $this;\n    }\n    public function getTraceId() : string\n    {\n        return $this->traceId;\n    }\n    public function isOpen() : bool\n    {\n        return isset($this->startTime) && !isset($this->endTime);\n    }\n    public function setIndependent(bool $independent) : self\n    {\n        $this->independent = $independent;\n        return $this;\n    }\n    public function addAnnotation(string $key, string $value) : self\n    {\n        $this->annotations[$key] = $value;\n        return $this;\n    }\n    public function addMetadata(string $key, mixed $value) : self\n    {\n        $this->metadata[$key] = $value;\n        return $this;\n    }\n    public function getCurrentSegment() : self\n    {\n        for ($max = count($this->subsegments); $this->lastOpenSegment < $max; $this->lastOpenSegment++) {\n            if ($this->subsegments[$this->lastOpenSegment]->isOpen()) {\n                return $this->subsegments[$this->lastOpenSegment]->getCurrentSegment();\n            }\n        }\n        return $this;\n    }\n    \/**\n     * @inheritDoc\n     * @return array<string, mixed>\n     *\/\n    public function jsonSerialize() : array\n    {\n        return array_filter(['id' => $this->id, 'parent_id' => $this->parentId, 'trace_id' => $this->traceId ?? null, 'name' => $this->name, 'start_time' => $this->startTime ?? null, 'end_time' => $this->endTime ?? null, 'subsegments' => $this->subsegments ?? null ?: null, 'type' => $this->independent ? 'subsegment' : null, 'fault' => $this->fault ?? null, 'error' => $this->error ?? null, 'annotations' => $this->annotations ?? null ?: null, 'metadata' => $this->metadata ?? null ?: null]);\n    }\n}","originalFilePath":"\/home\/ranpafin\/php-xray\/src\/Segment.php","originalStartLine":63},"diff":"--- Original\n+++ New\n@@ @@\n         }\n         return $this;\n     }\n-    public function begin() : self\n+    protected function begin() : self\n     {\n         $this->startTime = microtime(true);\n         return $this;","processOutput":"PHPUnit 9.5.10 by Sebastian Bergmann and contributors.\n\nRuntime:       PHP 8.0.13\nConfiguration: \/tmp\/tmp-folder\/infection\/phpunitConfiguration.4cfa40dc696f54de1e4a12ff101d37eb.infection.xml\n\nE\n\nTime: 00:00.004, Memory: 8.00 MB\n\nThere was 1 error:\n\n1) Fido\\PHPXray\\DaemonSegmentSubmitterTest::testSubmitsToDaemon\nsocket_bind(): Unable to bind address [98]: Address already in use\n\n\/home\/ranpafin\/php-xray\/tests\/DaemonSegmentSubmitterTest.php:18\n\nERRORS!\nTests: 1, Assertions: 0, Errors: 1."},{"mutator":{"mutatorName":"PublicVisibility","originalSourceCode":"<?php\n\nnamespace Fido\\PHPXray;\n\nuse JsonSerializable;\nuse Fido\\PHPXray\\Submission\\SegmentSubmitter;\nclass Segment implements JsonSerializable\n{\n    protected string $id;\n    protected ?string $parentId = null;\n    protected string $traceId;\n    protected ?string $name = null;\n    protected float $startTime;\n    protected float $endTime;\n    \/** @var Segment[] *\/\n    protected array $subsegments = [];\n    protected bool $error = false;\n    protected bool $fault = false;\n    protected bool $sampled = false;\n    protected bool $independent = false;\n    \/** @var array<string, mixed> *\/\n    private array $annotations;\n    \/** @var array<string, mixed> *\/\n    private array $metadata;\n    private int $lastOpenSegment = 0;\n    \/**\n     * @throws \\Exception if an appropriate source of randomness cannot be found.\n     *\/\n    public function __construct()\n    {\n        $this->id = bin2hex(random_bytes(8));\n    }\n    public function setTraceHeader(string $traceHeader = null) : self\n    {\n        if (is_null($traceHeader)) {\n            return $this;\n        }\n        $parts = explode(';', $traceHeader);\n        $variables = array_map(function ($str) : array {\n            return explode('=', $str);\n        }, $parts);\n        $variables = array_column($variables, 1, 0);\n        if (isset($variables['Root'])) {\n            $this->setTraceId($variables['Root']);\n        }\n        if (isset($variables['Sampled'])) {\n            $this->setSampled((bool) $variables['Sampled'] ?? false);\n        }\n        if (isset($variables['Parent'])) {\n            $this->setParentId($variables['Parent'] ?? null);\n        }\n        return $this;\n    }\n    public function begin() : self\n    {\n        $this->startTime = microtime(true);\n        return $this;\n    }\n    public function end() : self\n    {\n        $this->endTime = microtime(true);\n        return $this;\n    }\n    public function setName(string $name) : self\n    {\n        $this->name = $name;\n        return $this;\n    }\n    public function setError(bool $error) : self\n    {\n        $this->error = $error;\n        return $this;\n    }\n    public function setFault(bool $fault) : self\n    {\n        $this->fault = $fault;\n        return $this;\n    }\n    public function addSubsegment(Segment $subsegment) : self\n    {\n        if (!$this->isOpen()) {\n            return $this;\n        }\n        $this->subsegments[] = $subsegment;\n        $subsegment->setSampled($this->isSampled());\n        return $this;\n    }\n    public function submit(SegmentSubmitter $submitter) : void\n    {\n        if (!$this->isSampled()) {\n            return;\n        }\n        $submitter->submitSegment($this);\n    }\n    public function isSampled() : bool\n    {\n        return $this->sampled;\n    }\n    public function setSampled(bool $sampled) : self\n    {\n        $this->sampled = $sampled;\n        return $this;\n    }\n    public function getId() : string\n    {\n        return $this->id;\n    }\n    public function setParentId(?string $parentId) : self\n    {\n        $this->parentId = $parentId;\n        return $this;\n    }\n    public function setTraceId(string $traceId) : self\n    {\n        $this->traceId = $traceId;\n        return $this;\n    }\n    public function getTraceId() : string\n    {\n        return $this->traceId;\n    }\n    public function isOpen() : bool\n    {\n        return isset($this->startTime) && !isset($this->endTime);\n    }\n    public function setIndependent(bool $independent) : self\n    {\n        $this->independent = $independent;\n        return $this;\n    }\n    public function addAnnotation(string $key, string $value) : self\n    {\n        $this->annotations[$key] = $value;\n        return $this;\n    }\n    public function addMetadata(string $key, mixed $value) : self\n    {\n        $this->metadata[$key] = $value;\n        return $this;\n    }\n    public function getCurrentSegment() : self\n    {\n        for ($max = count($this->subsegments); $this->lastOpenSegment < $max; $this->lastOpenSegment++) {\n            if ($this->subsegments[$this->lastOpenSegment]->isOpen()) {\n                return $this->subsegments[$this->lastOpenSegment]->getCurrentSegment();\n            }\n        }\n        return $this;\n    }\n    \/**\n     * @inheritDoc\n     * @return array<string, mixed>\n     *\/\n    public function jsonSerialize() : array\n    {\n        return array_filter(['id' => $this->id, 'parent_id' => $this->parentId, 'trace_id' => $this->traceId ?? null, 'name' => $this->name, 'start_time' => $this->startTime ?? null, 'end_time' => $this->endTime ?? null, 'subsegments' => $this->subsegments ?? null ?: null, 'type' => $this->independent ? 'subsegment' : null, 'fault' => $this->fault ?? null, 'error' => $this->error ?? null, 'annotations' => $this->annotations ?? null ?: null, 'metadata' => $this->metadata ?? null ?: null]);\n    }\n}","mutatedSourceCode":"<?php\n\nnamespace Fido\\PHPXray;\n\nuse JsonSerializable;\nuse Fido\\PHPXray\\Submission\\SegmentSubmitter;\nclass Segment implements JsonSerializable\n{\n    protected string $id;\n    protected ?string $parentId = null;\n    protected string $traceId;\n    protected ?string $name = null;\n    protected float $startTime;\n    protected float $endTime;\n    \/** @var Segment[] *\/\n    protected array $subsegments = [];\n    protected bool $error = false;\n    protected bool $fault = false;\n    protected bool $sampled = false;\n    protected bool $independent = false;\n    \/** @var array<string, mixed> *\/\n    private array $annotations;\n    \/** @var array<string, mixed> *\/\n    private array $metadata;\n    private int $lastOpenSegment = 0;\n    \/**\n     * @throws \\Exception if an appropriate source of randomness cannot be found.\n     *\/\n    public function __construct()\n    {\n        $this->id = bin2hex(random_bytes(8));\n    }\n    public function setTraceHeader(string $traceHeader = null) : self\n    {\n        if (is_null($traceHeader)) {\n            return $this;\n        }\n        $parts = explode(';', $traceHeader);\n        $variables = array_map(function ($str) : array {\n            return explode('=', $str);\n        }, $parts);\n        $variables = array_column($variables, 1, 0);\n        if (isset($variables['Root'])) {\n            $this->setTraceId($variables['Root']);\n        }\n        if (isset($variables['Sampled'])) {\n            $this->setSampled((bool) $variables['Sampled'] ?? false);\n        }\n        if (isset($variables['Parent'])) {\n            $this->setParentId($variables['Parent'] ?? null);\n        }\n        return $this;\n    }\n    public function begin() : self\n    {\n        $this->startTime = microtime(true);\n        return $this;\n    }\n    protected function end() : self\n    {\n        $this->endTime = microtime(true);\n        return $this;\n    }\n    public function setName(string $name) : self\n    {\n        $this->name = $name;\n        return $this;\n    }\n    public function setError(bool $error) : self\n    {\n        $this->error = $error;\n        return $this;\n    }\n    public function setFault(bool $fault) : self\n    {\n        $this->fault = $fault;\n        return $this;\n    }\n    public function addSubsegment(Segment $subsegment) : self\n    {\n        if (!$this->isOpen()) {\n            return $this;\n        }\n        $this->subsegments[] = $subsegment;\n        $subsegment->setSampled($this->isSampled());\n        return $this;\n    }\n    public function submit(SegmentSubmitter $submitter) : void\n    {\n        if (!$this->isSampled()) {\n            return;\n        }\n        $submitter->submitSegment($this);\n    }\n    public function isSampled() : bool\n    {\n        return $this->sampled;\n    }\n    public function setSampled(bool $sampled) : self\n    {\n        $this->sampled = $sampled;\n        return $this;\n    }\n    public function getId() : string\n    {\n        return $this->id;\n    }\n    public function setParentId(?string $parentId) : self\n    {\n        $this->parentId = $parentId;\n        return $this;\n    }\n    public function setTraceId(string $traceId) : self\n    {\n        $this->traceId = $traceId;\n        return $this;\n    }\n    public function getTraceId() : string\n    {\n        return $this->traceId;\n    }\n    public function isOpen() : bool\n    {\n        return isset($this->startTime) && !isset($this->endTime);\n    }\n    public function setIndependent(bool $independent) : self\n    {\n        $this->independent = $independent;\n        return $this;\n    }\n    public function addAnnotation(string $key, string $value) : self\n    {\n        $this->annotations[$key] = $value;\n        return $this;\n    }\n    public function addMetadata(string $key, mixed $value) : self\n    {\n        $this->metadata[$key] = $value;\n        return $this;\n    }\n    public function getCurrentSegment() : self\n    {\n        for ($max = count($this->subsegments); $this->lastOpenSegment < $max; $this->lastOpenSegment++) {\n            if ($this->subsegments[$this->lastOpenSegment]->isOpen()) {\n                return $this->subsegments[$this->lastOpenSegment]->getCurrentSegment();\n            }\n        }\n        return $this;\n    }\n    \/**\n     * @inheritDoc\n     * @return array<string, mixed>\n     *\/\n    public function jsonSerialize() : array\n    {\n        return array_filter(['id' => $this->id, 'parent_id' => $this->parentId, 'trace_id' => $this->traceId ?? null, 'name' => $this->name, 'start_time' => $this->startTime ?? null, 'end_time' => $this->endTime ?? null, 'subsegments' => $this->subsegments ?? null ?: null, 'type' => $this->independent ? 'subsegment' : null, 'fault' => $this->fault ?? null, 'error' => $this->error ?? null, 'annotations' => $this->annotations ?? null ?: null, 'metadata' => $this->metadata ?? null ?: null]);\n    }\n}","originalFilePath":"\/home\/ranpafin\/php-xray\/src\/Segment.php","originalStartLine":70},"diff":"--- Original\n+++ New\n@@ @@\n         $this->startTime = microtime(true);\n         return $this;\n     }\n-    public function end() : self\n+    protected function end() : self\n     {\n         $this->endTime = microtime(true);\n         return $this;","processOutput":"PHPUnit 9.5.10 by Sebastian Bergmann and contributors.\n\nRuntime:       PHP 8.0.13\nConfiguration: \/tmp\/tmp-folder\/infection\/phpunitConfiguration.d43f207062f0b0bee86a25487f59935c.infection.xml\n\nE\n\nTime: 00:00.002, Memory: 8.00 MB\n\nThere was 1 error:\n\n1) Fido\\PHPXray\\DaemonSegmentSubmitterTest::testSubmitsToDaemon\nsocket_bind(): Unable to bind address [98]: Address already in use\n\n\/home\/ranpafin\/php-xray\/tests\/DaemonSegmentSubmitterTest.php:18\n\nERRORS!\nTests: 1, Assertions: 0, Errors: 1."},{"mutator":{"mutatorName":"PublicVisibility","originalSourceCode":"<?php\n\nnamespace Fido\\PHPXray;\n\nuse JsonSerializable;\nuse Fido\\PHPXray\\Submission\\SegmentSubmitter;\nclass Segment implements JsonSerializable\n{\n    protected string $id;\n    protected ?string $parentId = null;\n    protected string $traceId;\n    protected ?string $name = null;\n    protected float $startTime;\n    protected float $endTime;\n    \/** @var Segment[] *\/\n    protected array $subsegments = [];\n    protected bool $error = false;\n    protected bool $fault = false;\n    protected bool $sampled = false;\n    protected bool $independent = false;\n    \/** @var array<string, mixed> *\/\n    private array $annotations;\n    \/** @var array<string, mixed> *\/\n    private array $metadata;\n    private int $lastOpenSegment = 0;\n    \/**\n     * @throws \\Exception if an appropriate source of randomness cannot be found.\n     *\/\n    public function __construct()\n    {\n        $this->id = bin2hex(random_bytes(8));\n    }\n    public function setTraceHeader(string $traceHeader = null) : self\n    {\n        if (is_null($traceHeader)) {\n            return $this;\n        }\n        $parts = explode(';', $traceHeader);\n        $variables = array_map(function ($str) : array {\n            return explode('=', $str);\n        }, $parts);\n        $variables = array_column($variables, 1, 0);\n        if (isset($variables['Root'])) {\n            $this->setTraceId($variables['Root']);\n        }\n        if (isset($variables['Sampled'])) {\n            $this->setSampled((bool) $variables['Sampled'] ?? false);\n        }\n        if (isset($variables['Parent'])) {\n            $this->setParentId($variables['Parent'] ?? null);\n        }\n        return $this;\n    }\n    public function begin() : self\n    {\n        $this->startTime = microtime(true);\n        return $this;\n    }\n    public function end() : self\n    {\n        $this->endTime = microtime(true);\n        return $this;\n    }\n    public function setName(string $name) : self\n    {\n        $this->name = $name;\n        return $this;\n    }\n    public function setError(bool $error) : self\n    {\n        $this->error = $error;\n        return $this;\n    }\n    public function setFault(bool $fault) : self\n    {\n        $this->fault = $fault;\n        return $this;\n    }\n    public function addSubsegment(Segment $subsegment) : self\n    {\n        if (!$this->isOpen()) {\n            return $this;\n        }\n        $this->subsegments[] = $subsegment;\n        $subsegment->setSampled($this->isSampled());\n        return $this;\n    }\n    public function submit(SegmentSubmitter $submitter) : void\n    {\n        if (!$this->isSampled()) {\n            return;\n        }\n        $submitter->submitSegment($this);\n    }\n    public function isSampled() : bool\n    {\n        return $this->sampled;\n    }\n    public function setSampled(bool $sampled) : self\n    {\n        $this->sampled = $sampled;\n        return $this;\n    }\n    public function getId() : string\n    {\n        return $this->id;\n    }\n    public function setParentId(?string $parentId) : self\n    {\n        $this->parentId = $parentId;\n        return $this;\n    }\n    public function setTraceId(string $traceId) : self\n    {\n        $this->traceId = $traceId;\n        return $this;\n    }\n    public function getTraceId() : string\n    {\n        return $this->traceId;\n    }\n    public function isOpen() : bool\n    {\n        return isset($this->startTime) && !isset($this->endTime);\n    }\n    public function setIndependent(bool $independent) : self\n    {\n        $this->independent = $independent;\n        return $this;\n    }\n    public function addAnnotation(string $key, string $value) : self\n    {\n        $this->annotations[$key] = $value;\n        return $this;\n    }\n    public function addMetadata(string $key, mixed $value) : self\n    {\n        $this->metadata[$key] = $value;\n        return $this;\n    }\n    public function getCurrentSegment() : self\n    {\n        for ($max = count($this->subsegments); $this->lastOpenSegment < $max; $this->lastOpenSegment++) {\n            if ($this->subsegments[$this->lastOpenSegment]->isOpen()) {\n                return $this->subsegments[$this->lastOpenSegment]->getCurrentSegment();\n            }\n        }\n        return $this;\n    }\n    \/**\n     * @inheritDoc\n     * @return array<string, mixed>\n     *\/\n    public function jsonSerialize() : array\n    {\n        return array_filter(['id' => $this->id, 'parent_id' => $this->parentId, 'trace_id' => $this->traceId ?? null, 'name' => $this->name, 'start_time' => $this->startTime ?? null, 'end_time' => $this->endTime ?? null, 'subsegments' => $this->subsegments ?? null ?: null, 'type' => $this->independent ? 'subsegment' : null, 'fault' => $this->fault ?? null, 'error' => $this->error ?? null, 'annotations' => $this->annotations ?? null ?: null, 'metadata' => $this->metadata ?? null ?: null]);\n    }\n}","mutatedSourceCode":"<?php\n\nnamespace Fido\\PHPXray;\n\nuse JsonSerializable;\nuse Fido\\PHPXray\\Submission\\SegmentSubmitter;\nclass Segment implements JsonSerializable\n{\n    protected string $id;\n    protected ?string $parentId = null;\n    protected string $traceId;\n    protected ?string $name = null;\n    protected float $startTime;\n    protected float $endTime;\n    \/** @var Segment[] *\/\n    protected array $subsegments = [];\n    protected bool $error = false;\n    protected bool $fault = false;\n    protected bool $sampled = false;\n    protected bool $independent = false;\n    \/** @var array<string, mixed> *\/\n    private array $annotations;\n    \/** @var array<string, mixed> *\/\n    private array $metadata;\n    private int $lastOpenSegment = 0;\n    \/**\n     * @throws \\Exception if an appropriate source of randomness cannot be found.\n     *\/\n    public function __construct()\n    {\n        $this->id = bin2hex(random_bytes(8));\n    }\n    public function setTraceHeader(string $traceHeader = null) : self\n    {\n        if (is_null($traceHeader)) {\n            return $this;\n        }\n        $parts = explode(';', $traceHeader);\n        $variables = array_map(function ($str) : array {\n            return explode('=', $str);\n        }, $parts);\n        $variables = array_column($variables, 1, 0);\n        if (isset($variables['Root'])) {\n            $this->setTraceId($variables['Root']);\n        }\n        if (isset($variables['Sampled'])) {\n            $this->setSampled((bool) $variables['Sampled'] ?? false);\n        }\n        if (isset($variables['Parent'])) {\n            $this->setParentId($variables['Parent'] ?? null);\n        }\n        return $this;\n    }\n    public function begin() : self\n    {\n        $this->startTime = microtime(true);\n        return $this;\n    }\n    public function end() : self\n    {\n        $this->endTime = microtime(true);\n        return $this;\n    }\n    protected function setName(string $name) : self\n    {\n        $this->name = $name;\n        return $this;\n    }\n    public function setError(bool $error) : self\n    {\n        $this->error = $error;\n        return $this;\n    }\n    public function setFault(bool $fault) : self\n    {\n        $this->fault = $fault;\n        return $this;\n    }\n    public function addSubsegment(Segment $subsegment) : self\n    {\n        if (!$this->isOpen()) {\n            return $this;\n        }\n        $this->subsegments[] = $subsegment;\n        $subsegment->setSampled($this->isSampled());\n        return $this;\n    }\n    public function submit(SegmentSubmitter $submitter) : void\n    {\n        if (!$this->isSampled()) {\n            return;\n        }\n        $submitter->submitSegment($this);\n    }\n    public function isSampled() : bool\n    {\n        return $this->sampled;\n    }\n    public function setSampled(bool $sampled) : self\n    {\n        $this->sampled = $sampled;\n        return $this;\n    }\n    public function getId() : string\n    {\n        return $this->id;\n    }\n    public function setParentId(?string $parentId) : self\n    {\n        $this->parentId = $parentId;\n        return $this;\n    }\n    public function setTraceId(string $traceId) : self\n    {\n        $this->traceId = $traceId;\n        return $this;\n    }\n    public function getTraceId() : string\n    {\n        return $this->traceId;\n    }\n    public function isOpen() : bool\n    {\n        return isset($this->startTime) && !isset($this->endTime);\n    }\n    public function setIndependent(bool $independent) : self\n    {\n        $this->independent = $independent;\n        return $this;\n    }\n    public function addAnnotation(string $key, string $value) : self\n    {\n        $this->annotations[$key] = $value;\n        return $this;\n    }\n    public function addMetadata(string $key, mixed $value) : self\n    {\n        $this->metadata[$key] = $value;\n        return $this;\n    }\n    public function getCurrentSegment() : self\n    {\n        for ($max = count($this->subsegments); $this->lastOpenSegment < $max; $this->lastOpenSegment++) {\n            if ($this->subsegments[$this->lastOpenSegment]->isOpen()) {\n                return $this->subsegments[$this->lastOpenSegment]->getCurrentSegment();\n            }\n        }\n        return $this;\n    }\n    \/**\n     * @inheritDoc\n     * @return array<string, mixed>\n     *\/\n    public function jsonSerialize() : array\n    {\n        return array_filter(['id' => $this->id, 'parent_id' => $this->parentId, 'trace_id' => $this->traceId ?? null, 'name' => $this->name, 'start_time' => $this->startTime ?? null, 'end_time' => $this->endTime ?? null, 'subsegments' => $this->subsegments ?? null ?: null, 'type' => $this->independent ? 'subsegment' : null, 'fault' => $this->fault ?? null, 'error' => $this->error ?? null, 'annotations' => $this->annotations ?? null ?: null, 'metadata' => $this->metadata ?? null ?: null]);\n    }\n}","originalFilePath":"\/home\/ranpafin\/php-xray\/src\/Segment.php","originalStartLine":77},"diff":"--- Original\n+++ New\n@@ @@\n         $this->endTime = microtime(true);\n         return $this;\n     }\n-    public function setName(string $name) : self\n+    protected function setName(string $name) : self\n     {\n         $this->name = $name;\n         return $this;","processOutput":"PHPUnit 9.5.10 by Sebastian Bergmann and contributors.\n\nRuntime:       PHP 8.0.13\nConfiguration: \/tmp\/tmp-folder\/infection\/phpunitConfiguration.ba18e72c52cd4503e47b38e3f41b8e1d.infection.xml\n\nE\n\nTime: 00:00.003, Memory: 8.00 MB\n\nThere was 1 error:\n\n1) Fido\\PHPXray\\DaemonSegmentSubmitterTest::testSubmitsToDaemon\nsocket_bind(): Unable to bind address [98]: Address already in use\n\n\/home\/ranpafin\/php-xray\/tests\/DaemonSegmentSubmitterTest.php:18\n\nERRORS!\nTests: 1, Assertions: 0, Errors: 1."},{"mutator":{"mutatorName":"PublicVisibility","originalSourceCode":"<?php\n\nnamespace Fido\\PHPXray;\n\nuse JsonSerializable;\nuse Fido\\PHPXray\\Submission\\SegmentSubmitter;\nclass Segment implements JsonSerializable\n{\n    protected string $id;\n    protected ?string $parentId = null;\n    protected string $traceId;\n    protected ?string $name = null;\n    protected float $startTime;\n    protected float $endTime;\n    \/** @var Segment[] *\/\n    protected array $subsegments = [];\n    protected bool $error = false;\n    protected bool $fault = false;\n    protected bool $sampled = false;\n    protected bool $independent = false;\n    \/** @var array<string, mixed> *\/\n    private array $annotations;\n    \/** @var array<string, mixed> *\/\n    private array $metadata;\n    private int $lastOpenSegment = 0;\n    \/**\n     * @throws \\Exception if an appropriate source of randomness cannot be found.\n     *\/\n    public function __construct()\n    {\n        $this->id = bin2hex(random_bytes(8));\n    }\n    public function setTraceHeader(string $traceHeader = null) : self\n    {\n        if (is_null($traceHeader)) {\n            return $this;\n        }\n        $parts = explode(';', $traceHeader);\n        $variables = array_map(function ($str) : array {\n            return explode('=', $str);\n        }, $parts);\n        $variables = array_column($variables, 1, 0);\n        if (isset($variables['Root'])) {\n            $this->setTraceId($variables['Root']);\n        }\n        if (isset($variables['Sampled'])) {\n            $this->setSampled((bool) $variables['Sampled'] ?? false);\n        }\n        if (isset($variables['Parent'])) {\n            $this->setParentId($variables['Parent'] ?? null);\n        }\n        return $this;\n    }\n    public function begin() : self\n    {\n        $this->startTime = microtime(true);\n        return $this;\n    }\n    public function end() : self\n    {\n        $this->endTime = microtime(true);\n        return $this;\n    }\n    public function setName(string $name) : self\n    {\n        $this->name = $name;\n        return $this;\n    }\n    public function setError(bool $error) : self\n    {\n        $this->error = $error;\n        return $this;\n    }\n    public function setFault(bool $fault) : self\n    {\n        $this->fault = $fault;\n        return $this;\n    }\n    public function addSubsegment(Segment $subsegment) : self\n    {\n        if (!$this->isOpen()) {\n            return $this;\n        }\n        $this->subsegments[] = $subsegment;\n        $subsegment->setSampled($this->isSampled());\n        return $this;\n    }\n    public function submit(SegmentSubmitter $submitter) : void\n    {\n        if (!$this->isSampled()) {\n            return;\n        }\n        $submitter->submitSegment($this);\n    }\n    public function isSampled() : bool\n    {\n        return $this->sampled;\n    }\n    public function setSampled(bool $sampled) : self\n    {\n        $this->sampled = $sampled;\n        return $this;\n    }\n    public function getId() : string\n    {\n        return $this->id;\n    }\n    public function setParentId(?string $parentId) : self\n    {\n        $this->parentId = $parentId;\n        return $this;\n    }\n    public function setTraceId(string $traceId) : self\n    {\n        $this->traceId = $traceId;\n        return $this;\n    }\n    public function getTraceId() : string\n    {\n        return $this->traceId;\n    }\n    public function isOpen() : bool\n    {\n        return isset($this->startTime) && !isset($this->endTime);\n    }\n    public function setIndependent(bool $independent) : self\n    {\n        $this->independent = $independent;\n        return $this;\n    }\n    public function addAnnotation(string $key, string $value) : self\n    {\n        $this->annotations[$key] = $value;\n        return $this;\n    }\n    public function addMetadata(string $key, mixed $value) : self\n    {\n        $this->metadata[$key] = $value;\n        return $this;\n    }\n    public function getCurrentSegment() : self\n    {\n        for ($max = count($this->subsegments); $this->lastOpenSegment < $max; $this->lastOpenSegment++) {\n            if ($this->subsegments[$this->lastOpenSegment]->isOpen()) {\n                return $this->subsegments[$this->lastOpenSegment]->getCurrentSegment();\n            }\n        }\n        return $this;\n    }\n    \/**\n     * @inheritDoc\n     * @return array<string, mixed>\n     *\/\n    public function jsonSerialize() : array\n    {\n        return array_filter(['id' => $this->id, 'parent_id' => $this->parentId, 'trace_id' => $this->traceId ?? null, 'name' => $this->name, 'start_time' => $this->startTime ?? null, 'end_time' => $this->endTime ?? null, 'subsegments' => $this->subsegments ?? null ?: null, 'type' => $this->independent ? 'subsegment' : null, 'fault' => $this->fault ?? null, 'error' => $this->error ?? null, 'annotations' => $this->annotations ?? null ?: null, 'metadata' => $this->metadata ?? null ?: null]);\n    }\n}","mutatedSourceCode":"<?php\n\nnamespace Fido\\PHPXray;\n\nuse JsonSerializable;\nuse Fido\\PHPXray\\Submission\\SegmentSubmitter;\nclass Segment implements JsonSerializable\n{\n    protected string $id;\n    protected ?string $parentId = null;\n    protected string $traceId;\n    protected ?string $name = null;\n    protected float $startTime;\n    protected float $endTime;\n    \/** @var Segment[] *\/\n    protected array $subsegments = [];\n    protected bool $error = false;\n    protected bool $fault = false;\n    protected bool $sampled = false;\n    protected bool $independent = false;\n    \/** @var array<string, mixed> *\/\n    private array $annotations;\n    \/** @var array<string, mixed> *\/\n    private array $metadata;\n    private int $lastOpenSegment = 0;\n    \/**\n     * @throws \\Exception if an appropriate source of randomness cannot be found.\n     *\/\n    public function __construct()\n    {\n        $this->id = bin2hex(random_bytes(8));\n    }\n    public function setTraceHeader(string $traceHeader = null) : self\n    {\n        if (is_null($traceHeader)) {\n            return $this;\n        }\n        $parts = explode(';', $traceHeader);\n        $variables = array_map(function ($str) : array {\n            return explode('=', $str);\n        }, $parts);\n        $variables = array_column($variables, 1, 0);\n        if (isset($variables['Root'])) {\n            $this->setTraceId($variables['Root']);\n        }\n        if (isset($variables['Sampled'])) {\n            $this->setSampled((bool) $variables['Sampled'] ?? false);\n        }\n        if (isset($variables['Parent'])) {\n            $this->setParentId($variables['Parent'] ?? null);\n        }\n        return $this;\n    }\n    public function begin() : self\n    {\n        $this->startTime = microtime(true);\n        return $this;\n    }\n    public function end() : self\n    {\n        $this->endTime = microtime(true);\n        return $this;\n    }\n    public function setName(string $name) : self\n    {\n        $this->name = $name;\n        return $this;\n    }\n    protected function setError(bool $error) : self\n    {\n        $this->error = $error;\n        return $this;\n    }\n    public function setFault(bool $fault) : self\n    {\n        $this->fault = $fault;\n        return $this;\n    }\n    public function addSubsegment(Segment $subsegment) : self\n    {\n        if (!$this->isOpen()) {\n            return $this;\n        }\n        $this->subsegments[] = $subsegment;\n        $subsegment->setSampled($this->isSampled());\n        return $this;\n    }\n    public function submit(SegmentSubmitter $submitter) : void\n    {\n        if (!$this->isSampled()) {\n            return;\n        }\n        $submitter->submitSegment($this);\n    }\n    public function isSampled() : bool\n    {\n        return $this->sampled;\n    }\n    public function setSampled(bool $sampled) : self\n    {\n        $this->sampled = $sampled;\n        return $this;\n    }\n    public function getId() : string\n    {\n        return $this->id;\n    }\n    public function setParentId(?string $parentId) : self\n    {\n        $this->parentId = $parentId;\n        return $this;\n    }\n    public function setTraceId(string $traceId) : self\n    {\n        $this->traceId = $traceId;\n        return $this;\n    }\n    public function getTraceId() : string\n    {\n        return $this->traceId;\n    }\n    public function isOpen() : bool\n    {\n        return isset($this->startTime) && !isset($this->endTime);\n    }\n    public function setIndependent(bool $independent) : self\n    {\n        $this->independent = $independent;\n        return $this;\n    }\n    public function addAnnotation(string $key, string $value) : self\n    {\n        $this->annotations[$key] = $value;\n        return $this;\n    }\n    public function addMetadata(string $key, mixed $value) : self\n    {\n        $this->metadata[$key] = $value;\n        return $this;\n    }\n    public function getCurrentSegment() : self\n    {\n        for ($max = count($this->subsegments); $this->lastOpenSegment < $max; $this->lastOpenSegment++) {\n            if ($this->subsegments[$this->lastOpenSegment]->isOpen()) {\n                return $this->subsegments[$this->lastOpenSegment]->getCurrentSegment();\n            }\n        }\n        return $this;\n    }\n    \/**\n     * @inheritDoc\n     * @return array<string, mixed>\n     *\/\n    public function jsonSerialize() : array\n    {\n        return array_filter(['id' => $this->id, 'parent_id' => $this->parentId, 'trace_id' => $this->traceId ?? null, 'name' => $this->name, 'start_time' => $this->startTime ?? null, 'end_time' => $this->endTime ?? null, 'subsegments' => $this->subsegments ?? null ?: null, 'type' => $this->independent ? 'subsegment' : null, 'fault' => $this->fault ?? null, 'error' => $this->error ?? null, 'annotations' => $this->annotations ?? null ?: null, 'metadata' => $this->metadata ?? null ?: null]);\n    }\n}","originalFilePath":"\/home\/ranpafin\/php-xray\/src\/Segment.php","originalStartLine":84},"diff":"--- Original\n+++ New\n@@ @@\n         $this->name = $name;\n         return $this;\n     }\n-    public function setError(bool $error) : self\n+    protected function setError(bool $error) : self\n     {\n         $this->error = $error;\n         return $this;","processOutput":"PHPUnit 9.5.10 by Sebastian Bergmann and contributors.\n\nRuntime:       PHP 8.0.13\nConfiguration: \/tmp\/tmp-folder\/infection\/phpunitConfiguration.8e12340361635701db054611d77ee561.infection.xml\n\nE\n\nTime: 00:00.004, Memory: 8.00 MB\n\nThere was 1 error:\n\n1) Fido\\PHPXray\\SegmentTest::testSegmentWithErrorSerialisesCorrectly\nError: Call to protected method Fido\\PHPXray\\Segment::setError() from scope Fido\\PHPXray\\SegmentTest\n\n\/home\/ranpafin\/php-xray\/tests\/SegmentTest.php:40\n\nERRORS!\nTests: 1, Assertions: 0, Errors: 1."},{"mutator":{"mutatorName":"PublicVisibility","originalSourceCode":"<?php\n\nnamespace Fido\\PHPXray;\n\nuse JsonSerializable;\nuse Fido\\PHPXray\\Submission\\SegmentSubmitter;\nclass Segment implements JsonSerializable\n{\n    protected string $id;\n    protected ?string $parentId = null;\n    protected string $traceId;\n    protected ?string $name = null;\n    protected float $startTime;\n    protected float $endTime;\n    \/** @var Segment[] *\/\n    protected array $subsegments = [];\n    protected bool $error = false;\n    protected bool $fault = false;\n    protected bool $sampled = false;\n    protected bool $independent = false;\n    \/** @var array<string, mixed> *\/\n    private array $annotations;\n    \/** @var array<string, mixed> *\/\n    private array $metadata;\n    private int $lastOpenSegment = 0;\n    \/**\n     * @throws \\Exception if an appropriate source of randomness cannot be found.\n     *\/\n    public function __construct()\n    {\n        $this->id = bin2hex(random_bytes(8));\n    }\n    public function setTraceHeader(string $traceHeader = null) : self\n    {\n        if (is_null($traceHeader)) {\n            return $this;\n        }\n        $parts = explode(';', $traceHeader);\n        $variables = array_map(function ($str) : array {\n            return explode('=', $str);\n        }, $parts);\n        $variables = array_column($variables, 1, 0);\n        if (isset($variables['Root'])) {\n            $this->setTraceId($variables['Root']);\n        }\n        if (isset($variables['Sampled'])) {\n            $this->setSampled((bool) $variables['Sampled'] ?? false);\n        }\n        if (isset($variables['Parent'])) {\n            $this->setParentId($variables['Parent'] ?? null);\n        }\n        return $this;\n    }\n    public function begin() : self\n    {\n        $this->startTime = microtime(true);\n        return $this;\n    }\n    public function end() : self\n    {\n        $this->endTime = microtime(true);\n        return $this;\n    }\n    public function setName(string $name) : self\n    {\n        $this->name = $name;\n        return $this;\n    }\n    public function setError(bool $error) : self\n    {\n        $this->error = $error;\n        return $this;\n    }\n    public function setFault(bool $fault) : self\n    {\n        $this->fault = $fault;\n        return $this;\n    }\n    public function addSubsegment(Segment $subsegment) : self\n    {\n        if (!$this->isOpen()) {\n            return $this;\n        }\n        $this->subsegments[] = $subsegment;\n        $subsegment->setSampled($this->isSampled());\n        return $this;\n    }\n    public function submit(SegmentSubmitter $submitter) : void\n    {\n        if (!$this->isSampled()) {\n            return;\n        }\n        $submitter->submitSegment($this);\n    }\n    public function isSampled() : bool\n    {\n        return $this->sampled;\n    }\n    public function setSampled(bool $sampled) : self\n    {\n        $this->sampled = $sampled;\n        return $this;\n    }\n    public function getId() : string\n    {\n        return $this->id;\n    }\n    public function setParentId(?string $parentId) : self\n    {\n        $this->parentId = $parentId;\n        return $this;\n    }\n    public function setTraceId(string $traceId) : self\n    {\n        $this->traceId = $traceId;\n        return $this;\n    }\n    public function getTraceId() : string\n    {\n        return $this->traceId;\n    }\n    public function isOpen() : bool\n    {\n        return isset($this->startTime) && !isset($this->endTime);\n    }\n    public function setIndependent(bool $independent) : self\n    {\n        $this->independent = $independent;\n        return $this;\n    }\n    public function addAnnotation(string $key, string $value) : self\n    {\n        $this->annotations[$key] = $value;\n        return $this;\n    }\n    public function addMetadata(string $key, mixed $value) : self\n    {\n        $this->metadata[$key] = $value;\n        return $this;\n    }\n    public function getCurrentSegment() : self\n    {\n        for ($max = count($this->subsegments); $this->lastOpenSegment < $max; $this->lastOpenSegment++) {\n            if ($this->subsegments[$this->lastOpenSegment]->isOpen()) {\n                return $this->subsegments[$this->lastOpenSegment]->getCurrentSegment();\n            }\n        }\n        return $this;\n    }\n    \/**\n     * @inheritDoc\n     * @return array<string, mixed>\n     *\/\n    public function jsonSerialize() : array\n    {\n        return array_filter(['id' => $this->id, 'parent_id' => $this->parentId, 'trace_id' => $this->traceId ?? null, 'name' => $this->name, 'start_time' => $this->startTime ?? null, 'end_time' => $this->endTime ?? null, 'subsegments' => $this->subsegments ?? null ?: null, 'type' => $this->independent ? 'subsegment' : null, 'fault' => $this->fault ?? null, 'error' => $this->error ?? null, 'annotations' => $this->annotations ?? null ?: null, 'metadata' => $this->metadata ?? null ?: null]);\n    }\n}","mutatedSourceCode":"<?php\n\nnamespace Fido\\PHPXray;\n\nuse JsonSerializable;\nuse Fido\\PHPXray\\Submission\\SegmentSubmitter;\nclass Segment implements JsonSerializable\n{\n    protected string $id;\n    protected ?string $parentId = null;\n    protected string $traceId;\n    protected ?string $name = null;\n    protected float $startTime;\n    protected float $endTime;\n    \/** @var Segment[] *\/\n    protected array $subsegments = [];\n    protected bool $error = false;\n    protected bool $fault = false;\n    protected bool $sampled = false;\n    protected bool $independent = false;\n    \/** @var array<string, mixed> *\/\n    private array $annotations;\n    \/** @var array<string, mixed> *\/\n    private array $metadata;\n    private int $lastOpenSegment = 0;\n    \/**\n     * @throws \\Exception if an appropriate source of randomness cannot be found.\n     *\/\n    public function __construct()\n    {\n        $this->id = bin2hex(random_bytes(8));\n    }\n    public function setTraceHeader(string $traceHeader = null) : self\n    {\n        if (is_null($traceHeader)) {\n            return $this;\n        }\n        $parts = explode(';', $traceHeader);\n        $variables = array_map(function ($str) : array {\n            return explode('=', $str);\n        }, $parts);\n        $variables = array_column($variables, 1, 0);\n        if (isset($variables['Root'])) {\n            $this->setTraceId($variables['Root']);\n        }\n        if (isset($variables['Sampled'])) {\n            $this->setSampled((bool) $variables['Sampled'] ?? false);\n        }\n        if (isset($variables['Parent'])) {\n            $this->setParentId($variables['Parent'] ?? null);\n        }\n        return $this;\n    }\n    public function begin() : self\n    {\n        $this->startTime = microtime(true);\n        return $this;\n    }\n    public function end() : self\n    {\n        $this->endTime = microtime(true);\n        return $this;\n    }\n    public function setName(string $name) : self\n    {\n        $this->name = $name;\n        return $this;\n    }\n    public function setError(bool $error) : self\n    {\n        $this->error = $error;\n        return $this;\n    }\n    protected function setFault(bool $fault) : self\n    {\n        $this->fault = $fault;\n        return $this;\n    }\n    public function addSubsegment(Segment $subsegment) : self\n    {\n        if (!$this->isOpen()) {\n            return $this;\n        }\n        $this->subsegments[] = $subsegment;\n        $subsegment->setSampled($this->isSampled());\n        return $this;\n    }\n    public function submit(SegmentSubmitter $submitter) : void\n    {\n        if (!$this->isSampled()) {\n            return;\n        }\n        $submitter->submitSegment($this);\n    }\n    public function isSampled() : bool\n    {\n        return $this->sampled;\n    }\n    public function setSampled(bool $sampled) : self\n    {\n        $this->sampled = $sampled;\n        return $this;\n    }\n    public function getId() : string\n    {\n        return $this->id;\n    }\n    public function setParentId(?string $parentId) : self\n    {\n        $this->parentId = $parentId;\n        return $this;\n    }\n    public function setTraceId(string $traceId) : self\n    {\n        $this->traceId = $traceId;\n        return $this;\n    }\n    public function getTraceId() : string\n    {\n        return $this->traceId;\n    }\n    public function isOpen() : bool\n    {\n        return isset($this->startTime) && !isset($this->endTime);\n    }\n    public function setIndependent(bool $independent) : self\n    {\n        $this->independent = $independent;\n        return $this;\n    }\n    public function addAnnotation(string $key, string $value) : self\n    {\n        $this->annotations[$key] = $value;\n        return $this;\n    }\n    public function addMetadata(string $key, mixed $value) : self\n    {\n        $this->metadata[$key] = $value;\n        return $this;\n    }\n    public function getCurrentSegment() : self\n    {\n        for ($max = count($this->subsegments); $this->lastOpenSegment < $max; $this->lastOpenSegment++) {\n            if ($this->subsegments[$this->lastOpenSegment]->isOpen()) {\n                return $this->subsegments[$this->lastOpenSegment]->getCurrentSegment();\n            }\n        }\n        return $this;\n    }\n    \/**\n     * @inheritDoc\n     * @return array<string, mixed>\n     *\/\n    public function jsonSerialize() : array\n    {\n        return array_filter(['id' => $this->id, 'parent_id' => $this->parentId, 'trace_id' => $this->traceId ?? null, 'name' => $this->name, 'start_time' => $this->startTime ?? null, 'end_time' => $this->endTime ?? null, 'subsegments' => $this->subsegments ?? null ?: null, 'type' => $this->independent ? 'subsegment' : null, 'fault' => $this->fault ?? null, 'error' => $this->error ?? null, 'annotations' => $this->annotations ?? null ?: null, 'metadata' => $this->metadata ?? null ?: null]);\n    }\n}","originalFilePath":"\/home\/ranpafin\/php-xray\/src\/Segment.php","originalStartLine":91},"diff":"--- Original\n+++ New\n@@ @@\n         $this->error = $error;\n         return $this;\n     }\n-    public function setFault(bool $fault) : self\n+    protected function setFault(bool $fault) : self\n     {\n         $this->fault = $fault;\n         return $this;","processOutput":"PHPUnit 9.5.10 by Sebastian Bergmann and contributors.\n\nRuntime:       PHP 8.0.13\nConfiguration: \/tmp\/tmp-folder\/infection\/phpunitConfiguration.789fe76309ba4661f794f8c40be952e9.infection.xml\n\nE\n\nTime: 00:00.003, Memory: 8.00 MB\n\nThere was 1 error:\n\n1) Fido\\PHPXray\\SegmentTest::testSegmentWithFaultSerialisesCorrectly\nError: Call to protected method Fido\\PHPXray\\Segment::setFault() from scope Fido\\PHPXray\\SegmentTest\n\n\/home\/ranpafin\/php-xray\/tests\/SegmentTest.php:62\n\nERRORS!\nTests: 1, Assertions: 0, Errors: 1."},{"mutator":{"mutatorName":"PublicVisibility","originalSourceCode":"<?php\n\nnamespace Fido\\PHPXray;\n\nuse JsonSerializable;\nuse Fido\\PHPXray\\Submission\\SegmentSubmitter;\nclass Segment implements JsonSerializable\n{\n    protected string $id;\n    protected ?string $parentId = null;\n    protected string $traceId;\n    protected ?string $name = null;\n    protected float $startTime;\n    protected float $endTime;\n    \/** @var Segment[] *\/\n    protected array $subsegments = [];\n    protected bool $error = false;\n    protected bool $fault = false;\n    protected bool $sampled = false;\n    protected bool $independent = false;\n    \/** @var array<string, mixed> *\/\n    private array $annotations;\n    \/** @var array<string, mixed> *\/\n    private array $metadata;\n    private int $lastOpenSegment = 0;\n    \/**\n     * @throws \\Exception if an appropriate source of randomness cannot be found.\n     *\/\n    public function __construct()\n    {\n        $this->id = bin2hex(random_bytes(8));\n    }\n    public function setTraceHeader(string $traceHeader = null) : self\n    {\n        if (is_null($traceHeader)) {\n            return $this;\n        }\n        $parts = explode(';', $traceHeader);\n        $variables = array_map(function ($str) : array {\n            return explode('=', $str);\n        }, $parts);\n        $variables = array_column($variables, 1, 0);\n        if (isset($variables['Root'])) {\n            $this->setTraceId($variables['Root']);\n        }\n        if (isset($variables['Sampled'])) {\n            $this->setSampled((bool) $variables['Sampled'] ?? false);\n        }\n        if (isset($variables['Parent'])) {\n            $this->setParentId($variables['Parent'] ?? null);\n        }\n        return $this;\n    }\n    public function begin() : self\n    {\n        $this->startTime = microtime(true);\n        return $this;\n    }\n    public function end() : self\n    {\n        $this->endTime = microtime(true);\n        return $this;\n    }\n    public function setName(string $name) : self\n    {\n        $this->name = $name;\n        return $this;\n    }\n    public function setError(bool $error) : self\n    {\n        $this->error = $error;\n        return $this;\n    }\n    public function setFault(bool $fault) : self\n    {\n        $this->fault = $fault;\n        return $this;\n    }\n    public function addSubsegment(Segment $subsegment) : self\n    {\n        if (!$this->isOpen()) {\n            return $this;\n        }\n        $this->subsegments[] = $subsegment;\n        $subsegment->setSampled($this->isSampled());\n        return $this;\n    }\n    public function submit(SegmentSubmitter $submitter) : void\n    {\n        if (!$this->isSampled()) {\n            return;\n        }\n        $submitter->submitSegment($this);\n    }\n    public function isSampled() : bool\n    {\n        return $this->sampled;\n    }\n    public function setSampled(bool $sampled) : self\n    {\n        $this->sampled = $sampled;\n        return $this;\n    }\n    public function getId() : string\n    {\n        return $this->id;\n    }\n    public function setParentId(?string $parentId) : self\n    {\n        $this->parentId = $parentId;\n        return $this;\n    }\n    public function setTraceId(string $traceId) : self\n    {\n        $this->traceId = $traceId;\n        return $this;\n    }\n    public function getTraceId() : string\n    {\n        return $this->traceId;\n    }\n    public function isOpen() : bool\n    {\n        return isset($this->startTime) && !isset($this->endTime);\n    }\n    public function setIndependent(bool $independent) : self\n    {\n        $this->independent = $independent;\n        return $this;\n    }\n    public function addAnnotation(string $key, string $value) : self\n    {\n        $this->annotations[$key] = $value;\n        return $this;\n    }\n    public function addMetadata(string $key, mixed $value) : self\n    {\n        $this->metadata[$key] = $value;\n        return $this;\n    }\n    public function getCurrentSegment() : self\n    {\n        for ($max = count($this->subsegments); $this->lastOpenSegment < $max; $this->lastOpenSegment++) {\n            if ($this->subsegments[$this->lastOpenSegment]->isOpen()) {\n                return $this->subsegments[$this->lastOpenSegment]->getCurrentSegment();\n            }\n        }\n        return $this;\n    }\n    \/**\n     * @inheritDoc\n     * @return array<string, mixed>\n     *\/\n    public function jsonSerialize() : array\n    {\n        return array_filter(['id' => $this->id, 'parent_id' => $this->parentId, 'trace_id' => $this->traceId ?? null, 'name' => $this->name, 'start_time' => $this->startTime ?? null, 'end_time' => $this->endTime ?? null, 'subsegments' => $this->subsegments ?? null ?: null, 'type' => $this->independent ? 'subsegment' : null, 'fault' => $this->fault ?? null, 'error' => $this->error ?? null, 'annotations' => $this->annotations ?? null ?: null, 'metadata' => $this->metadata ?? null ?: null]);\n    }\n}","mutatedSourceCode":"<?php\n\nnamespace Fido\\PHPXray;\n\nuse JsonSerializable;\nuse Fido\\PHPXray\\Submission\\SegmentSubmitter;\nclass Segment implements JsonSerializable\n{\n    protected string $id;\n    protected ?string $parentId = null;\n    protected string $traceId;\n    protected ?string $name = null;\n    protected float $startTime;\n    protected float $endTime;\n    \/** @var Segment[] *\/\n    protected array $subsegments = [];\n    protected bool $error = false;\n    protected bool $fault = false;\n    protected bool $sampled = false;\n    protected bool $independent = false;\n    \/** @var array<string, mixed> *\/\n    private array $annotations;\n    \/** @var array<string, mixed> *\/\n    private array $metadata;\n    private int $lastOpenSegment = 0;\n    \/**\n     * @throws \\Exception if an appropriate source of randomness cannot be found.\n     *\/\n    public function __construct()\n    {\n        $this->id = bin2hex(random_bytes(8));\n    }\n    public function setTraceHeader(string $traceHeader = null) : self\n    {\n        if (is_null($traceHeader)) {\n            return $this;\n        }\n        $parts = explode(';', $traceHeader);\n        $variables = array_map(function ($str) : array {\n            return explode('=', $str);\n        }, $parts);\n        $variables = array_column($variables, 1, 0);\n        if (isset($variables['Root'])) {\n            $this->setTraceId($variables['Root']);\n        }\n        if (isset($variables['Sampled'])) {\n            $this->setSampled((bool) $variables['Sampled'] ?? false);\n        }\n        if (isset($variables['Parent'])) {\n            $this->setParentId($variables['Parent'] ?? null);\n        }\n        return $this;\n    }\n    public function begin() : self\n    {\n        $this->startTime = microtime(true);\n        return $this;\n    }\n    public function end() : self\n    {\n        $this->endTime = microtime(true);\n        return $this;\n    }\n    public function setName(string $name) : self\n    {\n        $this->name = $name;\n        return $this;\n    }\n    public function setError(bool $error) : self\n    {\n        $this->error = $error;\n        return $this;\n    }\n    public function setFault(bool $fault) : self\n    {\n        $this->fault = $fault;\n        return $this;\n    }\n    protected function addSubsegment(Segment $subsegment) : self\n    {\n        if (!$this->isOpen()) {\n            return $this;\n        }\n        $this->subsegments[] = $subsegment;\n        $subsegment->setSampled($this->isSampled());\n        return $this;\n    }\n    public function submit(SegmentSubmitter $submitter) : void\n    {\n        if (!$this->isSampled()) {\n            return;\n        }\n        $submitter->submitSegment($this);\n    }\n    public function isSampled() : bool\n    {\n        return $this->sampled;\n    }\n    public function setSampled(bool $sampled) : self\n    {\n        $this->sampled = $sampled;\n        return $this;\n    }\n    public function getId() : string\n    {\n        return $this->id;\n    }\n    public function setParentId(?string $parentId) : self\n    {\n        $this->parentId = $parentId;\n        return $this;\n    }\n    public function setTraceId(string $traceId) : self\n    {\n        $this->traceId = $traceId;\n        return $this;\n    }\n    public function getTraceId() : string\n    {\n        return $this->traceId;\n    }\n    public function isOpen() : bool\n    {\n        return isset($this->startTime) && !isset($this->endTime);\n    }\n    public function setIndependent(bool $independent) : self\n    {\n        $this->independent = $independent;\n        return $this;\n    }\n    public function addAnnotation(string $key, string $value) : self\n    {\n        $this->annotations[$key] = $value;\n        return $this;\n    }\n    public function addMetadata(string $key, mixed $value) : self\n    {\n        $this->metadata[$key] = $value;\n        return $this;\n    }\n    public function getCurrentSegment() : self\n    {\n        for ($max = count($this->subsegments); $this->lastOpenSegment < $max; $this->lastOpenSegment++) {\n            if ($this->subsegments[$this->lastOpenSegment]->isOpen()) {\n                return $this->subsegments[$this->lastOpenSegment]->getCurrentSegment();\n            }\n        }\n        return $this;\n    }\n    \/**\n     * @inheritDoc\n     * @return array<string, mixed>\n     *\/\n    public function jsonSerialize() : array\n    {\n        return array_filter(['id' => $this->id, 'parent_id' => $this->parentId, 'trace_id' => $this->traceId ?? null, 'name' => $this->name, 'start_time' => $this->startTime ?? null, 'end_time' => $this->endTime ?? null, 'subsegments' => $this->subsegments ?? null ?: null, 'type' => $this->independent ? 'subsegment' : null, 'fault' => $this->fault ?? null, 'error' => $this->error ?? null, 'annotations' => $this->annotations ?? null ?: null, 'metadata' => $this->metadata ?? null ?: null]);\n    }\n}","originalFilePath":"\/home\/ranpafin\/php-xray\/src\/Segment.php","originalStartLine":98},"diff":"--- Original\n+++ New\n@@ @@\n         $this->fault = $fault;\n         return $this;\n     }\n-    public function addSubsegment(Segment $subsegment) : self\n+    protected function addSubsegment(Segment $subsegment) : self\n     {\n         if (!$this->isOpen()) {\n             return $this;","processOutput":"PHPUnit 9.5.10 by Sebastian Bergmann and contributors.\n\nRuntime:       PHP 8.0.13\nConfiguration: \/tmp\/tmp-folder\/infection\/phpunitConfiguration.ece3cf83b6d3e7341cf1b1b8da4ac05c.infection.xml\n\nE\n\nTime: 00:00.003, Memory: 8.00 MB\n\nThere was 1 error:\n\n1) Fido\\PHPXray\\DaemonSegmentSubmitterTest::testSubmitsToDaemon\nsocket_bind(): Unable to bind address [98]: Address already in use\n\n\/home\/ranpafin\/php-xray\/tests\/DaemonSegmentSubmitterTest.php:18\n\nERRORS!\nTests: 1, Assertions: 0, Errors: 1."},{"mutator":{"mutatorName":"LogicalNot","originalSourceCode":"<?php\n\nnamespace Fido\\PHPXray;\n\nuse JsonSerializable;\nuse Fido\\PHPXray\\Submission\\SegmentSubmitter;\nclass Segment implements JsonSerializable\n{\n    protected string $id;\n    protected ?string $parentId = null;\n    protected string $traceId;\n    protected ?string $name = null;\n    protected float $startTime;\n    protected float $endTime;\n    \/** @var Segment[] *\/\n    protected array $subsegments = [];\n    protected bool $error = false;\n    protected bool $fault = false;\n    protected bool $sampled = false;\n    protected bool $independent = false;\n    \/** @var array<string, mixed> *\/\n    private array $annotations;\n    \/** @var array<string, mixed> *\/\n    private array $metadata;\n    private int $lastOpenSegment = 0;\n    \/**\n     * @throws \\Exception if an appropriate source of randomness cannot be found.\n     *\/\n    public function __construct()\n    {\n        $this->id = bin2hex(random_bytes(8));\n    }\n    public function setTraceHeader(string $traceHeader = null) : self\n    {\n        if (is_null($traceHeader)) {\n            return $this;\n        }\n        $parts = explode(';', $traceHeader);\n        $variables = array_map(function ($str) : array {\n            return explode('=', $str);\n        }, $parts);\n        $variables = array_column($variables, 1, 0);\n        if (isset($variables['Root'])) {\n            $this->setTraceId($variables['Root']);\n        }\n        if (isset($variables['Sampled'])) {\n            $this->setSampled((bool) $variables['Sampled'] ?? false);\n        }\n        if (isset($variables['Parent'])) {\n            $this->setParentId($variables['Parent'] ?? null);\n        }\n        return $this;\n    }\n    public function begin() : self\n    {\n        $this->startTime = microtime(true);\n        return $this;\n    }\n    public function end() : self\n    {\n        $this->endTime = microtime(true);\n        return $this;\n    }\n    public function setName(string $name) : self\n    {\n        $this->name = $name;\n        return $this;\n    }\n    public function setError(bool $error) : self\n    {\n        $this->error = $error;\n        return $this;\n    }\n    public function setFault(bool $fault) : self\n    {\n        $this->fault = $fault;\n        return $this;\n    }\n    public function addSubsegment(Segment $subsegment) : self\n    {\n        if (!$this->isOpen()) {\n            return $this;\n        }\n        $this->subsegments[] = $subsegment;\n        $subsegment->setSampled($this->isSampled());\n        return $this;\n    }\n    public function submit(SegmentSubmitter $submitter) : void\n    {\n        if (!$this->isSampled()) {\n            return;\n        }\n        $submitter->submitSegment($this);\n    }\n    public function isSampled() : bool\n    {\n        return $this->sampled;\n    }\n    public function setSampled(bool $sampled) : self\n    {\n        $this->sampled = $sampled;\n        return $this;\n    }\n    public function getId() : string\n    {\n        return $this->id;\n    }\n    public function setParentId(?string $parentId) : self\n    {\n        $this->parentId = $parentId;\n        return $this;\n    }\n    public function setTraceId(string $traceId) : self\n    {\n        $this->traceId = $traceId;\n        return $this;\n    }\n    public function getTraceId() : string\n    {\n        return $this->traceId;\n    }\n    public function isOpen() : bool\n    {\n        return isset($this->startTime) && !isset($this->endTime);\n    }\n    public function setIndependent(bool $independent) : self\n    {\n        $this->independent = $independent;\n        return $this;\n    }\n    public function addAnnotation(string $key, string $value) : self\n    {\n        $this->annotations[$key] = $value;\n        return $this;\n    }\n    public function addMetadata(string $key, mixed $value) : self\n    {\n        $this->metadata[$key] = $value;\n        return $this;\n    }\n    public function getCurrentSegment() : self\n    {\n        for ($max = count($this->subsegments); $this->lastOpenSegment < $max; $this->lastOpenSegment++) {\n            if ($this->subsegments[$this->lastOpenSegment]->isOpen()) {\n                return $this->subsegments[$this->lastOpenSegment]->getCurrentSegment();\n            }\n        }\n        return $this;\n    }\n    \/**\n     * @inheritDoc\n     * @return array<string, mixed>\n     *\/\n    public function jsonSerialize() : array\n    {\n        return array_filter(['id' => $this->id, 'parent_id' => $this->parentId, 'trace_id' => $this->traceId ?? null, 'name' => $this->name, 'start_time' => $this->startTime ?? null, 'end_time' => $this->endTime ?? null, 'subsegments' => $this->subsegments ?? null ?: null, 'type' => $this->independent ? 'subsegment' : null, 'fault' => $this->fault ?? null, 'error' => $this->error ?? null, 'annotations' => $this->annotations ?? null ?: null, 'metadata' => $this->metadata ?? null ?: null]);\n    }\n}","mutatedSourceCode":"<?php\n\nnamespace Fido\\PHPXray;\n\nuse JsonSerializable;\nuse Fido\\PHPXray\\Submission\\SegmentSubmitter;\nclass Segment implements JsonSerializable\n{\n    protected string $id;\n    protected ?string $parentId = null;\n    protected string $traceId;\n    protected ?string $name = null;\n    protected float $startTime;\n    protected float $endTime;\n    \/** @var Segment[] *\/\n    protected array $subsegments = [];\n    protected bool $error = false;\n    protected bool $fault = false;\n    protected bool $sampled = false;\n    protected bool $independent = false;\n    \/** @var array<string, mixed> *\/\n    private array $annotations;\n    \/** @var array<string, mixed> *\/\n    private array $metadata;\n    private int $lastOpenSegment = 0;\n    \/**\n     * @throws \\Exception if an appropriate source of randomness cannot be found.\n     *\/\n    public function __construct()\n    {\n        $this->id = bin2hex(random_bytes(8));\n    }\n    public function setTraceHeader(string $traceHeader = null) : self\n    {\n        if (is_null($traceHeader)) {\n            return $this;\n        }\n        $parts = explode(';', $traceHeader);\n        $variables = array_map(function ($str) : array {\n            return explode('=', $str);\n        }, $parts);\n        $variables = array_column($variables, 1, 0);\n        if (isset($variables['Root'])) {\n            $this->setTraceId($variables['Root']);\n        }\n        if (isset($variables['Sampled'])) {\n            $this->setSampled((bool) $variables['Sampled'] ?? false);\n        }\n        if (isset($variables['Parent'])) {\n            $this->setParentId($variables['Parent'] ?? null);\n        }\n        return $this;\n    }\n    public function begin() : self\n    {\n        $this->startTime = microtime(true);\n        return $this;\n    }\n    public function end() : self\n    {\n        $this->endTime = microtime(true);\n        return $this;\n    }\n    public function setName(string $name) : self\n    {\n        $this->name = $name;\n        return $this;\n    }\n    public function setError(bool $error) : self\n    {\n        $this->error = $error;\n        return $this;\n    }\n    public function setFault(bool $fault) : self\n    {\n        $this->fault = $fault;\n        return $this;\n    }\n    public function addSubsegment(Segment $subsegment) : self\n    {\n        if ($this->isOpen()) {\n            return $this;\n        }\n        $this->subsegments[] = $subsegment;\n        $subsegment->setSampled($this->isSampled());\n        return $this;\n    }\n    public function submit(SegmentSubmitter $submitter) : void\n    {\n        if (!$this->isSampled()) {\n            return;\n        }\n        $submitter->submitSegment($this);\n    }\n    public function isSampled() : bool\n    {\n        return $this->sampled;\n    }\n    public function setSampled(bool $sampled) : self\n    {\n        $this->sampled = $sampled;\n        return $this;\n    }\n    public function getId() : string\n    {\n        return $this->id;\n    }\n    public function setParentId(?string $parentId) : self\n    {\n        $this->parentId = $parentId;\n        return $this;\n    }\n    public function setTraceId(string $traceId) : self\n    {\n        $this->traceId = $traceId;\n        return $this;\n    }\n    public function getTraceId() : string\n    {\n        return $this->traceId;\n    }\n    public function isOpen() : bool\n    {\n        return isset($this->startTime) && !isset($this->endTime);\n    }\n    public function setIndependent(bool $independent) : self\n    {\n        $this->independent = $independent;\n        return $this;\n    }\n    public function addAnnotation(string $key, string $value) : self\n    {\n        $this->annotations[$key] = $value;\n        return $this;\n    }\n    public function addMetadata(string $key, mixed $value) : self\n    {\n        $this->metadata[$key] = $value;\n        return $this;\n    }\n    public function getCurrentSegment() : self\n    {\n        for ($max = count($this->subsegments); $this->lastOpenSegment < $max; $this->lastOpenSegment++) {\n            if ($this->subsegments[$this->lastOpenSegment]->isOpen()) {\n                return $this->subsegments[$this->lastOpenSegment]->getCurrentSegment();\n            }\n        }\n        return $this;\n    }\n    \/**\n     * @inheritDoc\n     * @return array<string, mixed>\n     *\/\n    public function jsonSerialize() : array\n    {\n        return array_filter(['id' => $this->id, 'parent_id' => $this->parentId, 'trace_id' => $this->traceId ?? null, 'name' => $this->name, 'start_time' => $this->startTime ?? null, 'end_time' => $this->endTime ?? null, 'subsegments' => $this->subsegments ?? null ?: null, 'type' => $this->independent ? 'subsegment' : null, 'fault' => $this->fault ?? null, 'error' => $this->error ?? null, 'annotations' => $this->annotations ?? null ?: null, 'metadata' => $this->metadata ?? null ?: null]);\n    }\n}","originalFilePath":"\/home\/ranpafin\/php-xray\/src\/Segment.php","originalStartLine":100},"diff":"--- Original\n+++ New\n@@ @@\n     }\n     public function addSubsegment(Segment $subsegment) : self\n     {\n-        if (!$this->isOpen()) {\n+        if ($this->isOpen()) {\n             return $this;\n         }\n         $this->subsegments[] = $subsegment;","processOutput":"PHPUnit 9.5.10 by Sebastian Bergmann and contributors.\n\nRuntime:       PHP 8.0.13\nConfiguration: \/tmp\/tmp-folder\/infection\/phpunitConfiguration.f35d03c01f7710108c599772b0b69d8f.infection.xml\n\nE\n\nTime: 00:00.004, Memory: 8.00 MB\n\nThere was 1 error:\n\n1) Fido\\PHPXray\\DaemonSegmentSubmitterTest::testSubmitsToDaemon\nsocket_bind(): Unable to bind address [98]: Address already in use\n\n\/home\/ranpafin\/php-xray\/tests\/DaemonSegmentSubmitterTest.php:18\n\nERRORS!\nTests: 1, Assertions: 0, Errors: 1."},{"mutator":{"mutatorName":"MethodCallRemoval","originalSourceCode":"<?php\n\nnamespace Fido\\PHPXray;\n\nuse JsonSerializable;\nuse Fido\\PHPXray\\Submission\\SegmentSubmitter;\nclass Segment implements JsonSerializable\n{\n    protected string $id;\n    protected ?string $parentId = null;\n    protected string $traceId;\n    protected ?string $name = null;\n    protected float $startTime;\n    protected float $endTime;\n    \/** @var Segment[] *\/\n    protected array $subsegments = [];\n    protected bool $error = false;\n    protected bool $fault = false;\n    protected bool $sampled = false;\n    protected bool $independent = false;\n    \/** @var array<string, mixed> *\/\n    private array $annotations;\n    \/** @var array<string, mixed> *\/\n    private array $metadata;\n    private int $lastOpenSegment = 0;\n    \/**\n     * @throws \\Exception if an appropriate source of randomness cannot be found.\n     *\/\n    public function __construct()\n    {\n        $this->id = bin2hex(random_bytes(8));\n    }\n    public function setTraceHeader(string $traceHeader = null) : self\n    {\n        if (is_null($traceHeader)) {\n            return $this;\n        }\n        $parts = explode(';', $traceHeader);\n        $variables = array_map(function ($str) : array {\n            return explode('=', $str);\n        }, $parts);\n        $variables = array_column($variables, 1, 0);\n        if (isset($variables['Root'])) {\n            $this->setTraceId($variables['Root']);\n        }\n        if (isset($variables['Sampled'])) {\n            $this->setSampled((bool) $variables['Sampled'] ?? false);\n        }\n        if (isset($variables['Parent'])) {\n            $this->setParentId($variables['Parent'] ?? null);\n        }\n        return $this;\n    }\n    public function begin() : self\n    {\n        $this->startTime = microtime(true);\n        return $this;\n    }\n    public function end() : self\n    {\n        $this->endTime = microtime(true);\n        return $this;\n    }\n    public function setName(string $name) : self\n    {\n        $this->name = $name;\n        return $this;\n    }\n    public function setError(bool $error) : self\n    {\n        $this->error = $error;\n        return $this;\n    }\n    public function setFault(bool $fault) : self\n    {\n        $this->fault = $fault;\n        return $this;\n    }\n    public function addSubsegment(Segment $subsegment) : self\n    {\n        if (!$this->isOpen()) {\n            return $this;\n        }\n        $this->subsegments[] = $subsegment;\n        $subsegment->setSampled($this->isSampled());\n        return $this;\n    }\n    public function submit(SegmentSubmitter $submitter) : void\n    {\n        if (!$this->isSampled()) {\n            return;\n        }\n        $submitter->submitSegment($this);\n    }\n    public function isSampled() : bool\n    {\n        return $this->sampled;\n    }\n    public function setSampled(bool $sampled) : self\n    {\n        $this->sampled = $sampled;\n        return $this;\n    }\n    public function getId() : string\n    {\n        return $this->id;\n    }\n    public function setParentId(?string $parentId) : self\n    {\n        $this->parentId = $parentId;\n        return $this;\n    }\n    public function setTraceId(string $traceId) : self\n    {\n        $this->traceId = $traceId;\n        return $this;\n    }\n    public function getTraceId() : string\n    {\n        return $this->traceId;\n    }\n    public function isOpen() : bool\n    {\n        return isset($this->startTime) && !isset($this->endTime);\n    }\n    public function setIndependent(bool $independent) : self\n    {\n        $this->independent = $independent;\n        return $this;\n    }\n    public function addAnnotation(string $key, string $value) : self\n    {\n        $this->annotations[$key] = $value;\n        return $this;\n    }\n    public function addMetadata(string $key, mixed $value) : self\n    {\n        $this->metadata[$key] = $value;\n        return $this;\n    }\n    public function getCurrentSegment() : self\n    {\n        for ($max = count($this->subsegments); $this->lastOpenSegment < $max; $this->lastOpenSegment++) {\n            if ($this->subsegments[$this->lastOpenSegment]->isOpen()) {\n                return $this->subsegments[$this->lastOpenSegment]->getCurrentSegment();\n            }\n        }\n        return $this;\n    }\n    \/**\n     * @inheritDoc\n     * @return array<string, mixed>\n     *\/\n    public function jsonSerialize() : array\n    {\n        return array_filter(['id' => $this->id, 'parent_id' => $this->parentId, 'trace_id' => $this->traceId ?? null, 'name' => $this->name, 'start_time' => $this->startTime ?? null, 'end_time' => $this->endTime ?? null, 'subsegments' => $this->subsegments ?? null ?: null, 'type' => $this->independent ? 'subsegment' : null, 'fault' => $this->fault ?? null, 'error' => $this->error ?? null, 'annotations' => $this->annotations ?? null ?: null, 'metadata' => $this->metadata ?? null ?: null]);\n    }\n}","mutatedSourceCode":"<?php\n\nnamespace Fido\\PHPXray;\n\nuse JsonSerializable;\nuse Fido\\PHPXray\\Submission\\SegmentSubmitter;\nclass Segment implements JsonSerializable\n{\n    protected string $id;\n    protected ?string $parentId = null;\n    protected string $traceId;\n    protected ?string $name = null;\n    protected float $startTime;\n    protected float $endTime;\n    \/** @var Segment[] *\/\n    protected array $subsegments = [];\n    protected bool $error = false;\n    protected bool $fault = false;\n    protected bool $sampled = false;\n    protected bool $independent = false;\n    \/** @var array<string, mixed> *\/\n    private array $annotations;\n    \/** @var array<string, mixed> *\/\n    private array $metadata;\n    private int $lastOpenSegment = 0;\n    \/**\n     * @throws \\Exception if an appropriate source of randomness cannot be found.\n     *\/\n    public function __construct()\n    {\n        $this->id = bin2hex(random_bytes(8));\n    }\n    public function setTraceHeader(string $traceHeader = null) : self\n    {\n        if (is_null($traceHeader)) {\n            return $this;\n        }\n        $parts = explode(';', $traceHeader);\n        $variables = array_map(function ($str) : array {\n            return explode('=', $str);\n        }, $parts);\n        $variables = array_column($variables, 1, 0);\n        if (isset($variables['Root'])) {\n            $this->setTraceId($variables['Root']);\n        }\n        if (isset($variables['Sampled'])) {\n            $this->setSampled((bool) $variables['Sampled'] ?? false);\n        }\n        if (isset($variables['Parent'])) {\n            $this->setParentId($variables['Parent'] ?? null);\n        }\n        return $this;\n    }\n    public function begin() : self\n    {\n        $this->startTime = microtime(true);\n        return $this;\n    }\n    public function end() : self\n    {\n        $this->endTime = microtime(true);\n        return $this;\n    }\n    public function setName(string $name) : self\n    {\n        $this->name = $name;\n        return $this;\n    }\n    public function setError(bool $error) : self\n    {\n        $this->error = $error;\n        return $this;\n    }\n    public function setFault(bool $fault) : self\n    {\n        $this->fault = $fault;\n        return $this;\n    }\n    public function addSubsegment(Segment $subsegment) : self\n    {\n        if (!$this->isOpen()) {\n            return $this;\n        }\n        $this->subsegments[] = $subsegment;\n        \n        return $this;\n    }\n    public function submit(SegmentSubmitter $submitter) : void\n    {\n        if (!$this->isSampled()) {\n            return;\n        }\n        $submitter->submitSegment($this);\n    }\n    public function isSampled() : bool\n    {\n        return $this->sampled;\n    }\n    public function setSampled(bool $sampled) : self\n    {\n        $this->sampled = $sampled;\n        return $this;\n    }\n    public function getId() : string\n    {\n        return $this->id;\n    }\n    public function setParentId(?string $parentId) : self\n    {\n        $this->parentId = $parentId;\n        return $this;\n    }\n    public function setTraceId(string $traceId) : self\n    {\n        $this->traceId = $traceId;\n        return $this;\n    }\n    public function getTraceId() : string\n    {\n        return $this->traceId;\n    }\n    public function isOpen() : bool\n    {\n        return isset($this->startTime) && !isset($this->endTime);\n    }\n    public function setIndependent(bool $independent) : self\n    {\n        $this->independent = $independent;\n        return $this;\n    }\n    public function addAnnotation(string $key, string $value) : self\n    {\n        $this->annotations[$key] = $value;\n        return $this;\n    }\n    public function addMetadata(string $key, mixed $value) : self\n    {\n        $this->metadata[$key] = $value;\n        return $this;\n    }\n    public function getCurrentSegment() : self\n    {\n        for ($max = count($this->subsegments); $this->lastOpenSegment < $max; $this->lastOpenSegment++) {\n            if ($this->subsegments[$this->lastOpenSegment]->isOpen()) {\n                return $this->subsegments[$this->lastOpenSegment]->getCurrentSegment();\n            }\n        }\n        return $this;\n    }\n    \/**\n     * @inheritDoc\n     * @return array<string, mixed>\n     *\/\n    public function jsonSerialize() : array\n    {\n        return array_filter(['id' => $this->id, 'parent_id' => $this->parentId, 'trace_id' => $this->traceId ?? null, 'name' => $this->name, 'start_time' => $this->startTime ?? null, 'end_time' => $this->endTime ?? null, 'subsegments' => $this->subsegments ?? null ?: null, 'type' => $this->independent ? 'subsegment' : null, 'fault' => $this->fault ?? null, 'error' => $this->error ?? null, 'annotations' => $this->annotations ?? null ?: null, 'metadata' => $this->metadata ?? null ?: null]);\n    }\n}","originalFilePath":"\/home\/ranpafin\/php-xray\/src\/Segment.php","originalStartLine":105},"diff":"--- Original\n+++ New\n@@ @@\n             return $this;\n         }\n         $this->subsegments[] = $subsegment;\n-        $subsegment->setSampled($this->isSampled());\n+        \n         return $this;\n     }\n     public function submit(SegmentSubmitter $submitter) : void","processOutput":"PHPUnit 9.5.10 by Sebastian Bergmann and contributors.\n\nRuntime:       PHP 8.0.13\nConfiguration: \/tmp\/tmp-folder\/infection\/phpunitConfiguration.8902d999a29554dfcd6b3aab6111b724.infection.xml\n\nE\n\nTime: 00:00.003, Memory: 8.00 MB\n\nThere was 1 error:\n\n1) Fido\\PHPXray\\DaemonSegmentSubmitterTest::testSubmitsToDaemon\nsocket_bind(): Unable to bind address [98]: Address already in use\n\n\/home\/ranpafin\/php-xray\/tests\/DaemonSegmentSubmitterTest.php:18\n\nERRORS!\nTests: 1, Assertions: 0, Errors: 1."},{"mutator":{"mutatorName":"PublicVisibility","originalSourceCode":"<?php\n\nnamespace Fido\\PHPXray;\n\nuse JsonSerializable;\nuse Fido\\PHPXray\\Submission\\SegmentSubmitter;\nclass Segment implements JsonSerializable\n{\n    protected string $id;\n    protected ?string $parentId = null;\n    protected string $traceId;\n    protected ?string $name = null;\n    protected float $startTime;\n    protected float $endTime;\n    \/** @var Segment[] *\/\n    protected array $subsegments = [];\n    protected bool $error = false;\n    protected bool $fault = false;\n    protected bool $sampled = false;\n    protected bool $independent = false;\n    \/** @var array<string, mixed> *\/\n    private array $annotations;\n    \/** @var array<string, mixed> *\/\n    private array $metadata;\n    private int $lastOpenSegment = 0;\n    \/**\n     * @throws \\Exception if an appropriate source of randomness cannot be found.\n     *\/\n    public function __construct()\n    {\n        $this->id = bin2hex(random_bytes(8));\n    }\n    public function setTraceHeader(string $traceHeader = null) : self\n    {\n        if (is_null($traceHeader)) {\n            return $this;\n        }\n        $parts = explode(';', $traceHeader);\n        $variables = array_map(function ($str) : array {\n            return explode('=', $str);\n        }, $parts);\n        $variables = array_column($variables, 1, 0);\n        if (isset($variables['Root'])) {\n            $this->setTraceId($variables['Root']);\n        }\n        if (isset($variables['Sampled'])) {\n            $this->setSampled((bool) $variables['Sampled'] ?? false);\n        }\n        if (isset($variables['Parent'])) {\n            $this->setParentId($variables['Parent'] ?? null);\n        }\n        return $this;\n    }\n    public function begin() : self\n    {\n        $this->startTime = microtime(true);\n        return $this;\n    }\n    public function end() : self\n    {\n        $this->endTime = microtime(true);\n        return $this;\n    }\n    public function setName(string $name) : self\n    {\n        $this->name = $name;\n        return $this;\n    }\n    public function setError(bool $error) : self\n    {\n        $this->error = $error;\n        return $this;\n    }\n    public function setFault(bool $fault) : self\n    {\n        $this->fault = $fault;\n        return $this;\n    }\n    public function addSubsegment(Segment $subsegment) : self\n    {\n        if (!$this->isOpen()) {\n            return $this;\n        }\n        $this->subsegments[] = $subsegment;\n        $subsegment->setSampled($this->isSampled());\n        return $this;\n    }\n    public function submit(SegmentSubmitter $submitter) : void\n    {\n        if (!$this->isSampled()) {\n            return;\n        }\n        $submitter->submitSegment($this);\n    }\n    public function isSampled() : bool\n    {\n        return $this->sampled;\n    }\n    public function setSampled(bool $sampled) : self\n    {\n        $this->sampled = $sampled;\n        return $this;\n    }\n    public function getId() : string\n    {\n        return $this->id;\n    }\n    public function setParentId(?string $parentId) : self\n    {\n        $this->parentId = $parentId;\n        return $this;\n    }\n    public function setTraceId(string $traceId) : self\n    {\n        $this->traceId = $traceId;\n        return $this;\n    }\n    public function getTraceId() : string\n    {\n        return $this->traceId;\n    }\n    public function isOpen() : bool\n    {\n        return isset($this->startTime) && !isset($this->endTime);\n    }\n    public function setIndependent(bool $independent) : self\n    {\n        $this->independent = $independent;\n        return $this;\n    }\n    public function addAnnotation(string $key, string $value) : self\n    {\n        $this->annotations[$key] = $value;\n        return $this;\n    }\n    public function addMetadata(string $key, mixed $value) : self\n    {\n        $this->metadata[$key] = $value;\n        return $this;\n    }\n    public function getCurrentSegment() : self\n    {\n        for ($max = count($this->subsegments); $this->lastOpenSegment < $max; $this->lastOpenSegment++) {\n            if ($this->subsegments[$this->lastOpenSegment]->isOpen()) {\n                return $this->subsegments[$this->lastOpenSegment]->getCurrentSegment();\n            }\n        }\n        return $this;\n    }\n    \/**\n     * @inheritDoc\n     * @return array<string, mixed>\n     *\/\n    public function jsonSerialize() : array\n    {\n        return array_filter(['id' => $this->id, 'parent_id' => $this->parentId, 'trace_id' => $this->traceId ?? null, 'name' => $this->name, 'start_time' => $this->startTime ?? null, 'end_time' => $this->endTime ?? null, 'subsegments' => $this->subsegments ?? null ?: null, 'type' => $this->independent ? 'subsegment' : null, 'fault' => $this->fault ?? null, 'error' => $this->error ?? null, 'annotations' => $this->annotations ?? null ?: null, 'metadata' => $this->metadata ?? null ?: null]);\n    }\n}","mutatedSourceCode":"<?php\n\nnamespace Fido\\PHPXray;\n\nuse JsonSerializable;\nuse Fido\\PHPXray\\Submission\\SegmentSubmitter;\nclass Segment implements JsonSerializable\n{\n    protected string $id;\n    protected ?string $parentId = null;\n    protected string $traceId;\n    protected ?string $name = null;\n    protected float $startTime;\n    protected float $endTime;\n    \/** @var Segment[] *\/\n    protected array $subsegments = [];\n    protected bool $error = false;\n    protected bool $fault = false;\n    protected bool $sampled = false;\n    protected bool $independent = false;\n    \/** @var array<string, mixed> *\/\n    private array $annotations;\n    \/** @var array<string, mixed> *\/\n    private array $metadata;\n    private int $lastOpenSegment = 0;\n    \/**\n     * @throws \\Exception if an appropriate source of randomness cannot be found.\n     *\/\n    public function __construct()\n    {\n        $this->id = bin2hex(random_bytes(8));\n    }\n    public function setTraceHeader(string $traceHeader = null) : self\n    {\n        if (is_null($traceHeader)) {\n            return $this;\n        }\n        $parts = explode(';', $traceHeader);\n        $variables = array_map(function ($str) : array {\n            return explode('=', $str);\n        }, $parts);\n        $variables = array_column($variables, 1, 0);\n        if (isset($variables['Root'])) {\n            $this->setTraceId($variables['Root']);\n        }\n        if (isset($variables['Sampled'])) {\n            $this->setSampled((bool) $variables['Sampled'] ?? false);\n        }\n        if (isset($variables['Parent'])) {\n            $this->setParentId($variables['Parent'] ?? null);\n        }\n        return $this;\n    }\n    public function begin() : self\n    {\n        $this->startTime = microtime(true);\n        return $this;\n    }\n    public function end() : self\n    {\n        $this->endTime = microtime(true);\n        return $this;\n    }\n    public function setName(string $name) : self\n    {\n        $this->name = $name;\n        return $this;\n    }\n    public function setError(bool $error) : self\n    {\n        $this->error = $error;\n        return $this;\n    }\n    public function setFault(bool $fault) : self\n    {\n        $this->fault = $fault;\n        return $this;\n    }\n    public function addSubsegment(Segment $subsegment) : self\n    {\n        if (!$this->isOpen()) {\n            return $this;\n        }\n        $this->subsegments[] = $subsegment;\n        $subsegment->setSampled($this->isSampled());\n        return $this;\n    }\n    protected function submit(SegmentSubmitter $submitter) : void\n    {\n        if (!$this->isSampled()) {\n            return;\n        }\n        $submitter->submitSegment($this);\n    }\n    public function isSampled() : bool\n    {\n        return $this->sampled;\n    }\n    public function setSampled(bool $sampled) : self\n    {\n        $this->sampled = $sampled;\n        return $this;\n    }\n    public function getId() : string\n    {\n        return $this->id;\n    }\n    public function setParentId(?string $parentId) : self\n    {\n        $this->parentId = $parentId;\n        return $this;\n    }\n    public function setTraceId(string $traceId) : self\n    {\n        $this->traceId = $traceId;\n        return $this;\n    }\n    public function getTraceId() : string\n    {\n        return $this->traceId;\n    }\n    public function isOpen() : bool\n    {\n        return isset($this->startTime) && !isset($this->endTime);\n    }\n    public function setIndependent(bool $independent) : self\n    {\n        $this->independent = $independent;\n        return $this;\n    }\n    public function addAnnotation(string $key, string $value) : self\n    {\n        $this->annotations[$key] = $value;\n        return $this;\n    }\n    public function addMetadata(string $key, mixed $value) : self\n    {\n        $this->metadata[$key] = $value;\n        return $this;\n    }\n    public function getCurrentSegment() : self\n    {\n        for ($max = count($this->subsegments); $this->lastOpenSegment < $max; $this->lastOpenSegment++) {\n            if ($this->subsegments[$this->lastOpenSegment]->isOpen()) {\n                return $this->subsegments[$this->lastOpenSegment]->getCurrentSegment();\n            }\n        }\n        return $this;\n    }\n    \/**\n     * @inheritDoc\n     * @return array<string, mixed>\n     *\/\n    public function jsonSerialize() : array\n    {\n        return array_filter(['id' => $this->id, 'parent_id' => $this->parentId, 'trace_id' => $this->traceId ?? null, 'name' => $this->name, 'start_time' => $this->startTime ?? null, 'end_time' => $this->endTime ?? null, 'subsegments' => $this->subsegments ?? null ?: null, 'type' => $this->independent ? 'subsegment' : null, 'fault' => $this->fault ?? null, 'error' => $this->error ?? null, 'annotations' => $this->annotations ?? null ?: null, 'metadata' => $this->metadata ?? null ?: null]);\n    }\n}","originalFilePath":"\/home\/ranpafin\/php-xray\/src\/Segment.php","originalStartLine":110},"diff":"--- Original\n+++ New\n@@ @@\n         $subsegment->setSampled($this->isSampled());\n         return $this;\n     }\n-    public function submit(SegmentSubmitter $submitter) : void\n+    protected function submit(SegmentSubmitter $submitter) : void\n     {\n         if (!$this->isSampled()) {\n             return;","processOutput":"PHPUnit 9.5.10 by Sebastian Bergmann and contributors.\n\nRuntime:       PHP 8.0.13\nConfiguration: \/tmp\/tmp-folder\/infection\/phpunitConfiguration.7d055ee396f438753ef0636f136fa5f2.infection.xml\n\nE\n\nTime: 00:00.003, Memory: 8.00 MB\n\nThere was 1 error:\n\n1) Fido\\PHPXray\\DaemonSegmentSubmitterTest::testSubmitsToDaemon\nsocket_bind(): Unable to bind address [98]: Address already in use\n\n\/home\/ranpafin\/php-xray\/tests\/DaemonSegmentSubmitterTest.php:18\n\nERRORS!\nTests: 1, Assertions: 0, Errors: 1."},{"mutator":{"mutatorName":"LogicalNot","originalSourceCode":"<?php\n\nnamespace Fido\\PHPXray;\n\nuse JsonSerializable;\nuse Fido\\PHPXray\\Submission\\SegmentSubmitter;\nclass Segment implements JsonSerializable\n{\n    protected string $id;\n    protected ?string $parentId = null;\n    protected string $traceId;\n    protected ?string $name = null;\n    protected float $startTime;\n    protected float $endTime;\n    \/** @var Segment[] *\/\n    protected array $subsegments = [];\n    protected bool $error = false;\n    protected bool $fault = false;\n    protected bool $sampled = false;\n    protected bool $independent = false;\n    \/** @var array<string, mixed> *\/\n    private array $annotations;\n    \/** @var array<string, mixed> *\/\n    private array $metadata;\n    private int $lastOpenSegment = 0;\n    \/**\n     * @throws \\Exception if an appropriate source of randomness cannot be found.\n     *\/\n    public function __construct()\n    {\n        $this->id = bin2hex(random_bytes(8));\n    }\n    public function setTraceHeader(string $traceHeader = null) : self\n    {\n        if (is_null($traceHeader)) {\n            return $this;\n        }\n        $parts = explode(';', $traceHeader);\n        $variables = array_map(function ($str) : array {\n            return explode('=', $str);\n        }, $parts);\n        $variables = array_column($variables, 1, 0);\n        if (isset($variables['Root'])) {\n            $this->setTraceId($variables['Root']);\n        }\n        if (isset($variables['Sampled'])) {\n            $this->setSampled((bool) $variables['Sampled'] ?? false);\n        }\n        if (isset($variables['Parent'])) {\n            $this->setParentId($variables['Parent'] ?? null);\n        }\n        return $this;\n    }\n    public function begin() : self\n    {\n        $this->startTime = microtime(true);\n        return $this;\n    }\n    public function end() : self\n    {\n        $this->endTime = microtime(true);\n        return $this;\n    }\n    public function setName(string $name) : self\n    {\n        $this->name = $name;\n        return $this;\n    }\n    public function setError(bool $error) : self\n    {\n        $this->error = $error;\n        return $this;\n    }\n    public function setFault(bool $fault) : self\n    {\n        $this->fault = $fault;\n        return $this;\n    }\n    public function addSubsegment(Segment $subsegment) : self\n    {\n        if (!$this->isOpen()) {\n            return $this;\n        }\n        $this->subsegments[] = $subsegment;\n        $subsegment->setSampled($this->isSampled());\n        return $this;\n    }\n    public function submit(SegmentSubmitter $submitter) : void\n    {\n        if (!$this->isSampled()) {\n            return;\n        }\n        $submitter->submitSegment($this);\n    }\n    public function isSampled() : bool\n    {\n        return $this->sampled;\n    }\n    public function setSampled(bool $sampled) : self\n    {\n        $this->sampled = $sampled;\n        return $this;\n    }\n    public function getId() : string\n    {\n        return $this->id;\n    }\n    public function setParentId(?string $parentId) : self\n    {\n        $this->parentId = $parentId;\n        return $this;\n    }\n    public function setTraceId(string $traceId) : self\n    {\n        $this->traceId = $traceId;\n        return $this;\n    }\n    public function getTraceId() : string\n    {\n        return $this->traceId;\n    }\n    public function isOpen() : bool\n    {\n        return isset($this->startTime) && !isset($this->endTime);\n    }\n    public function setIndependent(bool $independent) : self\n    {\n        $this->independent = $independent;\n        return $this;\n    }\n    public function addAnnotation(string $key, string $value) : self\n    {\n        $this->annotations[$key] = $value;\n        return $this;\n    }\n    public function addMetadata(string $key, mixed $value) : self\n    {\n        $this->metadata[$key] = $value;\n        return $this;\n    }\n    public function getCurrentSegment() : self\n    {\n        for ($max = count($this->subsegments); $this->lastOpenSegment < $max; $this->lastOpenSegment++) {\n            if ($this->subsegments[$this->lastOpenSegment]->isOpen()) {\n                return $this->subsegments[$this->lastOpenSegment]->getCurrentSegment();\n            }\n        }\n        return $this;\n    }\n    \/**\n     * @inheritDoc\n     * @return array<string, mixed>\n     *\/\n    public function jsonSerialize() : array\n    {\n        return array_filter(['id' => $this->id, 'parent_id' => $this->parentId, 'trace_id' => $this->traceId ?? null, 'name' => $this->name, 'start_time' => $this->startTime ?? null, 'end_time' => $this->endTime ?? null, 'subsegments' => $this->subsegments ?? null ?: null, 'type' => $this->independent ? 'subsegment' : null, 'fault' => $this->fault ?? null, 'error' => $this->error ?? null, 'annotations' => $this->annotations ?? null ?: null, 'metadata' => $this->metadata ?? null ?: null]);\n    }\n}","mutatedSourceCode":"<?php\n\nnamespace Fido\\PHPXray;\n\nuse JsonSerializable;\nuse Fido\\PHPXray\\Submission\\SegmentSubmitter;\nclass Segment implements JsonSerializable\n{\n    protected string $id;\n    protected ?string $parentId = null;\n    protected string $traceId;\n    protected ?string $name = null;\n    protected float $startTime;\n    protected float $endTime;\n    \/** @var Segment[] *\/\n    protected array $subsegments = [];\n    protected bool $error = false;\n    protected bool $fault = false;\n    protected bool $sampled = false;\n    protected bool $independent = false;\n    \/** @var array<string, mixed> *\/\n    private array $annotations;\n    \/** @var array<string, mixed> *\/\n    private array $metadata;\n    private int $lastOpenSegment = 0;\n    \/**\n     * @throws \\Exception if an appropriate source of randomness cannot be found.\n     *\/\n    public function __construct()\n    {\n        $this->id = bin2hex(random_bytes(8));\n    }\n    public function setTraceHeader(string $traceHeader = null) : self\n    {\n        if (is_null($traceHeader)) {\n            return $this;\n        }\n        $parts = explode(';', $traceHeader);\n        $variables = array_map(function ($str) : array {\n            return explode('=', $str);\n        }, $parts);\n        $variables = array_column($variables, 1, 0);\n        if (isset($variables['Root'])) {\n            $this->setTraceId($variables['Root']);\n        }\n        if (isset($variables['Sampled'])) {\n            $this->setSampled((bool) $variables['Sampled'] ?? false);\n        }\n        if (isset($variables['Parent'])) {\n            $this->setParentId($variables['Parent'] ?? null);\n        }\n        return $this;\n    }\n    public function begin() : self\n    {\n        $this->startTime = microtime(true);\n        return $this;\n    }\n    public function end() : self\n    {\n        $this->endTime = microtime(true);\n        return $this;\n    }\n    public function setName(string $name) : self\n    {\n        $this->name = $name;\n        return $this;\n    }\n    public function setError(bool $error) : self\n    {\n        $this->error = $error;\n        return $this;\n    }\n    public function setFault(bool $fault) : self\n    {\n        $this->fault = $fault;\n        return $this;\n    }\n    public function addSubsegment(Segment $subsegment) : self\n    {\n        if (!$this->isOpen()) {\n            return $this;\n        }\n        $this->subsegments[] = $subsegment;\n        $subsegment->setSampled($this->isSampled());\n        return $this;\n    }\n    public function submit(SegmentSubmitter $submitter) : void\n    {\n        if ($this->isSampled()) {\n            return;\n        }\n        $submitter->submitSegment($this);\n    }\n    public function isSampled() : bool\n    {\n        return $this->sampled;\n    }\n    public function setSampled(bool $sampled) : self\n    {\n        $this->sampled = $sampled;\n        return $this;\n    }\n    public function getId() : string\n    {\n        return $this->id;\n    }\n    public function setParentId(?string $parentId) : self\n    {\n        $this->parentId = $parentId;\n        return $this;\n    }\n    public function setTraceId(string $traceId) : self\n    {\n        $this->traceId = $traceId;\n        return $this;\n    }\n    public function getTraceId() : string\n    {\n        return $this->traceId;\n    }\n    public function isOpen() : bool\n    {\n        return isset($this->startTime) && !isset($this->endTime);\n    }\n    public function setIndependent(bool $independent) : self\n    {\n        $this->independent = $independent;\n        return $this;\n    }\n    public function addAnnotation(string $key, string $value) : self\n    {\n        $this->annotations[$key] = $value;\n        return $this;\n    }\n    public function addMetadata(string $key, mixed $value) : self\n    {\n        $this->metadata[$key] = $value;\n        return $this;\n    }\n    public function getCurrentSegment() : self\n    {\n        for ($max = count($this->subsegments); $this->lastOpenSegment < $max; $this->lastOpenSegment++) {\n            if ($this->subsegments[$this->lastOpenSegment]->isOpen()) {\n                return $this->subsegments[$this->lastOpenSegment]->getCurrentSegment();\n            }\n        }\n        return $this;\n    }\n    \/**\n     * @inheritDoc\n     * @return array<string, mixed>\n     *\/\n    public function jsonSerialize() : array\n    {\n        return array_filter(['id' => $this->id, 'parent_id' => $this->parentId, 'trace_id' => $this->traceId ?? null, 'name' => $this->name, 'start_time' => $this->startTime ?? null, 'end_time' => $this->endTime ?? null, 'subsegments' => $this->subsegments ?? null ?: null, 'type' => $this->independent ? 'subsegment' : null, 'fault' => $this->fault ?? null, 'error' => $this->error ?? null, 'annotations' => $this->annotations ?? null ?: null, 'metadata' => $this->metadata ?? null ?: null]);\n    }\n}","originalFilePath":"\/home\/ranpafin\/php-xray\/src\/Segment.php","originalStartLine":112},"diff":"--- Original\n+++ New\n@@ @@\n     }\n     public function submit(SegmentSubmitter $submitter) : void\n     {\n-        if (!$this->isSampled()) {\n+        if ($this->isSampled()) {\n             return;\n         }\n         $submitter->submitSegment($this);","processOutput":"PHPUnit 9.5.10 by Sebastian Bergmann and contributors.\n\nRuntime:       PHP 8.0.13\nConfiguration: \/tmp\/tmp-folder\/infection\/phpunitConfiguration.44f050a82dfd51e590838fdd7310530e.infection.xml\n\nE\n\nTime: 00:00.004, Memory: 8.00 MB\n\nThere was 1 error:\n\n1) Fido\\PHPXray\\DaemonSegmentSubmitterTest::testSubmitsToDaemon\nsocket_bind(): Unable to bind address [98]: Address already in use\n\n\/home\/ranpafin\/php-xray\/tests\/DaemonSegmentSubmitterTest.php:18\n\nERRORS!\nTests: 1, Assertions: 0, Errors: 1."},{"mutator":{"mutatorName":"MethodCallRemoval","originalSourceCode":"<?php\n\nnamespace Fido\\PHPXray;\n\nuse JsonSerializable;\nuse Fido\\PHPXray\\Submission\\SegmentSubmitter;\nclass Segment implements JsonSerializable\n{\n    protected string $id;\n    protected ?string $parentId = null;\n    protected string $traceId;\n    protected ?string $name = null;\n    protected float $startTime;\n    protected float $endTime;\n    \/** @var Segment[] *\/\n    protected array $subsegments = [];\n    protected bool $error = false;\n    protected bool $fault = false;\n    protected bool $sampled = false;\n    protected bool $independent = false;\n    \/** @var array<string, mixed> *\/\n    private array $annotations;\n    \/** @var array<string, mixed> *\/\n    private array $metadata;\n    private int $lastOpenSegment = 0;\n    \/**\n     * @throws \\Exception if an appropriate source of randomness cannot be found.\n     *\/\n    public function __construct()\n    {\n        $this->id = bin2hex(random_bytes(8));\n    }\n    public function setTraceHeader(string $traceHeader = null) : self\n    {\n        if (is_null($traceHeader)) {\n            return $this;\n        }\n        $parts = explode(';', $traceHeader);\n        $variables = array_map(function ($str) : array {\n            return explode('=', $str);\n        }, $parts);\n        $variables = array_column($variables, 1, 0);\n        if (isset($variables['Root'])) {\n            $this->setTraceId($variables['Root']);\n        }\n        if (isset($variables['Sampled'])) {\n            $this->setSampled((bool) $variables['Sampled'] ?? false);\n        }\n        if (isset($variables['Parent'])) {\n            $this->setParentId($variables['Parent'] ?? null);\n        }\n        return $this;\n    }\n    public function begin() : self\n    {\n        $this->startTime = microtime(true);\n        return $this;\n    }\n    public function end() : self\n    {\n        $this->endTime = microtime(true);\n        return $this;\n    }\n    public function setName(string $name) : self\n    {\n        $this->name = $name;\n        return $this;\n    }\n    public function setError(bool $error) : self\n    {\n        $this->error = $error;\n        return $this;\n    }\n    public function setFault(bool $fault) : self\n    {\n        $this->fault = $fault;\n        return $this;\n    }\n    public function addSubsegment(Segment $subsegment) : self\n    {\n        if (!$this->isOpen()) {\n            return $this;\n        }\n        $this->subsegments[] = $subsegment;\n        $subsegment->setSampled($this->isSampled());\n        return $this;\n    }\n    public function submit(SegmentSubmitter $submitter) : void\n    {\n        if (!$this->isSampled()) {\n            return;\n        }\n        $submitter->submitSegment($this);\n    }\n    public function isSampled() : bool\n    {\n        return $this->sampled;\n    }\n    public function setSampled(bool $sampled) : self\n    {\n        $this->sampled = $sampled;\n        return $this;\n    }\n    public function getId() : string\n    {\n        return $this->id;\n    }\n    public function setParentId(?string $parentId) : self\n    {\n        $this->parentId = $parentId;\n        return $this;\n    }\n    public function setTraceId(string $traceId) : self\n    {\n        $this->traceId = $traceId;\n        return $this;\n    }\n    public function getTraceId() : string\n    {\n        return $this->traceId;\n    }\n    public function isOpen() : bool\n    {\n        return isset($this->startTime) && !isset($this->endTime);\n    }\n    public function setIndependent(bool $independent) : self\n    {\n        $this->independent = $independent;\n        return $this;\n    }\n    public function addAnnotation(string $key, string $value) : self\n    {\n        $this->annotations[$key] = $value;\n        return $this;\n    }\n    public function addMetadata(string $key, mixed $value) : self\n    {\n        $this->metadata[$key] = $value;\n        return $this;\n    }\n    public function getCurrentSegment() : self\n    {\n        for ($max = count($this->subsegments); $this->lastOpenSegment < $max; $this->lastOpenSegment++) {\n            if ($this->subsegments[$this->lastOpenSegment]->isOpen()) {\n                return $this->subsegments[$this->lastOpenSegment]->getCurrentSegment();\n            }\n        }\n        return $this;\n    }\n    \/**\n     * @inheritDoc\n     * @return array<string, mixed>\n     *\/\n    public function jsonSerialize() : array\n    {\n        return array_filter(['id' => $this->id, 'parent_id' => $this->parentId, 'trace_id' => $this->traceId ?? null, 'name' => $this->name, 'start_time' => $this->startTime ?? null, 'end_time' => $this->endTime ?? null, 'subsegments' => $this->subsegments ?? null ?: null, 'type' => $this->independent ? 'subsegment' : null, 'fault' => $this->fault ?? null, 'error' => $this->error ?? null, 'annotations' => $this->annotations ?? null ?: null, 'metadata' => $this->metadata ?? null ?: null]);\n    }\n}","mutatedSourceCode":"<?php\n\nnamespace Fido\\PHPXray;\n\nuse JsonSerializable;\nuse Fido\\PHPXray\\Submission\\SegmentSubmitter;\nclass Segment implements JsonSerializable\n{\n    protected string $id;\n    protected ?string $parentId = null;\n    protected string $traceId;\n    protected ?string $name = null;\n    protected float $startTime;\n    protected float $endTime;\n    \/** @var Segment[] *\/\n    protected array $subsegments = [];\n    protected bool $error = false;\n    protected bool $fault = false;\n    protected bool $sampled = false;\n    protected bool $independent = false;\n    \/** @var array<string, mixed> *\/\n    private array $annotations;\n    \/** @var array<string, mixed> *\/\n    private array $metadata;\n    private int $lastOpenSegment = 0;\n    \/**\n     * @throws \\Exception if an appropriate source of randomness cannot be found.\n     *\/\n    public function __construct()\n    {\n        $this->id = bin2hex(random_bytes(8));\n    }\n    public function setTraceHeader(string $traceHeader = null) : self\n    {\n        if (is_null($traceHeader)) {\n            return $this;\n        }\n        $parts = explode(';', $traceHeader);\n        $variables = array_map(function ($str) : array {\n            return explode('=', $str);\n        }, $parts);\n        $variables = array_column($variables, 1, 0);\n        if (isset($variables['Root'])) {\n            $this->setTraceId($variables['Root']);\n        }\n        if (isset($variables['Sampled'])) {\n            $this->setSampled((bool) $variables['Sampled'] ?? false);\n        }\n        if (isset($variables['Parent'])) {\n            $this->setParentId($variables['Parent'] ?? null);\n        }\n        return $this;\n    }\n    public function begin() : self\n    {\n        $this->startTime = microtime(true);\n        return $this;\n    }\n    public function end() : self\n    {\n        $this->endTime = microtime(true);\n        return $this;\n    }\n    public function setName(string $name) : self\n    {\n        $this->name = $name;\n        return $this;\n    }\n    public function setError(bool $error) : self\n    {\n        $this->error = $error;\n        return $this;\n    }\n    public function setFault(bool $fault) : self\n    {\n        $this->fault = $fault;\n        return $this;\n    }\n    public function addSubsegment(Segment $subsegment) : self\n    {\n        if (!$this->isOpen()) {\n            return $this;\n        }\n        $this->subsegments[] = $subsegment;\n        $subsegment->setSampled($this->isSampled());\n        return $this;\n    }\n    public function submit(SegmentSubmitter $submitter) : void\n    {\n        if (!$this->isSampled()) {\n            return;\n        }\n        \n    }\n    public function isSampled() : bool\n    {\n        return $this->sampled;\n    }\n    public function setSampled(bool $sampled) : self\n    {\n        $this->sampled = $sampled;\n        return $this;\n    }\n    public function getId() : string\n    {\n        return $this->id;\n    }\n    public function setParentId(?string $parentId) : self\n    {\n        $this->parentId = $parentId;\n        return $this;\n    }\n    public function setTraceId(string $traceId) : self\n    {\n        $this->traceId = $traceId;\n        return $this;\n    }\n    public function getTraceId() : string\n    {\n        return $this->traceId;\n    }\n    public function isOpen() : bool\n    {\n        return isset($this->startTime) && !isset($this->endTime);\n    }\n    public function setIndependent(bool $independent) : self\n    {\n        $this->independent = $independent;\n        return $this;\n    }\n    public function addAnnotation(string $key, string $value) : self\n    {\n        $this->annotations[$key] = $value;\n        return $this;\n    }\n    public function addMetadata(string $key, mixed $value) : self\n    {\n        $this->metadata[$key] = $value;\n        return $this;\n    }\n    public function getCurrentSegment() : self\n    {\n        for ($max = count($this->subsegments); $this->lastOpenSegment < $max; $this->lastOpenSegment++) {\n            if ($this->subsegments[$this->lastOpenSegment]->isOpen()) {\n                return $this->subsegments[$this->lastOpenSegment]->getCurrentSegment();\n            }\n        }\n        return $this;\n    }\n    \/**\n     * @inheritDoc\n     * @return array<string, mixed>\n     *\/\n    public function jsonSerialize() : array\n    {\n        return array_filter(['id' => $this->id, 'parent_id' => $this->parentId, 'trace_id' => $this->traceId ?? null, 'name' => $this->name, 'start_time' => $this->startTime ?? null, 'end_time' => $this->endTime ?? null, 'subsegments' => $this->subsegments ?? null ?: null, 'type' => $this->independent ? 'subsegment' : null, 'fault' => $this->fault ?? null, 'error' => $this->error ?? null, 'annotations' => $this->annotations ?? null ?: null, 'metadata' => $this->metadata ?? null ?: null]);\n    }\n}","originalFilePath":"\/home\/ranpafin\/php-xray\/src\/Segment.php","originalStartLine":116},"diff":"--- Original\n+++ New\n@@ @@\n         if (!$this->isSampled()) {\n             return;\n         }\n-        $submitter->submitSegment($this);\n+        \n     }\n     public function isSampled() : bool\n     {","processOutput":"PHPUnit 9.5.10 by Sebastian Bergmann and contributors.\n\nRuntime:       PHP 8.0.13\nConfiguration: \/tmp\/tmp-folder\/infection\/phpunitConfiguration.42c68d3cd5705c9b9882f7037cf498aa.infection.xml\n\nE\n\nTime: 00:00.002, Memory: 8.00 MB\n\nThere was 1 error:\n\n1) Fido\\PHPXray\\DaemonSegmentSubmitterTest::testSubmitsToDaemon\nsocket_bind(): Unable to bind address [98]: Address already in use\n\n\/home\/ranpafin\/php-xray\/tests\/DaemonSegmentSubmitterTest.php:18\n\nERRORS!\nTests: 1, Assertions: 0, Errors: 1."},{"mutator":{"mutatorName":"PublicVisibility","originalSourceCode":"<?php\n\nnamespace Fido\\PHPXray;\n\nuse JsonSerializable;\nuse Fido\\PHPXray\\Submission\\SegmentSubmitter;\nclass Segment implements JsonSerializable\n{\n    protected string $id;\n    protected ?string $parentId = null;\n    protected string $traceId;\n    protected ?string $name = null;\n    protected float $startTime;\n    protected float $endTime;\n    \/** @var Segment[] *\/\n    protected array $subsegments = [];\n    protected bool $error = false;\n    protected bool $fault = false;\n    protected bool $sampled = false;\n    protected bool $independent = false;\n    \/** @var array<string, mixed> *\/\n    private array $annotations;\n    \/** @var array<string, mixed> *\/\n    private array $metadata;\n    private int $lastOpenSegment = 0;\n    \/**\n     * @throws \\Exception if an appropriate source of randomness cannot be found.\n     *\/\n    public function __construct()\n    {\n        $this->id = bin2hex(random_bytes(8));\n    }\n    public function setTraceHeader(string $traceHeader = null) : self\n    {\n        if (is_null($traceHeader)) {\n            return $this;\n        }\n        $parts = explode(';', $traceHeader);\n        $variables = array_map(function ($str) : array {\n            return explode('=', $str);\n        }, $parts);\n        $variables = array_column($variables, 1, 0);\n        if (isset($variables['Root'])) {\n            $this->setTraceId($variables['Root']);\n        }\n        if (isset($variables['Sampled'])) {\n            $this->setSampled((bool) $variables['Sampled'] ?? false);\n        }\n        if (isset($variables['Parent'])) {\n            $this->setParentId($variables['Parent'] ?? null);\n        }\n        return $this;\n    }\n    public function begin() : self\n    {\n        $this->startTime = microtime(true);\n        return $this;\n    }\n    public function end() : self\n    {\n        $this->endTime = microtime(true);\n        return $this;\n    }\n    public function setName(string $name) : self\n    {\n        $this->name = $name;\n        return $this;\n    }\n    public function setError(bool $error) : self\n    {\n        $this->error = $error;\n        return $this;\n    }\n    public function setFault(bool $fault) : self\n    {\n        $this->fault = $fault;\n        return $this;\n    }\n    public function addSubsegment(Segment $subsegment) : self\n    {\n        if (!$this->isOpen()) {\n            return $this;\n        }\n        $this->subsegments[] = $subsegment;\n        $subsegment->setSampled($this->isSampled());\n        return $this;\n    }\n    public function submit(SegmentSubmitter $submitter) : void\n    {\n        if (!$this->isSampled()) {\n            return;\n        }\n        $submitter->submitSegment($this);\n    }\n    public function isSampled() : bool\n    {\n        return $this->sampled;\n    }\n    public function setSampled(bool $sampled) : self\n    {\n        $this->sampled = $sampled;\n        return $this;\n    }\n    public function getId() : string\n    {\n        return $this->id;\n    }\n    public function setParentId(?string $parentId) : self\n    {\n        $this->parentId = $parentId;\n        return $this;\n    }\n    public function setTraceId(string $traceId) : self\n    {\n        $this->traceId = $traceId;\n        return $this;\n    }\n    public function getTraceId() : string\n    {\n        return $this->traceId;\n    }\n    public function isOpen() : bool\n    {\n        return isset($this->startTime) && !isset($this->endTime);\n    }\n    public function setIndependent(bool $independent) : self\n    {\n        $this->independent = $independent;\n        return $this;\n    }\n    public function addAnnotation(string $key, string $value) : self\n    {\n        $this->annotations[$key] = $value;\n        return $this;\n    }\n    public function addMetadata(string $key, mixed $value) : self\n    {\n        $this->metadata[$key] = $value;\n        return $this;\n    }\n    public function getCurrentSegment() : self\n    {\n        for ($max = count($this->subsegments); $this->lastOpenSegment < $max; $this->lastOpenSegment++) {\n            if ($this->subsegments[$this->lastOpenSegment]->isOpen()) {\n                return $this->subsegments[$this->lastOpenSegment]->getCurrentSegment();\n            }\n        }\n        return $this;\n    }\n    \/**\n     * @inheritDoc\n     * @return array<string, mixed>\n     *\/\n    public function jsonSerialize() : array\n    {\n        return array_filter(['id' => $this->id, 'parent_id' => $this->parentId, 'trace_id' => $this->traceId ?? null, 'name' => $this->name, 'start_time' => $this->startTime ?? null, 'end_time' => $this->endTime ?? null, 'subsegments' => $this->subsegments ?? null ?: null, 'type' => $this->independent ? 'subsegment' : null, 'fault' => $this->fault ?? null, 'error' => $this->error ?? null, 'annotations' => $this->annotations ?? null ?: null, 'metadata' => $this->metadata ?? null ?: null]);\n    }\n}","mutatedSourceCode":"<?php\n\nnamespace Fido\\PHPXray;\n\nuse JsonSerializable;\nuse Fido\\PHPXray\\Submission\\SegmentSubmitter;\nclass Segment implements JsonSerializable\n{\n    protected string $id;\n    protected ?string $parentId = null;\n    protected string $traceId;\n    protected ?string $name = null;\n    protected float $startTime;\n    protected float $endTime;\n    \/** @var Segment[] *\/\n    protected array $subsegments = [];\n    protected bool $error = false;\n    protected bool $fault = false;\n    protected bool $sampled = false;\n    protected bool $independent = false;\n    \/** @var array<string, mixed> *\/\n    private array $annotations;\n    \/** @var array<string, mixed> *\/\n    private array $metadata;\n    private int $lastOpenSegment = 0;\n    \/**\n     * @throws \\Exception if an appropriate source of randomness cannot be found.\n     *\/\n    public function __construct()\n    {\n        $this->id = bin2hex(random_bytes(8));\n    }\n    public function setTraceHeader(string $traceHeader = null) : self\n    {\n        if (is_null($traceHeader)) {\n            return $this;\n        }\n        $parts = explode(';', $traceHeader);\n        $variables = array_map(function ($str) : array {\n            return explode('=', $str);\n        }, $parts);\n        $variables = array_column($variables, 1, 0);\n        if (isset($variables['Root'])) {\n            $this->setTraceId($variables['Root']);\n        }\n        if (isset($variables['Sampled'])) {\n            $this->setSampled((bool) $variables['Sampled'] ?? false);\n        }\n        if (isset($variables['Parent'])) {\n            $this->setParentId($variables['Parent'] ?? null);\n        }\n        return $this;\n    }\n    public function begin() : self\n    {\n        $this->startTime = microtime(true);\n        return $this;\n    }\n    public function end() : self\n    {\n        $this->endTime = microtime(true);\n        return $this;\n    }\n    public function setName(string $name) : self\n    {\n        $this->name = $name;\n        return $this;\n    }\n    public function setError(bool $error) : self\n    {\n        $this->error = $error;\n        return $this;\n    }\n    public function setFault(bool $fault) : self\n    {\n        $this->fault = $fault;\n        return $this;\n    }\n    public function addSubsegment(Segment $subsegment) : self\n    {\n        if (!$this->isOpen()) {\n            return $this;\n        }\n        $this->subsegments[] = $subsegment;\n        $subsegment->setSampled($this->isSampled());\n        return $this;\n    }\n    public function submit(SegmentSubmitter $submitter) : void\n    {\n        if (!$this->isSampled()) {\n            return;\n        }\n        $submitter->submitSegment($this);\n    }\n    protected function isSampled() : bool\n    {\n        return $this->sampled;\n    }\n    public function setSampled(bool $sampled) : self\n    {\n        $this->sampled = $sampled;\n        return $this;\n    }\n    public function getId() : string\n    {\n        return $this->id;\n    }\n    public function setParentId(?string $parentId) : self\n    {\n        $this->parentId = $parentId;\n        return $this;\n    }\n    public function setTraceId(string $traceId) : self\n    {\n        $this->traceId = $traceId;\n        return $this;\n    }\n    public function getTraceId() : string\n    {\n        return $this->traceId;\n    }\n    public function isOpen() : bool\n    {\n        return isset($this->startTime) && !isset($this->endTime);\n    }\n    public function setIndependent(bool $independent) : self\n    {\n        $this->independent = $independent;\n        return $this;\n    }\n    public function addAnnotation(string $key, string $value) : self\n    {\n        $this->annotations[$key] = $value;\n        return $this;\n    }\n    public function addMetadata(string $key, mixed $value) : self\n    {\n        $this->metadata[$key] = $value;\n        return $this;\n    }\n    public function getCurrentSegment() : self\n    {\n        for ($max = count($this->subsegments); $this->lastOpenSegment < $max; $this->lastOpenSegment++) {\n            if ($this->subsegments[$this->lastOpenSegment]->isOpen()) {\n                return $this->subsegments[$this->lastOpenSegment]->getCurrentSegment();\n            }\n        }\n        return $this;\n    }\n    \/**\n     * @inheritDoc\n     * @return array<string, mixed>\n     *\/\n    public function jsonSerialize() : array\n    {\n        return array_filter(['id' => $this->id, 'parent_id' => $this->parentId, 'trace_id' => $this->traceId ?? null, 'name' => $this->name, 'start_time' => $this->startTime ?? null, 'end_time' => $this->endTime ?? null, 'subsegments' => $this->subsegments ?? null ?: null, 'type' => $this->independent ? 'subsegment' : null, 'fault' => $this->fault ?? null, 'error' => $this->error ?? null, 'annotations' => $this->annotations ?? null ?: null, 'metadata' => $this->metadata ?? null ?: null]);\n    }\n}","originalFilePath":"\/home\/ranpafin\/php-xray\/src\/Segment.php","originalStartLine":119},"diff":"--- Original\n+++ New\n@@ @@\n         }\n         $submitter->submitSegment($this);\n     }\n-    public function isSampled() : bool\n+    protected function isSampled() : bool\n     {\n         return $this->sampled;\n     }","processOutput":"PHPUnit 9.5.10 by Sebastian Bergmann and contributors.\n\nRuntime:       PHP 8.0.13\nConfiguration: \/tmp\/tmp-folder\/infection\/phpunitConfiguration.8a11dbe26d32ca4b06e0f93707ed45de.infection.xml\n\nE\n\nTime: 00:00.003, Memory: 8.00 MB\n\nThere was 1 error:\n\n1) Fido\\PHPXray\\DaemonSegmentSubmitterTest::testSubmitsToDaemon\nsocket_bind(): Unable to bind address [98]: Address already in use\n\n\/home\/ranpafin\/php-xray\/tests\/DaemonSegmentSubmitterTest.php:18\n\nERRORS!\nTests: 1, Assertions: 0, Errors: 1."},{"mutator":{"mutatorName":"PublicVisibility","originalSourceCode":"<?php\n\nnamespace Fido\\PHPXray;\n\nuse JsonSerializable;\nuse Fido\\PHPXray\\Submission\\SegmentSubmitter;\nclass Segment implements JsonSerializable\n{\n    protected string $id;\n    protected ?string $parentId = null;\n    protected string $traceId;\n    protected ?string $name = null;\n    protected float $startTime;\n    protected float $endTime;\n    \/** @var Segment[] *\/\n    protected array $subsegments = [];\n    protected bool $error = false;\n    protected bool $fault = false;\n    protected bool $sampled = false;\n    protected bool $independent = false;\n    \/** @var array<string, mixed> *\/\n    private array $annotations;\n    \/** @var array<string, mixed> *\/\n    private array $metadata;\n    private int $lastOpenSegment = 0;\n    \/**\n     * @throws \\Exception if an appropriate source of randomness cannot be found.\n     *\/\n    public function __construct()\n    {\n        $this->id = bin2hex(random_bytes(8));\n    }\n    public function setTraceHeader(string $traceHeader = null) : self\n    {\n        if (is_null($traceHeader)) {\n            return $this;\n        }\n        $parts = explode(';', $traceHeader);\n        $variables = array_map(function ($str) : array {\n            return explode('=', $str);\n        }, $parts);\n        $variables = array_column($variables, 1, 0);\n        if (isset($variables['Root'])) {\n            $this->setTraceId($variables['Root']);\n        }\n        if (isset($variables['Sampled'])) {\n            $this->setSampled((bool) $variables['Sampled'] ?? false);\n        }\n        if (isset($variables['Parent'])) {\n            $this->setParentId($variables['Parent'] ?? null);\n        }\n        return $this;\n    }\n    public function begin() : self\n    {\n        $this->startTime = microtime(true);\n        return $this;\n    }\n    public function end() : self\n    {\n        $this->endTime = microtime(true);\n        return $this;\n    }\n    public function setName(string $name) : self\n    {\n        $this->name = $name;\n        return $this;\n    }\n    public function setError(bool $error) : self\n    {\n        $this->error = $error;\n        return $this;\n    }\n    public function setFault(bool $fault) : self\n    {\n        $this->fault = $fault;\n        return $this;\n    }\n    public function addSubsegment(Segment $subsegment) : self\n    {\n        if (!$this->isOpen()) {\n            return $this;\n        }\n        $this->subsegments[] = $subsegment;\n        $subsegment->setSampled($this->isSampled());\n        return $this;\n    }\n    public function submit(SegmentSubmitter $submitter) : void\n    {\n        if (!$this->isSampled()) {\n            return;\n        }\n        $submitter->submitSegment($this);\n    }\n    public function isSampled() : bool\n    {\n        return $this->sampled;\n    }\n    public function setSampled(bool $sampled) : self\n    {\n        $this->sampled = $sampled;\n        return $this;\n    }\n    public function getId() : string\n    {\n        return $this->id;\n    }\n    public function setParentId(?string $parentId) : self\n    {\n        $this->parentId = $parentId;\n        return $this;\n    }\n    public function setTraceId(string $traceId) : self\n    {\n        $this->traceId = $traceId;\n        return $this;\n    }\n    public function getTraceId() : string\n    {\n        return $this->traceId;\n    }\n    public function isOpen() : bool\n    {\n        return isset($this->startTime) && !isset($this->endTime);\n    }\n    public function setIndependent(bool $independent) : self\n    {\n        $this->independent = $independent;\n        return $this;\n    }\n    public function addAnnotation(string $key, string $value) : self\n    {\n        $this->annotations[$key] = $value;\n        return $this;\n    }\n    public function addMetadata(string $key, mixed $value) : self\n    {\n        $this->metadata[$key] = $value;\n        return $this;\n    }\n    public function getCurrentSegment() : self\n    {\n        for ($max = count($this->subsegments); $this->lastOpenSegment < $max; $this->lastOpenSegment++) {\n            if ($this->subsegments[$this->lastOpenSegment]->isOpen()) {\n                return $this->subsegments[$this->lastOpenSegment]->getCurrentSegment();\n            }\n        }\n        return $this;\n    }\n    \/**\n     * @inheritDoc\n     * @return array<string, mixed>\n     *\/\n    public function jsonSerialize() : array\n    {\n        return array_filter(['id' => $this->id, 'parent_id' => $this->parentId, 'trace_id' => $this->traceId ?? null, 'name' => $this->name, 'start_time' => $this->startTime ?? null, 'end_time' => $this->endTime ?? null, 'subsegments' => $this->subsegments ?? null ?: null, 'type' => $this->independent ? 'subsegment' : null, 'fault' => $this->fault ?? null, 'error' => $this->error ?? null, 'annotations' => $this->annotations ?? null ?: null, 'metadata' => $this->metadata ?? null ?: null]);\n    }\n}","mutatedSourceCode":"<?php\n\nnamespace Fido\\PHPXray;\n\nuse JsonSerializable;\nuse Fido\\PHPXray\\Submission\\SegmentSubmitter;\nclass Segment implements JsonSerializable\n{\n    protected string $id;\n    protected ?string $parentId = null;\n    protected string $traceId;\n    protected ?string $name = null;\n    protected float $startTime;\n    protected float $endTime;\n    \/** @var Segment[] *\/\n    protected array $subsegments = [];\n    protected bool $error = false;\n    protected bool $fault = false;\n    protected bool $sampled = false;\n    protected bool $independent = false;\n    \/** @var array<string, mixed> *\/\n    private array $annotations;\n    \/** @var array<string, mixed> *\/\n    private array $metadata;\n    private int $lastOpenSegment = 0;\n    \/**\n     * @throws \\Exception if an appropriate source of randomness cannot be found.\n     *\/\n    public function __construct()\n    {\n        $this->id = bin2hex(random_bytes(8));\n    }\n    public function setTraceHeader(string $traceHeader = null) : self\n    {\n        if (is_null($traceHeader)) {\n            return $this;\n        }\n        $parts = explode(';', $traceHeader);\n        $variables = array_map(function ($str) : array {\n            return explode('=', $str);\n        }, $parts);\n        $variables = array_column($variables, 1, 0);\n        if (isset($variables['Root'])) {\n            $this->setTraceId($variables['Root']);\n        }\n        if (isset($variables['Sampled'])) {\n            $this->setSampled((bool) $variables['Sampled'] ?? false);\n        }\n        if (isset($variables['Parent'])) {\n            $this->setParentId($variables['Parent'] ?? null);\n        }\n        return $this;\n    }\n    public function begin() : self\n    {\n        $this->startTime = microtime(true);\n        return $this;\n    }\n    public function end() : self\n    {\n        $this->endTime = microtime(true);\n        return $this;\n    }\n    public function setName(string $name) : self\n    {\n        $this->name = $name;\n        return $this;\n    }\n    public function setError(bool $error) : self\n    {\n        $this->error = $error;\n        return $this;\n    }\n    public function setFault(bool $fault) : self\n    {\n        $this->fault = $fault;\n        return $this;\n    }\n    public function addSubsegment(Segment $subsegment) : self\n    {\n        if (!$this->isOpen()) {\n            return $this;\n        }\n        $this->subsegments[] = $subsegment;\n        $subsegment->setSampled($this->isSampled());\n        return $this;\n    }\n    public function submit(SegmentSubmitter $submitter) : void\n    {\n        if (!$this->isSampled()) {\n            return;\n        }\n        $submitter->submitSegment($this);\n    }\n    public function isSampled() : bool\n    {\n        return $this->sampled;\n    }\n    protected function setSampled(bool $sampled) : self\n    {\n        $this->sampled = $sampled;\n        return $this;\n    }\n    public function getId() : string\n    {\n        return $this->id;\n    }\n    public function setParentId(?string $parentId) : self\n    {\n        $this->parentId = $parentId;\n        return $this;\n    }\n    public function setTraceId(string $traceId) : self\n    {\n        $this->traceId = $traceId;\n        return $this;\n    }\n    public function getTraceId() : string\n    {\n        return $this->traceId;\n    }\n    public function isOpen() : bool\n    {\n        return isset($this->startTime) && !isset($this->endTime);\n    }\n    public function setIndependent(bool $independent) : self\n    {\n        $this->independent = $independent;\n        return $this;\n    }\n    public function addAnnotation(string $key, string $value) : self\n    {\n        $this->annotations[$key] = $value;\n        return $this;\n    }\n    public function addMetadata(string $key, mixed $value) : self\n    {\n        $this->metadata[$key] = $value;\n        return $this;\n    }\n    public function getCurrentSegment() : self\n    {\n        for ($max = count($this->subsegments); $this->lastOpenSegment < $max; $this->lastOpenSegment++) {\n            if ($this->subsegments[$this->lastOpenSegment]->isOpen()) {\n                return $this->subsegments[$this->lastOpenSegment]->getCurrentSegment();\n            }\n        }\n        return $this;\n    }\n    \/**\n     * @inheritDoc\n     * @return array<string, mixed>\n     *\/\n    public function jsonSerialize() : array\n    {\n        return array_filter(['id' => $this->id, 'parent_id' => $this->parentId, 'trace_id' => $this->traceId ?? null, 'name' => $this->name, 'start_time' => $this->startTime ?? null, 'end_time' => $this->endTime ?? null, 'subsegments' => $this->subsegments ?? null ?: null, 'type' => $this->independent ? 'subsegment' : null, 'fault' => $this->fault ?? null, 'error' => $this->error ?? null, 'annotations' => $this->annotations ?? null ?: null, 'metadata' => $this->metadata ?? null ?: null]);\n    }\n}","originalFilePath":"\/home\/ranpafin\/php-xray\/src\/Segment.php","originalStartLine":124},"diff":"--- Original\n+++ New\n@@ @@\n     {\n         return $this->sampled;\n     }\n-    public function setSampled(bool $sampled) : self\n+    protected function setSampled(bool $sampled) : self\n     {\n         $this->sampled = $sampled;\n         return $this;","processOutput":"PHPUnit 9.5.10 by Sebastian Bergmann and contributors.\n\nRuntime:       PHP 8.0.13\nConfiguration: \/tmp\/tmp-folder\/infection\/phpunitConfiguration.6ef13f12dfe8dfff7c0b474fb26788ac.infection.xml\n\nE\n\nTime: 00:00.003, Memory: 8.00 MB\n\nThere was 1 error:\n\n1) Fido\\PHPXray\\DaemonSegmentSubmitterTest::testSubmitsToDaemon\nsocket_bind(): Unable to bind address [98]: Address already in use\n\n\/home\/ranpafin\/php-xray\/tests\/DaemonSegmentSubmitterTest.php:18\n\nERRORS!\nTests: 1, Assertions: 0, Errors: 1."},{"mutator":{"mutatorName":"PublicVisibility","originalSourceCode":"<?php\n\nnamespace Fido\\PHPXray;\n\nuse JsonSerializable;\nuse Fido\\PHPXray\\Submission\\SegmentSubmitter;\nclass Segment implements JsonSerializable\n{\n    protected string $id;\n    protected ?string $parentId = null;\n    protected string $traceId;\n    protected ?string $name = null;\n    protected float $startTime;\n    protected float $endTime;\n    \/** @var Segment[] *\/\n    protected array $subsegments = [];\n    protected bool $error = false;\n    protected bool $fault = false;\n    protected bool $sampled = false;\n    protected bool $independent = false;\n    \/** @var array<string, mixed> *\/\n    private array $annotations;\n    \/** @var array<string, mixed> *\/\n    private array $metadata;\n    private int $lastOpenSegment = 0;\n    \/**\n     * @throws \\Exception if an appropriate source of randomness cannot be found.\n     *\/\n    public function __construct()\n    {\n        $this->id = bin2hex(random_bytes(8));\n    }\n    public function setTraceHeader(string $traceHeader = null) : self\n    {\n        if (is_null($traceHeader)) {\n            return $this;\n        }\n        $parts = explode(';', $traceHeader);\n        $variables = array_map(function ($str) : array {\n            return explode('=', $str);\n        }, $parts);\n        $variables = array_column($variables, 1, 0);\n        if (isset($variables['Root'])) {\n            $this->setTraceId($variables['Root']);\n        }\n        if (isset($variables['Sampled'])) {\n            $this->setSampled((bool) $variables['Sampled'] ?? false);\n        }\n        if (isset($variables['Parent'])) {\n            $this->setParentId($variables['Parent'] ?? null);\n        }\n        return $this;\n    }\n    public function begin() : self\n    {\n        $this->startTime = microtime(true);\n        return $this;\n    }\n    public function end() : self\n    {\n        $this->endTime = microtime(true);\n        return $this;\n    }\n    public function setName(string $name) : self\n    {\n        $this->name = $name;\n        return $this;\n    }\n    public function setError(bool $error) : self\n    {\n        $this->error = $error;\n        return $this;\n    }\n    public function setFault(bool $fault) : self\n    {\n        $this->fault = $fault;\n        return $this;\n    }\n    public function addSubsegment(Segment $subsegment) : self\n    {\n        if (!$this->isOpen()) {\n            return $this;\n        }\n        $this->subsegments[] = $subsegment;\n        $subsegment->setSampled($this->isSampled());\n        return $this;\n    }\n    public function submit(SegmentSubmitter $submitter) : void\n    {\n        if (!$this->isSampled()) {\n            return;\n        }\n        $submitter->submitSegment($this);\n    }\n    public function isSampled() : bool\n    {\n        return $this->sampled;\n    }\n    public function setSampled(bool $sampled) : self\n    {\n        $this->sampled = $sampled;\n        return $this;\n    }\n    public function getId() : string\n    {\n        return $this->id;\n    }\n    public function setParentId(?string $parentId) : self\n    {\n        $this->parentId = $parentId;\n        return $this;\n    }\n    public function setTraceId(string $traceId) : self\n    {\n        $this->traceId = $traceId;\n        return $this;\n    }\n    public function getTraceId() : string\n    {\n        return $this->traceId;\n    }\n    public function isOpen() : bool\n    {\n        return isset($this->startTime) && !isset($this->endTime);\n    }\n    public function setIndependent(bool $independent) : self\n    {\n        $this->independent = $independent;\n        return $this;\n    }\n    public function addAnnotation(string $key, string $value) : self\n    {\n        $this->annotations[$key] = $value;\n        return $this;\n    }\n    public function addMetadata(string $key, mixed $value) : self\n    {\n        $this->metadata[$key] = $value;\n        return $this;\n    }\n    public function getCurrentSegment() : self\n    {\n        for ($max = count($this->subsegments); $this->lastOpenSegment < $max; $this->lastOpenSegment++) {\n            if ($this->subsegments[$this->lastOpenSegment]->isOpen()) {\n                return $this->subsegments[$this->lastOpenSegment]->getCurrentSegment();\n            }\n        }\n        return $this;\n    }\n    \/**\n     * @inheritDoc\n     * @return array<string, mixed>\n     *\/\n    public function jsonSerialize() : array\n    {\n        return array_filter(['id' => $this->id, 'parent_id' => $this->parentId, 'trace_id' => $this->traceId ?? null, 'name' => $this->name, 'start_time' => $this->startTime ?? null, 'end_time' => $this->endTime ?? null, 'subsegments' => $this->subsegments ?? null ?: null, 'type' => $this->independent ? 'subsegment' : null, 'fault' => $this->fault ?? null, 'error' => $this->error ?? null, 'annotations' => $this->annotations ?? null ?: null, 'metadata' => $this->metadata ?? null ?: null]);\n    }\n}","mutatedSourceCode":"<?php\n\nnamespace Fido\\PHPXray;\n\nuse JsonSerializable;\nuse Fido\\PHPXray\\Submission\\SegmentSubmitter;\nclass Segment implements JsonSerializable\n{\n    protected string $id;\n    protected ?string $parentId = null;\n    protected string $traceId;\n    protected ?string $name = null;\n    protected float $startTime;\n    protected float $endTime;\n    \/** @var Segment[] *\/\n    protected array $subsegments = [];\n    protected bool $error = false;\n    protected bool $fault = false;\n    protected bool $sampled = false;\n    protected bool $independent = false;\n    \/** @var array<string, mixed> *\/\n    private array $annotations;\n    \/** @var array<string, mixed> *\/\n    private array $metadata;\n    private int $lastOpenSegment = 0;\n    \/**\n     * @throws \\Exception if an appropriate source of randomness cannot be found.\n     *\/\n    public function __construct()\n    {\n        $this->id = bin2hex(random_bytes(8));\n    }\n    public function setTraceHeader(string $traceHeader = null) : self\n    {\n        if (is_null($traceHeader)) {\n            return $this;\n        }\n        $parts = explode(';', $traceHeader);\n        $variables = array_map(function ($str) : array {\n            return explode('=', $str);\n        }, $parts);\n        $variables = array_column($variables, 1, 0);\n        if (isset($variables['Root'])) {\n            $this->setTraceId($variables['Root']);\n        }\n        if (isset($variables['Sampled'])) {\n            $this->setSampled((bool) $variables['Sampled'] ?? false);\n        }\n        if (isset($variables['Parent'])) {\n            $this->setParentId($variables['Parent'] ?? null);\n        }\n        return $this;\n    }\n    public function begin() : self\n    {\n        $this->startTime = microtime(true);\n        return $this;\n    }\n    public function end() : self\n    {\n        $this->endTime = microtime(true);\n        return $this;\n    }\n    public function setName(string $name) : self\n    {\n        $this->name = $name;\n        return $this;\n    }\n    public function setError(bool $error) : self\n    {\n        $this->error = $error;\n        return $this;\n    }\n    public function setFault(bool $fault) : self\n    {\n        $this->fault = $fault;\n        return $this;\n    }\n    public function addSubsegment(Segment $subsegment) : self\n    {\n        if (!$this->isOpen()) {\n            return $this;\n        }\n        $this->subsegments[] = $subsegment;\n        $subsegment->setSampled($this->isSampled());\n        return $this;\n    }\n    public function submit(SegmentSubmitter $submitter) : void\n    {\n        if (!$this->isSampled()) {\n            return;\n        }\n        $submitter->submitSegment($this);\n    }\n    public function isSampled() : bool\n    {\n        return $this->sampled;\n    }\n    public function setSampled(bool $sampled) : self\n    {\n        $this->sampled = $sampled;\n        return $this;\n    }\n    protected function getId() : string\n    {\n        return $this->id;\n    }\n    public function setParentId(?string $parentId) : self\n    {\n        $this->parentId = $parentId;\n        return $this;\n    }\n    public function setTraceId(string $traceId) : self\n    {\n        $this->traceId = $traceId;\n        return $this;\n    }\n    public function getTraceId() : string\n    {\n        return $this->traceId;\n    }\n    public function isOpen() : bool\n    {\n        return isset($this->startTime) && !isset($this->endTime);\n    }\n    public function setIndependent(bool $independent) : self\n    {\n        $this->independent = $independent;\n        return $this;\n    }\n    public function addAnnotation(string $key, string $value) : self\n    {\n        $this->annotations[$key] = $value;\n        return $this;\n    }\n    public function addMetadata(string $key, mixed $value) : self\n    {\n        $this->metadata[$key] = $value;\n        return $this;\n    }\n    public function getCurrentSegment() : self\n    {\n        for ($max = count($this->subsegments); $this->lastOpenSegment < $max; $this->lastOpenSegment++) {\n            if ($this->subsegments[$this->lastOpenSegment]->isOpen()) {\n                return $this->subsegments[$this->lastOpenSegment]->getCurrentSegment();\n            }\n        }\n        return $this;\n    }\n    \/**\n     * @inheritDoc\n     * @return array<string, mixed>\n     *\/\n    public function jsonSerialize() : array\n    {\n        return array_filter(['id' => $this->id, 'parent_id' => $this->parentId, 'trace_id' => $this->traceId ?? null, 'name' => $this->name, 'start_time' => $this->startTime ?? null, 'end_time' => $this->endTime ?? null, 'subsegments' => $this->subsegments ?? null ?: null, 'type' => $this->independent ? 'subsegment' : null, 'fault' => $this->fault ?? null, 'error' => $this->error ?? null, 'annotations' => $this->annotations ?? null ?: null, 'metadata' => $this->metadata ?? null ?: null]);\n    }\n}","originalFilePath":"\/home\/ranpafin\/php-xray\/src\/Segment.php","originalStartLine":131},"diff":"--- Original\n+++ New\n@@ @@\n         $this->sampled = $sampled;\n         return $this;\n     }\n-    public function getId() : string\n+    protected function getId() : string\n     {\n         return $this->id;\n     }","processOutput":"PHPUnit 9.5.10 by Sebastian Bergmann and contributors.\n\nRuntime:       PHP 8.0.13\nConfiguration: \/tmp\/tmp-folder\/infection\/phpunitConfiguration.0a6e0e1d2c0a67832705d5598c91a782.infection.xml\n\nE\n\nTime: 00:00.003, Memory: 8.00 MB\n\nThere was 1 error:\n\n1) Fido\\PHPXray\\DaemonSegmentSubmitterTest::testSubmitsToDaemon\nsocket_bind(): Unable to bind address [98]: Address already in use\n\n\/home\/ranpafin\/php-xray\/tests\/DaemonSegmentSubmitterTest.php:18\n\nERRORS!\nTests: 1, Assertions: 0, Errors: 1."},{"mutator":{"mutatorName":"PublicVisibility","originalSourceCode":"<?php\n\nnamespace Fido\\PHPXray;\n\nuse JsonSerializable;\nuse Fido\\PHPXray\\Submission\\SegmentSubmitter;\nclass Segment implements JsonSerializable\n{\n    protected string $id;\n    protected ?string $parentId = null;\n    protected string $traceId;\n    protected ?string $name = null;\n    protected float $startTime;\n    protected float $endTime;\n    \/** @var Segment[] *\/\n    protected array $subsegments = [];\n    protected bool $error = false;\n    protected bool $fault = false;\n    protected bool $sampled = false;\n    protected bool $independent = false;\n    \/** @var array<string, mixed> *\/\n    private array $annotations;\n    \/** @var array<string, mixed> *\/\n    private array $metadata;\n    private int $lastOpenSegment = 0;\n    \/**\n     * @throws \\Exception if an appropriate source of randomness cannot be found.\n     *\/\n    public function __construct()\n    {\n        $this->id = bin2hex(random_bytes(8));\n    }\n    public function setTraceHeader(string $traceHeader = null) : self\n    {\n        if (is_null($traceHeader)) {\n            return $this;\n        }\n        $parts = explode(';', $traceHeader);\n        $variables = array_map(function ($str) : array {\n            return explode('=', $str);\n        }, $parts);\n        $variables = array_column($variables, 1, 0);\n        if (isset($variables['Root'])) {\n            $this->setTraceId($variables['Root']);\n        }\n        if (isset($variables['Sampled'])) {\n            $this->setSampled((bool) $variables['Sampled'] ?? false);\n        }\n        if (isset($variables['Parent'])) {\n            $this->setParentId($variables['Parent'] ?? null);\n        }\n        return $this;\n    }\n    public function begin() : self\n    {\n        $this->startTime = microtime(true);\n        return $this;\n    }\n    public function end() : self\n    {\n        $this->endTime = microtime(true);\n        return $this;\n    }\n    public function setName(string $name) : self\n    {\n        $this->name = $name;\n        return $this;\n    }\n    public function setError(bool $error) : self\n    {\n        $this->error = $error;\n        return $this;\n    }\n    public function setFault(bool $fault) : self\n    {\n        $this->fault = $fault;\n        return $this;\n    }\n    public function addSubsegment(Segment $subsegment) : self\n    {\n        if (!$this->isOpen()) {\n            return $this;\n        }\n        $this->subsegments[] = $subsegment;\n        $subsegment->setSampled($this->isSampled());\n        return $this;\n    }\n    public function submit(SegmentSubmitter $submitter) : void\n    {\n        if (!$this->isSampled()) {\n            return;\n        }\n        $submitter->submitSegment($this);\n    }\n    public function isSampled() : bool\n    {\n        return $this->sampled;\n    }\n    public function setSampled(bool $sampled) : self\n    {\n        $this->sampled = $sampled;\n        return $this;\n    }\n    public function getId() : string\n    {\n        return $this->id;\n    }\n    public function setParentId(?string $parentId) : self\n    {\n        $this->parentId = $parentId;\n        return $this;\n    }\n    public function setTraceId(string $traceId) : self\n    {\n        $this->traceId = $traceId;\n        return $this;\n    }\n    public function getTraceId() : string\n    {\n        return $this->traceId;\n    }\n    public function isOpen() : bool\n    {\n        return isset($this->startTime) && !isset($this->endTime);\n    }\n    public function setIndependent(bool $independent) : self\n    {\n        $this->independent = $independent;\n        return $this;\n    }\n    public function addAnnotation(string $key, string $value) : self\n    {\n        $this->annotations[$key] = $value;\n        return $this;\n    }\n    public function addMetadata(string $key, mixed $value) : self\n    {\n        $this->metadata[$key] = $value;\n        return $this;\n    }\n    public function getCurrentSegment() : self\n    {\n        for ($max = count($this->subsegments); $this->lastOpenSegment < $max; $this->lastOpenSegment++) {\n            if ($this->subsegments[$this->lastOpenSegment]->isOpen()) {\n                return $this->subsegments[$this->lastOpenSegment]->getCurrentSegment();\n            }\n        }\n        return $this;\n    }\n    \/**\n     * @inheritDoc\n     * @return array<string, mixed>\n     *\/\n    public function jsonSerialize() : array\n    {\n        return array_filter(['id' => $this->id, 'parent_id' => $this->parentId, 'trace_id' => $this->traceId ?? null, 'name' => $this->name, 'start_time' => $this->startTime ?? null, 'end_time' => $this->endTime ?? null, 'subsegments' => $this->subsegments ?? null ?: null, 'type' => $this->independent ? 'subsegment' : null, 'fault' => $this->fault ?? null, 'error' => $this->error ?? null, 'annotations' => $this->annotations ?? null ?: null, 'metadata' => $this->metadata ?? null ?: null]);\n    }\n}","mutatedSourceCode":"<?php\n\nnamespace Fido\\PHPXray;\n\nuse JsonSerializable;\nuse Fido\\PHPXray\\Submission\\SegmentSubmitter;\nclass Segment implements JsonSerializable\n{\n    protected string $id;\n    protected ?string $parentId = null;\n    protected string $traceId;\n    protected ?string $name = null;\n    protected float $startTime;\n    protected float $endTime;\n    \/** @var Segment[] *\/\n    protected array $subsegments = [];\n    protected bool $error = false;\n    protected bool $fault = false;\n    protected bool $sampled = false;\n    protected bool $independent = false;\n    \/** @var array<string, mixed> *\/\n    private array $annotations;\n    \/** @var array<string, mixed> *\/\n    private array $metadata;\n    private int $lastOpenSegment = 0;\n    \/**\n     * @throws \\Exception if an appropriate source of randomness cannot be found.\n     *\/\n    public function __construct()\n    {\n        $this->id = bin2hex(random_bytes(8));\n    }\n    public function setTraceHeader(string $traceHeader = null) : self\n    {\n        if (is_null($traceHeader)) {\n            return $this;\n        }\n        $parts = explode(';', $traceHeader);\n        $variables = array_map(function ($str) : array {\n            return explode('=', $str);\n        }, $parts);\n        $variables = array_column($variables, 1, 0);\n        if (isset($variables['Root'])) {\n            $this->setTraceId($variables['Root']);\n        }\n        if (isset($variables['Sampled'])) {\n            $this->setSampled((bool) $variables['Sampled'] ?? false);\n        }\n        if (isset($variables['Parent'])) {\n            $this->setParentId($variables['Parent'] ?? null);\n        }\n        return $this;\n    }\n    public function begin() : self\n    {\n        $this->startTime = microtime(true);\n        return $this;\n    }\n    public function end() : self\n    {\n        $this->endTime = microtime(true);\n        return $this;\n    }\n    public function setName(string $name) : self\n    {\n        $this->name = $name;\n        return $this;\n    }\n    public function setError(bool $error) : self\n    {\n        $this->error = $error;\n        return $this;\n    }\n    public function setFault(bool $fault) : self\n    {\n        $this->fault = $fault;\n        return $this;\n    }\n    public function addSubsegment(Segment $subsegment) : self\n    {\n        if (!$this->isOpen()) {\n            return $this;\n        }\n        $this->subsegments[] = $subsegment;\n        $subsegment->setSampled($this->isSampled());\n        return $this;\n    }\n    public function submit(SegmentSubmitter $submitter) : void\n    {\n        if (!$this->isSampled()) {\n            return;\n        }\n        $submitter->submitSegment($this);\n    }\n    public function isSampled() : bool\n    {\n        return $this->sampled;\n    }\n    public function setSampled(bool $sampled) : self\n    {\n        $this->sampled = $sampled;\n        return $this;\n    }\n    public function getId() : string\n    {\n        return $this->id;\n    }\n    protected function setParentId(?string $parentId) : self\n    {\n        $this->parentId = $parentId;\n        return $this;\n    }\n    public function setTraceId(string $traceId) : self\n    {\n        $this->traceId = $traceId;\n        return $this;\n    }\n    public function getTraceId() : string\n    {\n        return $this->traceId;\n    }\n    public function isOpen() : bool\n    {\n        return isset($this->startTime) && !isset($this->endTime);\n    }\n    public function setIndependent(bool $independent) : self\n    {\n        $this->independent = $independent;\n        return $this;\n    }\n    public function addAnnotation(string $key, string $value) : self\n    {\n        $this->annotations[$key] = $value;\n        return $this;\n    }\n    public function addMetadata(string $key, mixed $value) : self\n    {\n        $this->metadata[$key] = $value;\n        return $this;\n    }\n    public function getCurrentSegment() : self\n    {\n        for ($max = count($this->subsegments); $this->lastOpenSegment < $max; $this->lastOpenSegment++) {\n            if ($this->subsegments[$this->lastOpenSegment]->isOpen()) {\n                return $this->subsegments[$this->lastOpenSegment]->getCurrentSegment();\n            }\n        }\n        return $this;\n    }\n    \/**\n     * @inheritDoc\n     * @return array<string, mixed>\n     *\/\n    public function jsonSerialize() : array\n    {\n        return array_filter(['id' => $this->id, 'parent_id' => $this->parentId, 'trace_id' => $this->traceId ?? null, 'name' => $this->name, 'start_time' => $this->startTime ?? null, 'end_time' => $this->endTime ?? null, 'subsegments' => $this->subsegments ?? null ?: null, 'type' => $this->independent ? 'subsegment' : null, 'fault' => $this->fault ?? null, 'error' => $this->error ?? null, 'annotations' => $this->annotations ?? null ?: null, 'metadata' => $this->metadata ?? null ?: null]);\n    }\n}","originalFilePath":"\/home\/ranpafin\/php-xray\/src\/Segment.php","originalStartLine":136},"diff":"--- Original\n+++ New\n@@ @@\n     {\n         return $this->id;\n     }\n-    public function setParentId(?string $parentId) : self\n+    protected function setParentId(?string $parentId) : self\n     {\n         $this->parentId = $parentId;\n         return $this;","processOutput":"PHPUnit 9.5.10 by Sebastian Bergmann and contributors.\n\nRuntime:       PHP 8.0.13\nConfiguration: \/tmp\/tmp-folder\/infection\/phpunitConfiguration.4a19f6fac023f61ccad1ac1b192a47a1.infection.xml\n\nE\n\nTime: 00:00.004, Memory: 8.00 MB\n\nThere was 1 error:\n\n1) Fido\\PHPXray\\DaemonSegmentSubmitterTest::testSubmitsToDaemon\nsocket_bind(): Unable to bind address [98]: Address already in use\n\n\/home\/ranpafin\/php-xray\/tests\/DaemonSegmentSubmitterTest.php:18\n\nERRORS!\nTests: 1, Assertions: 0, Errors: 1."},{"mutator":{"mutatorName":"PublicVisibility","originalSourceCode":"<?php\n\nnamespace Fido\\PHPXray;\n\nuse JsonSerializable;\nuse Fido\\PHPXray\\Submission\\SegmentSubmitter;\nclass Segment implements JsonSerializable\n{\n    protected string $id;\n    protected ?string $parentId = null;\n    protected string $traceId;\n    protected ?string $name = null;\n    protected float $startTime;\n    protected float $endTime;\n    \/** @var Segment[] *\/\n    protected array $subsegments = [];\n    protected bool $error = false;\n    protected bool $fault = false;\n    protected bool $sampled = false;\n    protected bool $independent = false;\n    \/** @var array<string, mixed> *\/\n    private array $annotations;\n    \/** @var array<string, mixed> *\/\n    private array $metadata;\n    private int $lastOpenSegment = 0;\n    \/**\n     * @throws \\Exception if an appropriate source of randomness cannot be found.\n     *\/\n    public function __construct()\n    {\n        $this->id = bin2hex(random_bytes(8));\n    }\n    public function setTraceHeader(string $traceHeader = null) : self\n    {\n        if (is_null($traceHeader)) {\n            return $this;\n        }\n        $parts = explode(';', $traceHeader);\n        $variables = array_map(function ($str) : array {\n            return explode('=', $str);\n        }, $parts);\n        $variables = array_column($variables, 1, 0);\n        if (isset($variables['Root'])) {\n            $this->setTraceId($variables['Root']);\n        }\n        if (isset($variables['Sampled'])) {\n            $this->setSampled((bool) $variables['Sampled'] ?? false);\n        }\n        if (isset($variables['Parent'])) {\n            $this->setParentId($variables['Parent'] ?? null);\n        }\n        return $this;\n    }\n    public function begin() : self\n    {\n        $this->startTime = microtime(true);\n        return $this;\n    }\n    public function end() : self\n    {\n        $this->endTime = microtime(true);\n        return $this;\n    }\n    public function setName(string $name) : self\n    {\n        $this->name = $name;\n        return $this;\n    }\n    public function setError(bool $error) : self\n    {\n        $this->error = $error;\n        return $this;\n    }\n    public function setFault(bool $fault) : self\n    {\n        $this->fault = $fault;\n        return $this;\n    }\n    public function addSubsegment(Segment $subsegment) : self\n    {\n        if (!$this->isOpen()) {\n            return $this;\n        }\n        $this->subsegments[] = $subsegment;\n        $subsegment->setSampled($this->isSampled());\n        return $this;\n    }\n    public function submit(SegmentSubmitter $submitter) : void\n    {\n        if (!$this->isSampled()) {\n            return;\n        }\n        $submitter->submitSegment($this);\n    }\n    public function isSampled() : bool\n    {\n        return $this->sampled;\n    }\n    public function setSampled(bool $sampled) : self\n    {\n        $this->sampled = $sampled;\n        return $this;\n    }\n    public function getId() : string\n    {\n        return $this->id;\n    }\n    public function setParentId(?string $parentId) : self\n    {\n        $this->parentId = $parentId;\n        return $this;\n    }\n    public function setTraceId(string $traceId) : self\n    {\n        $this->traceId = $traceId;\n        return $this;\n    }\n    public function getTraceId() : string\n    {\n        return $this->traceId;\n    }\n    public function isOpen() : bool\n    {\n        return isset($this->startTime) && !isset($this->endTime);\n    }\n    public function setIndependent(bool $independent) : self\n    {\n        $this->independent = $independent;\n        return $this;\n    }\n    public function addAnnotation(string $key, string $value) : self\n    {\n        $this->annotations[$key] = $value;\n        return $this;\n    }\n    public function addMetadata(string $key, mixed $value) : self\n    {\n        $this->metadata[$key] = $value;\n        return $this;\n    }\n    public function getCurrentSegment() : self\n    {\n        for ($max = count($this->subsegments); $this->lastOpenSegment < $max; $this->lastOpenSegment++) {\n            if ($this->subsegments[$this->lastOpenSegment]->isOpen()) {\n                return $this->subsegments[$this->lastOpenSegment]->getCurrentSegment();\n            }\n        }\n        return $this;\n    }\n    \/**\n     * @inheritDoc\n     * @return array<string, mixed>\n     *\/\n    public function jsonSerialize() : array\n    {\n        return array_filter(['id' => $this->id, 'parent_id' => $this->parentId, 'trace_id' => $this->traceId ?? null, 'name' => $this->name, 'start_time' => $this->startTime ?? null, 'end_time' => $this->endTime ?? null, 'subsegments' => $this->subsegments ?? null ?: null, 'type' => $this->independent ? 'subsegment' : null, 'fault' => $this->fault ?? null, 'error' => $this->error ?? null, 'annotations' => $this->annotations ?? null ?: null, 'metadata' => $this->metadata ?? null ?: null]);\n    }\n}","mutatedSourceCode":"<?php\n\nnamespace Fido\\PHPXray;\n\nuse JsonSerializable;\nuse Fido\\PHPXray\\Submission\\SegmentSubmitter;\nclass Segment implements JsonSerializable\n{\n    protected string $id;\n    protected ?string $parentId = null;\n    protected string $traceId;\n    protected ?string $name = null;\n    protected float $startTime;\n    protected float $endTime;\n    \/** @var Segment[] *\/\n    protected array $subsegments = [];\n    protected bool $error = false;\n    protected bool $fault = false;\n    protected bool $sampled = false;\n    protected bool $independent = false;\n    \/** @var array<string, mixed> *\/\n    private array $annotations;\n    \/** @var array<string, mixed> *\/\n    private array $metadata;\n    private int $lastOpenSegment = 0;\n    \/**\n     * @throws \\Exception if an appropriate source of randomness cannot be found.\n     *\/\n    public function __construct()\n    {\n        $this->id = bin2hex(random_bytes(8));\n    }\n    public function setTraceHeader(string $traceHeader = null) : self\n    {\n        if (is_null($traceHeader)) {\n            return $this;\n        }\n        $parts = explode(';', $traceHeader);\n        $variables = array_map(function ($str) : array {\n            return explode('=', $str);\n        }, $parts);\n        $variables = array_column($variables, 1, 0);\n        if (isset($variables['Root'])) {\n            $this->setTraceId($variables['Root']);\n        }\n        if (isset($variables['Sampled'])) {\n            $this->setSampled((bool) $variables['Sampled'] ?? false);\n        }\n        if (isset($variables['Parent'])) {\n            $this->setParentId($variables['Parent'] ?? null);\n        }\n        return $this;\n    }\n    public function begin() : self\n    {\n        $this->startTime = microtime(true);\n        return $this;\n    }\n    public function end() : self\n    {\n        $this->endTime = microtime(true);\n        return $this;\n    }\n    public function setName(string $name) : self\n    {\n        $this->name = $name;\n        return $this;\n    }\n    public function setError(bool $error) : self\n    {\n        $this->error = $error;\n        return $this;\n    }\n    public function setFault(bool $fault) : self\n    {\n        $this->fault = $fault;\n        return $this;\n    }\n    public function addSubsegment(Segment $subsegment) : self\n    {\n        if (!$this->isOpen()) {\n            return $this;\n        }\n        $this->subsegments[] = $subsegment;\n        $subsegment->setSampled($this->isSampled());\n        return $this;\n    }\n    public function submit(SegmentSubmitter $submitter) : void\n    {\n        if (!$this->isSampled()) {\n            return;\n        }\n        $submitter->submitSegment($this);\n    }\n    public function isSampled() : bool\n    {\n        return $this->sampled;\n    }\n    public function setSampled(bool $sampled) : self\n    {\n        $this->sampled = $sampled;\n        return $this;\n    }\n    public function getId() : string\n    {\n        return $this->id;\n    }\n    public function setParentId(?string $parentId) : self\n    {\n        $this->parentId = $parentId;\n        return $this;\n    }\n    protected function setTraceId(string $traceId) : self\n    {\n        $this->traceId = $traceId;\n        return $this;\n    }\n    public function getTraceId() : string\n    {\n        return $this->traceId;\n    }\n    public function isOpen() : bool\n    {\n        return isset($this->startTime) && !isset($this->endTime);\n    }\n    public function setIndependent(bool $independent) : self\n    {\n        $this->independent = $independent;\n        return $this;\n    }\n    public function addAnnotation(string $key, string $value) : self\n    {\n        $this->annotations[$key] = $value;\n        return $this;\n    }\n    public function addMetadata(string $key, mixed $value) : self\n    {\n        $this->metadata[$key] = $value;\n        return $this;\n    }\n    public function getCurrentSegment() : self\n    {\n        for ($max = count($this->subsegments); $this->lastOpenSegment < $max; $this->lastOpenSegment++) {\n            if ($this->subsegments[$this->lastOpenSegment]->isOpen()) {\n                return $this->subsegments[$this->lastOpenSegment]->getCurrentSegment();\n            }\n        }\n        return $this;\n    }\n    \/**\n     * @inheritDoc\n     * @return array<string, mixed>\n     *\/\n    public function jsonSerialize() : array\n    {\n        return array_filter(['id' => $this->id, 'parent_id' => $this->parentId, 'trace_id' => $this->traceId ?? null, 'name' => $this->name, 'start_time' => $this->startTime ?? null, 'end_time' => $this->endTime ?? null, 'subsegments' => $this->subsegments ?? null ?: null, 'type' => $this->independent ? 'subsegment' : null, 'fault' => $this->fault ?? null, 'error' => $this->error ?? null, 'annotations' => $this->annotations ?? null ?: null, 'metadata' => $this->metadata ?? null ?: null]);\n    }\n}","originalFilePath":"\/home\/ranpafin\/php-xray\/src\/Segment.php","originalStartLine":143},"diff":"--- Original\n+++ New\n@@ @@\n         $this->parentId = $parentId;\n         return $this;\n     }\n-    public function setTraceId(string $traceId) : self\n+    protected function setTraceId(string $traceId) : self\n     {\n         $this->traceId = $traceId;\n         return $this;","processOutput":"PHPUnit 9.5.10 by Sebastian Bergmann and contributors.\n\nRuntime:       PHP 8.0.13\nConfiguration: \/tmp\/tmp-folder\/infection\/phpunitConfiguration.5212c9d68925c6d73785fe77220edc13.infection.xml\n\nE\n\nTime: 00:00.003, Memory: 8.00 MB\n\nThere was 1 error:\n\n1) Fido\\PHPXray\\DaemonSegmentSubmitterTest::testSubmitsToDaemon\nsocket_bind(): Unable to bind address [98]: Address already in use\n\n\/home\/ranpafin\/php-xray\/tests\/DaemonSegmentSubmitterTest.php:18\n\nERRORS!\nTests: 1, Assertions: 0, Errors: 1."},{"mutator":{"mutatorName":"PublicVisibility","originalSourceCode":"<?php\n\nnamespace Fido\\PHPXray;\n\nuse JsonSerializable;\nuse Fido\\PHPXray\\Submission\\SegmentSubmitter;\nclass Segment implements JsonSerializable\n{\n    protected string $id;\n    protected ?string $parentId = null;\n    protected string $traceId;\n    protected ?string $name = null;\n    protected float $startTime;\n    protected float $endTime;\n    \/** @var Segment[] *\/\n    protected array $subsegments = [];\n    protected bool $error = false;\n    protected bool $fault = false;\n    protected bool $sampled = false;\n    protected bool $independent = false;\n    \/** @var array<string, mixed> *\/\n    private array $annotations;\n    \/** @var array<string, mixed> *\/\n    private array $metadata;\n    private int $lastOpenSegment = 0;\n    \/**\n     * @throws \\Exception if an appropriate source of randomness cannot be found.\n     *\/\n    public function __construct()\n    {\n        $this->id = bin2hex(random_bytes(8));\n    }\n    public function setTraceHeader(string $traceHeader = null) : self\n    {\n        if (is_null($traceHeader)) {\n            return $this;\n        }\n        $parts = explode(';', $traceHeader);\n        $variables = array_map(function ($str) : array {\n            return explode('=', $str);\n        }, $parts);\n        $variables = array_column($variables, 1, 0);\n        if (isset($variables['Root'])) {\n            $this->setTraceId($variables['Root']);\n        }\n        if (isset($variables['Sampled'])) {\n            $this->setSampled((bool) $variables['Sampled'] ?? false);\n        }\n        if (isset($variables['Parent'])) {\n            $this->setParentId($variables['Parent'] ?? null);\n        }\n        return $this;\n    }\n    public function begin() : self\n    {\n        $this->startTime = microtime(true);\n        return $this;\n    }\n    public function end() : self\n    {\n        $this->endTime = microtime(true);\n        return $this;\n    }\n    public function setName(string $name) : self\n    {\n        $this->name = $name;\n        return $this;\n    }\n    public function setError(bool $error) : self\n    {\n        $this->error = $error;\n        return $this;\n    }\n    public function setFault(bool $fault) : self\n    {\n        $this->fault = $fault;\n        return $this;\n    }\n    public function addSubsegment(Segment $subsegment) : self\n    {\n        if (!$this->isOpen()) {\n            return $this;\n        }\n        $this->subsegments[] = $subsegment;\n        $subsegment->setSampled($this->isSampled());\n        return $this;\n    }\n    public function submit(SegmentSubmitter $submitter) : void\n    {\n        if (!$this->isSampled()) {\n            return;\n        }\n        $submitter->submitSegment($this);\n    }\n    public function isSampled() : bool\n    {\n        return $this->sampled;\n    }\n    public function setSampled(bool $sampled) : self\n    {\n        $this->sampled = $sampled;\n        return $this;\n    }\n    public function getId() : string\n    {\n        return $this->id;\n    }\n    public function setParentId(?string $parentId) : self\n    {\n        $this->parentId = $parentId;\n        return $this;\n    }\n    public function setTraceId(string $traceId) : self\n    {\n        $this->traceId = $traceId;\n        return $this;\n    }\n    public function getTraceId() : string\n    {\n        return $this->traceId;\n    }\n    public function isOpen() : bool\n    {\n        return isset($this->startTime) && !isset($this->endTime);\n    }\n    public function setIndependent(bool $independent) : self\n    {\n        $this->independent = $independent;\n        return $this;\n    }\n    public function addAnnotation(string $key, string $value) : self\n    {\n        $this->annotations[$key] = $value;\n        return $this;\n    }\n    public function addMetadata(string $key, mixed $value) : self\n    {\n        $this->metadata[$key] = $value;\n        return $this;\n    }\n    public function getCurrentSegment() : self\n    {\n        for ($max = count($this->subsegments); $this->lastOpenSegment < $max; $this->lastOpenSegment++) {\n            if ($this->subsegments[$this->lastOpenSegment]->isOpen()) {\n                return $this->subsegments[$this->lastOpenSegment]->getCurrentSegment();\n            }\n        }\n        return $this;\n    }\n    \/**\n     * @inheritDoc\n     * @return array<string, mixed>\n     *\/\n    public function jsonSerialize() : array\n    {\n        return array_filter(['id' => $this->id, 'parent_id' => $this->parentId, 'trace_id' => $this->traceId ?? null, 'name' => $this->name, 'start_time' => $this->startTime ?? null, 'end_time' => $this->endTime ?? null, 'subsegments' => $this->subsegments ?? null ?: null, 'type' => $this->independent ? 'subsegment' : null, 'fault' => $this->fault ?? null, 'error' => $this->error ?? null, 'annotations' => $this->annotations ?? null ?: null, 'metadata' => $this->metadata ?? null ?: null]);\n    }\n}","mutatedSourceCode":"<?php\n\nnamespace Fido\\PHPXray;\n\nuse JsonSerializable;\nuse Fido\\PHPXray\\Submission\\SegmentSubmitter;\nclass Segment implements JsonSerializable\n{\n    protected string $id;\n    protected ?string $parentId = null;\n    protected string $traceId;\n    protected ?string $name = null;\n    protected float $startTime;\n    protected float $endTime;\n    \/** @var Segment[] *\/\n    protected array $subsegments = [];\n    protected bool $error = false;\n    protected bool $fault = false;\n    protected bool $sampled = false;\n    protected bool $independent = false;\n    \/** @var array<string, mixed> *\/\n    private array $annotations;\n    \/** @var array<string, mixed> *\/\n    private array $metadata;\n    private int $lastOpenSegment = 0;\n    \/**\n     * @throws \\Exception if an appropriate source of randomness cannot be found.\n     *\/\n    public function __construct()\n    {\n        $this->id = bin2hex(random_bytes(8));\n    }\n    public function setTraceHeader(string $traceHeader = null) : self\n    {\n        if (is_null($traceHeader)) {\n            return $this;\n        }\n        $parts = explode(';', $traceHeader);\n        $variables = array_map(function ($str) : array {\n            return explode('=', $str);\n        }, $parts);\n        $variables = array_column($variables, 1, 0);\n        if (isset($variables['Root'])) {\n            $this->setTraceId($variables['Root']);\n        }\n        if (isset($variables['Sampled'])) {\n            $this->setSampled((bool) $variables['Sampled'] ?? false);\n        }\n        if (isset($variables['Parent'])) {\n            $this->setParentId($variables['Parent'] ?? null);\n        }\n        return $this;\n    }\n    public function begin() : self\n    {\n        $this->startTime = microtime(true);\n        return $this;\n    }\n    public function end() : self\n    {\n        $this->endTime = microtime(true);\n        return $this;\n    }\n    public function setName(string $name) : self\n    {\n        $this->name = $name;\n        return $this;\n    }\n    public function setError(bool $error) : self\n    {\n        $this->error = $error;\n        return $this;\n    }\n    public function setFault(bool $fault) : self\n    {\n        $this->fault = $fault;\n        return $this;\n    }\n    public function addSubsegment(Segment $subsegment) : self\n    {\n        if (!$this->isOpen()) {\n            return $this;\n        }\n        $this->subsegments[] = $subsegment;\n        $subsegment->setSampled($this->isSampled());\n        return $this;\n    }\n    public function submit(SegmentSubmitter $submitter) : void\n    {\n        if (!$this->isSampled()) {\n            return;\n        }\n        $submitter->submitSegment($this);\n    }\n    public function isSampled() : bool\n    {\n        return $this->sampled;\n    }\n    public function setSampled(bool $sampled) : self\n    {\n        $this->sampled = $sampled;\n        return $this;\n    }\n    public function getId() : string\n    {\n        return $this->id;\n    }\n    public function setParentId(?string $parentId) : self\n    {\n        $this->parentId = $parentId;\n        return $this;\n    }\n    public function setTraceId(string $traceId) : self\n    {\n        $this->traceId = $traceId;\n        return $this;\n    }\n    protected function getTraceId() : string\n    {\n        return $this->traceId;\n    }\n    public function isOpen() : bool\n    {\n        return isset($this->startTime) && !isset($this->endTime);\n    }\n    public function setIndependent(bool $independent) : self\n    {\n        $this->independent = $independent;\n        return $this;\n    }\n    public function addAnnotation(string $key, string $value) : self\n    {\n        $this->annotations[$key] = $value;\n        return $this;\n    }\n    public function addMetadata(string $key, mixed $value) : self\n    {\n        $this->metadata[$key] = $value;\n        return $this;\n    }\n    public function getCurrentSegment() : self\n    {\n        for ($max = count($this->subsegments); $this->lastOpenSegment < $max; $this->lastOpenSegment++) {\n            if ($this->subsegments[$this->lastOpenSegment]->isOpen()) {\n                return $this->subsegments[$this->lastOpenSegment]->getCurrentSegment();\n            }\n        }\n        return $this;\n    }\n    \/**\n     * @inheritDoc\n     * @return array<string, mixed>\n     *\/\n    public function jsonSerialize() : array\n    {\n        return array_filter(['id' => $this->id, 'parent_id' => $this->parentId, 'trace_id' => $this->traceId ?? null, 'name' => $this->name, 'start_time' => $this->startTime ?? null, 'end_time' => $this->endTime ?? null, 'subsegments' => $this->subsegments ?? null ?: null, 'type' => $this->independent ? 'subsegment' : null, 'fault' => $this->fault ?? null, 'error' => $this->error ?? null, 'annotations' => $this->annotations ?? null ?: null, 'metadata' => $this->metadata ?? null ?: null]);\n    }\n}","originalFilePath":"\/home\/ranpafin\/php-xray\/src\/Segment.php","originalStartLine":150},"diff":"--- Original\n+++ New\n@@ @@\n         $this->traceId = $traceId;\n         return $this;\n     }\n-    public function getTraceId() : string\n+    protected function getTraceId() : string\n     {\n         return $this->traceId;\n     }","processOutput":"PHPUnit 9.5.10 by Sebastian Bergmann and contributors.\n\nRuntime:       PHP 8.0.13\nConfiguration: \/tmp\/tmp-folder\/infection\/phpunitConfiguration.8fff95feac55828aac1d6ed7102e9cfc.infection.xml\n\nE\n\nTime: 00:00.003, Memory: 8.00 MB\n\nThere was 1 error:\n\n1) Fido\\PHPXray\\DaemonSegmentSubmitterTest::testSubmitsToDaemon\nsocket_bind(): Unable to bind address [98]: Address already in use\n\n\/home\/ranpafin\/php-xray\/tests\/DaemonSegmentSubmitterTest.php:18\n\nERRORS!\nTests: 1, Assertions: 0, Errors: 1."},{"mutator":{"mutatorName":"PublicVisibility","originalSourceCode":"<?php\n\nnamespace Fido\\PHPXray;\n\nuse JsonSerializable;\nuse Fido\\PHPXray\\Submission\\SegmentSubmitter;\nclass Segment implements JsonSerializable\n{\n    protected string $id;\n    protected ?string $parentId = null;\n    protected string $traceId;\n    protected ?string $name = null;\n    protected float $startTime;\n    protected float $endTime;\n    \/** @var Segment[] *\/\n    protected array $subsegments = [];\n    protected bool $error = false;\n    protected bool $fault = false;\n    protected bool $sampled = false;\n    protected bool $independent = false;\n    \/** @var array<string, mixed> *\/\n    private array $annotations;\n    \/** @var array<string, mixed> *\/\n    private array $metadata;\n    private int $lastOpenSegment = 0;\n    \/**\n     * @throws \\Exception if an appropriate source of randomness cannot be found.\n     *\/\n    public function __construct()\n    {\n        $this->id = bin2hex(random_bytes(8));\n    }\n    public function setTraceHeader(string $traceHeader = null) : self\n    {\n        if (is_null($traceHeader)) {\n            return $this;\n        }\n        $parts = explode(';', $traceHeader);\n        $variables = array_map(function ($str) : array {\n            return explode('=', $str);\n        }, $parts);\n        $variables = array_column($variables, 1, 0);\n        if (isset($variables['Root'])) {\n            $this->setTraceId($variables['Root']);\n        }\n        if (isset($variables['Sampled'])) {\n            $this->setSampled((bool) $variables['Sampled'] ?? false);\n        }\n        if (isset($variables['Parent'])) {\n            $this->setParentId($variables['Parent'] ?? null);\n        }\n        return $this;\n    }\n    public function begin() : self\n    {\n        $this->startTime = microtime(true);\n        return $this;\n    }\n    public function end() : self\n    {\n        $this->endTime = microtime(true);\n        return $this;\n    }\n    public function setName(string $name) : self\n    {\n        $this->name = $name;\n        return $this;\n    }\n    public function setError(bool $error) : self\n    {\n        $this->error = $error;\n        return $this;\n    }\n    public function setFault(bool $fault) : self\n    {\n        $this->fault = $fault;\n        return $this;\n    }\n    public function addSubsegment(Segment $subsegment) : self\n    {\n        if (!$this->isOpen()) {\n            return $this;\n        }\n        $this->subsegments[] = $subsegment;\n        $subsegment->setSampled($this->isSampled());\n        return $this;\n    }\n    public function submit(SegmentSubmitter $submitter) : void\n    {\n        if (!$this->isSampled()) {\n            return;\n        }\n        $submitter->submitSegment($this);\n    }\n    public function isSampled() : bool\n    {\n        return $this->sampled;\n    }\n    public function setSampled(bool $sampled) : self\n    {\n        $this->sampled = $sampled;\n        return $this;\n    }\n    public function getId() : string\n    {\n        return $this->id;\n    }\n    public function setParentId(?string $parentId) : self\n    {\n        $this->parentId = $parentId;\n        return $this;\n    }\n    public function setTraceId(string $traceId) : self\n    {\n        $this->traceId = $traceId;\n        return $this;\n    }\n    public function getTraceId() : string\n    {\n        return $this->traceId;\n    }\n    public function isOpen() : bool\n    {\n        return isset($this->startTime) && !isset($this->endTime);\n    }\n    public function setIndependent(bool $independent) : self\n    {\n        $this->independent = $independent;\n        return $this;\n    }\n    public function addAnnotation(string $key, string $value) : self\n    {\n        $this->annotations[$key] = $value;\n        return $this;\n    }\n    public function addMetadata(string $key, mixed $value) : self\n    {\n        $this->metadata[$key] = $value;\n        return $this;\n    }\n    public function getCurrentSegment() : self\n    {\n        for ($max = count($this->subsegments); $this->lastOpenSegment < $max; $this->lastOpenSegment++) {\n            if ($this->subsegments[$this->lastOpenSegment]->isOpen()) {\n                return $this->subsegments[$this->lastOpenSegment]->getCurrentSegment();\n            }\n        }\n        return $this;\n    }\n    \/**\n     * @inheritDoc\n     * @return array<string, mixed>\n     *\/\n    public function jsonSerialize() : array\n    {\n        return array_filter(['id' => $this->id, 'parent_id' => $this->parentId, 'trace_id' => $this->traceId ?? null, 'name' => $this->name, 'start_time' => $this->startTime ?? null, 'end_time' => $this->endTime ?? null, 'subsegments' => $this->subsegments ?? null ?: null, 'type' => $this->independent ? 'subsegment' : null, 'fault' => $this->fault ?? null, 'error' => $this->error ?? null, 'annotations' => $this->annotations ?? null ?: null, 'metadata' => $this->metadata ?? null ?: null]);\n    }\n}","mutatedSourceCode":"<?php\n\nnamespace Fido\\PHPXray;\n\nuse JsonSerializable;\nuse Fido\\PHPXray\\Submission\\SegmentSubmitter;\nclass Segment implements JsonSerializable\n{\n    protected string $id;\n    protected ?string $parentId = null;\n    protected string $traceId;\n    protected ?string $name = null;\n    protected float $startTime;\n    protected float $endTime;\n    \/** @var Segment[] *\/\n    protected array $subsegments = [];\n    protected bool $error = false;\n    protected bool $fault = false;\n    protected bool $sampled = false;\n    protected bool $independent = false;\n    \/** @var array<string, mixed> *\/\n    private array $annotations;\n    \/** @var array<string, mixed> *\/\n    private array $metadata;\n    private int $lastOpenSegment = 0;\n    \/**\n     * @throws \\Exception if an appropriate source of randomness cannot be found.\n     *\/\n    public function __construct()\n    {\n        $this->id = bin2hex(random_bytes(8));\n    }\n    public function setTraceHeader(string $traceHeader = null) : self\n    {\n        if (is_null($traceHeader)) {\n            return $this;\n        }\n        $parts = explode(';', $traceHeader);\n        $variables = array_map(function ($str) : array {\n            return explode('=', $str);\n        }, $parts);\n        $variables = array_column($variables, 1, 0);\n        if (isset($variables['Root'])) {\n            $this->setTraceId($variables['Root']);\n        }\n        if (isset($variables['Sampled'])) {\n            $this->setSampled((bool) $variables['Sampled'] ?? false);\n        }\n        if (isset($variables['Parent'])) {\n            $this->setParentId($variables['Parent'] ?? null);\n        }\n        return $this;\n    }\n    public function begin() : self\n    {\n        $this->startTime = microtime(true);\n        return $this;\n    }\n    public function end() : self\n    {\n        $this->endTime = microtime(true);\n        return $this;\n    }\n    public function setName(string $name) : self\n    {\n        $this->name = $name;\n        return $this;\n    }\n    public function setError(bool $error) : self\n    {\n        $this->error = $error;\n        return $this;\n    }\n    public function setFault(bool $fault) : self\n    {\n        $this->fault = $fault;\n        return $this;\n    }\n    public function addSubsegment(Segment $subsegment) : self\n    {\n        if (!$this->isOpen()) {\n            return $this;\n        }\n        $this->subsegments[] = $subsegment;\n        $subsegment->setSampled($this->isSampled());\n        return $this;\n    }\n    public function submit(SegmentSubmitter $submitter) : void\n    {\n        if (!$this->isSampled()) {\n            return;\n        }\n        $submitter->submitSegment($this);\n    }\n    public function isSampled() : bool\n    {\n        return $this->sampled;\n    }\n    public function setSampled(bool $sampled) : self\n    {\n        $this->sampled = $sampled;\n        return $this;\n    }\n    public function getId() : string\n    {\n        return $this->id;\n    }\n    public function setParentId(?string $parentId) : self\n    {\n        $this->parentId = $parentId;\n        return $this;\n    }\n    public function setTraceId(string $traceId) : self\n    {\n        $this->traceId = $traceId;\n        return $this;\n    }\n    public function getTraceId() : string\n    {\n        return $this->traceId;\n    }\n    protected function isOpen() : bool\n    {\n        return isset($this->startTime) && !isset($this->endTime);\n    }\n    public function setIndependent(bool $independent) : self\n    {\n        $this->independent = $independent;\n        return $this;\n    }\n    public function addAnnotation(string $key, string $value) : self\n    {\n        $this->annotations[$key] = $value;\n        return $this;\n    }\n    public function addMetadata(string $key, mixed $value) : self\n    {\n        $this->metadata[$key] = $value;\n        return $this;\n    }\n    public function getCurrentSegment() : self\n    {\n        for ($max = count($this->subsegments); $this->lastOpenSegment < $max; $this->lastOpenSegment++) {\n            if ($this->subsegments[$this->lastOpenSegment]->isOpen()) {\n                return $this->subsegments[$this->lastOpenSegment]->getCurrentSegment();\n            }\n        }\n        return $this;\n    }\n    \/**\n     * @inheritDoc\n     * @return array<string, mixed>\n     *\/\n    public function jsonSerialize() : array\n    {\n        return array_filter(['id' => $this->id, 'parent_id' => $this->parentId, 'trace_id' => $this->traceId ?? null, 'name' => $this->name, 'start_time' => $this->startTime ?? null, 'end_time' => $this->endTime ?? null, 'subsegments' => $this->subsegments ?? null ?: null, 'type' => $this->independent ? 'subsegment' : null, 'fault' => $this->fault ?? null, 'error' => $this->error ?? null, 'annotations' => $this->annotations ?? null ?: null, 'metadata' => $this->metadata ?? null ?: null]);\n    }\n}","originalFilePath":"\/home\/ranpafin\/php-xray\/src\/Segment.php","originalStartLine":155},"diff":"--- Original\n+++ New\n@@ @@\n     {\n         return $this->traceId;\n     }\n-    public function isOpen() : bool\n+    protected function isOpen() : bool\n     {\n         return isset($this->startTime) && !isset($this->endTime);\n     }","processOutput":"PHPUnit 9.5.10 by Sebastian Bergmann and contributors.\n\nRuntime:       PHP 8.0.13\nConfiguration: \/tmp\/tmp-folder\/infection\/phpunitConfiguration.251c30eaabe1a46602327abe3e656de8.infection.xml\n\nE\n\nTime: 00:00.004, Memory: 8.00 MB\n\nThere was 1 error:\n\n1) Fido\\PHPXray\\DaemonSegmentSubmitterTest::testSubmitsToDaemon\nsocket_bind(): Unable to bind address [98]: Address already in use\n\n\/home\/ranpafin\/php-xray\/tests\/DaemonSegmentSubmitterTest.php:18\n\nERRORS!\nTests: 1, Assertions: 0, Errors: 1."},{"mutator":{"mutatorName":"LogicalNot","originalSourceCode":"<?php\n\nnamespace Fido\\PHPXray;\n\nuse JsonSerializable;\nuse Fido\\PHPXray\\Submission\\SegmentSubmitter;\nclass Segment implements JsonSerializable\n{\n    protected string $id;\n    protected ?string $parentId = null;\n    protected string $traceId;\n    protected ?string $name = null;\n    protected float $startTime;\n    protected float $endTime;\n    \/** @var Segment[] *\/\n    protected array $subsegments = [];\n    protected bool $error = false;\n    protected bool $fault = false;\n    protected bool $sampled = false;\n    protected bool $independent = false;\n    \/** @var array<string, mixed> *\/\n    private array $annotations;\n    \/** @var array<string, mixed> *\/\n    private array $metadata;\n    private int $lastOpenSegment = 0;\n    \/**\n     * @throws \\Exception if an appropriate source of randomness cannot be found.\n     *\/\n    public function __construct()\n    {\n        $this->id = bin2hex(random_bytes(8));\n    }\n    public function setTraceHeader(string $traceHeader = null) : self\n    {\n        if (is_null($traceHeader)) {\n            return $this;\n        }\n        $parts = explode(';', $traceHeader);\n        $variables = array_map(function ($str) : array {\n            return explode('=', $str);\n        }, $parts);\n        $variables = array_column($variables, 1, 0);\n        if (isset($variables['Root'])) {\n            $this->setTraceId($variables['Root']);\n        }\n        if (isset($variables['Sampled'])) {\n            $this->setSampled((bool) $variables['Sampled'] ?? false);\n        }\n        if (isset($variables['Parent'])) {\n            $this->setParentId($variables['Parent'] ?? null);\n        }\n        return $this;\n    }\n    public function begin() : self\n    {\n        $this->startTime = microtime(true);\n        return $this;\n    }\n    public function end() : self\n    {\n        $this->endTime = microtime(true);\n        return $this;\n    }\n    public function setName(string $name) : self\n    {\n        $this->name = $name;\n        return $this;\n    }\n    public function setError(bool $error) : self\n    {\n        $this->error = $error;\n        return $this;\n    }\n    public function setFault(bool $fault) : self\n    {\n        $this->fault = $fault;\n        return $this;\n    }\n    public function addSubsegment(Segment $subsegment) : self\n    {\n        if (!$this->isOpen()) {\n            return $this;\n        }\n        $this->subsegments[] = $subsegment;\n        $subsegment->setSampled($this->isSampled());\n        return $this;\n    }\n    public function submit(SegmentSubmitter $submitter) : void\n    {\n        if (!$this->isSampled()) {\n            return;\n        }\n        $submitter->submitSegment($this);\n    }\n    public function isSampled() : bool\n    {\n        return $this->sampled;\n    }\n    public function setSampled(bool $sampled) : self\n    {\n        $this->sampled = $sampled;\n        return $this;\n    }\n    public function getId() : string\n    {\n        return $this->id;\n    }\n    public function setParentId(?string $parentId) : self\n    {\n        $this->parentId = $parentId;\n        return $this;\n    }\n    public function setTraceId(string $traceId) : self\n    {\n        $this->traceId = $traceId;\n        return $this;\n    }\n    public function getTraceId() : string\n    {\n        return $this->traceId;\n    }\n    public function isOpen() : bool\n    {\n        return isset($this->startTime) && !isset($this->endTime);\n    }\n    public function setIndependent(bool $independent) : self\n    {\n        $this->independent = $independent;\n        return $this;\n    }\n    public function addAnnotation(string $key, string $value) : self\n    {\n        $this->annotations[$key] = $value;\n        return $this;\n    }\n    public function addMetadata(string $key, mixed $value) : self\n    {\n        $this->metadata[$key] = $value;\n        return $this;\n    }\n    public function getCurrentSegment() : self\n    {\n        for ($max = count($this->subsegments); $this->lastOpenSegment < $max; $this->lastOpenSegment++) {\n            if ($this->subsegments[$this->lastOpenSegment]->isOpen()) {\n                return $this->subsegments[$this->lastOpenSegment]->getCurrentSegment();\n            }\n        }\n        return $this;\n    }\n    \/**\n     * @inheritDoc\n     * @return array<string, mixed>\n     *\/\n    public function jsonSerialize() : array\n    {\n        return array_filter(['id' => $this->id, 'parent_id' => $this->parentId, 'trace_id' => $this->traceId ?? null, 'name' => $this->name, 'start_time' => $this->startTime ?? null, 'end_time' => $this->endTime ?? null, 'subsegments' => $this->subsegments ?? null ?: null, 'type' => $this->independent ? 'subsegment' : null, 'fault' => $this->fault ?? null, 'error' => $this->error ?? null, 'annotations' => $this->annotations ?? null ?: null, 'metadata' => $this->metadata ?? null ?: null]);\n    }\n}","mutatedSourceCode":"<?php\n\nnamespace Fido\\PHPXray;\n\nuse JsonSerializable;\nuse Fido\\PHPXray\\Submission\\SegmentSubmitter;\nclass Segment implements JsonSerializable\n{\n    protected string $id;\n    protected ?string $parentId = null;\n    protected string $traceId;\n    protected ?string $name = null;\n    protected float $startTime;\n    protected float $endTime;\n    \/** @var Segment[] *\/\n    protected array $subsegments = [];\n    protected bool $error = false;\n    protected bool $fault = false;\n    protected bool $sampled = false;\n    protected bool $independent = false;\n    \/** @var array<string, mixed> *\/\n    private array $annotations;\n    \/** @var array<string, mixed> *\/\n    private array $metadata;\n    private int $lastOpenSegment = 0;\n    \/**\n     * @throws \\Exception if an appropriate source of randomness cannot be found.\n     *\/\n    public function __construct()\n    {\n        $this->id = bin2hex(random_bytes(8));\n    }\n    public function setTraceHeader(string $traceHeader = null) : self\n    {\n        if (is_null($traceHeader)) {\n            return $this;\n        }\n        $parts = explode(';', $traceHeader);\n        $variables = array_map(function ($str) : array {\n            return explode('=', $str);\n        }, $parts);\n        $variables = array_column($variables, 1, 0);\n        if (isset($variables['Root'])) {\n            $this->setTraceId($variables['Root']);\n        }\n        if (isset($variables['Sampled'])) {\n            $this->setSampled((bool) $variables['Sampled'] ?? false);\n        }\n        if (isset($variables['Parent'])) {\n            $this->setParentId($variables['Parent'] ?? null);\n        }\n        return $this;\n    }\n    public function begin() : self\n    {\n        $this->startTime = microtime(true);\n        return $this;\n    }\n    public function end() : self\n    {\n        $this->endTime = microtime(true);\n        return $this;\n    }\n    public function setName(string $name) : self\n    {\n        $this->name = $name;\n        return $this;\n    }\n    public function setError(bool $error) : self\n    {\n        $this->error = $error;\n        return $this;\n    }\n    public function setFault(bool $fault) : self\n    {\n        $this->fault = $fault;\n        return $this;\n    }\n    public function addSubsegment(Segment $subsegment) : self\n    {\n        if (!$this->isOpen()) {\n            return $this;\n        }\n        $this->subsegments[] = $subsegment;\n        $subsegment->setSampled($this->isSampled());\n        return $this;\n    }\n    public function submit(SegmentSubmitter $submitter) : void\n    {\n        if (!$this->isSampled()) {\n            return;\n        }\n        $submitter->submitSegment($this);\n    }\n    public function isSampled() : bool\n    {\n        return $this->sampled;\n    }\n    public function setSampled(bool $sampled) : self\n    {\n        $this->sampled = $sampled;\n        return $this;\n    }\n    public function getId() : string\n    {\n        return $this->id;\n    }\n    public function setParentId(?string $parentId) : self\n    {\n        $this->parentId = $parentId;\n        return $this;\n    }\n    public function setTraceId(string $traceId) : self\n    {\n        $this->traceId = $traceId;\n        return $this;\n    }\n    public function getTraceId() : string\n    {\n        return $this->traceId;\n    }\n    public function isOpen() : bool\n    {\n        return isset($this->startTime) && isset($this->endTime);\n    }\n    public function setIndependent(bool $independent) : self\n    {\n        $this->independent = $independent;\n        return $this;\n    }\n    public function addAnnotation(string $key, string $value) : self\n    {\n        $this->annotations[$key] = $value;\n        return $this;\n    }\n    public function addMetadata(string $key, mixed $value) : self\n    {\n        $this->metadata[$key] = $value;\n        return $this;\n    }\n    public function getCurrentSegment() : self\n    {\n        for ($max = count($this->subsegments); $this->lastOpenSegment < $max; $this->lastOpenSegment++) {\n            if ($this->subsegments[$this->lastOpenSegment]->isOpen()) {\n                return $this->subsegments[$this->lastOpenSegment]->getCurrentSegment();\n            }\n        }\n        return $this;\n    }\n    \/**\n     * @inheritDoc\n     * @return array<string, mixed>\n     *\/\n    public function jsonSerialize() : array\n    {\n        return array_filter(['id' => $this->id, 'parent_id' => $this->parentId, 'trace_id' => $this->traceId ?? null, 'name' => $this->name, 'start_time' => $this->startTime ?? null, 'end_time' => $this->endTime ?? null, 'subsegments' => $this->subsegments ?? null ?: null, 'type' => $this->independent ? 'subsegment' : null, 'fault' => $this->fault ?? null, 'error' => $this->error ?? null, 'annotations' => $this->annotations ?? null ?: null, 'metadata' => $this->metadata ?? null ?: null]);\n    }\n}","originalFilePath":"\/home\/ranpafin\/php-xray\/src\/Segment.php","originalStartLine":157},"diff":"--- Original\n+++ New\n@@ @@\n     }\n     public function isOpen() : bool\n     {\n-        return isset($this->startTime) && !isset($this->endTime);\n+        return isset($this->startTime) && isset($this->endTime);\n     }\n     public function setIndependent(bool $independent) : self\n     {","processOutput":"PHPUnit 9.5.10 by Sebastian Bergmann and contributors.\n\nRuntime:       PHP 8.0.13\nConfiguration: \/tmp\/tmp-folder\/infection\/phpunitConfiguration.7742f955a343006789de97e97e184925.infection.xml\n\nE\n\nTime: 00:00.003, Memory: 8.00 MB\n\nThere was 1 error:\n\n1) Fido\\PHPXray\\DaemonSegmentSubmitterTest::testSubmitsToDaemon\nsocket_bind(): Unable to bind address [98]: Address already in use\n\n\/home\/ranpafin\/php-xray\/tests\/DaemonSegmentSubmitterTest.php:18\n\nERRORS!\nTests: 1, Assertions: 0, Errors: 1."},{"mutator":{"mutatorName":"LogicalAnd","originalSourceCode":"<?php\n\nnamespace Fido\\PHPXray;\n\nuse JsonSerializable;\nuse Fido\\PHPXray\\Submission\\SegmentSubmitter;\nclass Segment implements JsonSerializable\n{\n    protected string $id;\n    protected ?string $parentId = null;\n    protected string $traceId;\n    protected ?string $name = null;\n    protected float $startTime;\n    protected float $endTime;\n    \/** @var Segment[] *\/\n    protected array $subsegments = [];\n    protected bool $error = false;\n    protected bool $fault = false;\n    protected bool $sampled = false;\n    protected bool $independent = false;\n    \/** @var array<string, mixed> *\/\n    private array $annotations;\n    \/** @var array<string, mixed> *\/\n    private array $metadata;\n    private int $lastOpenSegment = 0;\n    \/**\n     * @throws \\Exception if an appropriate source of randomness cannot be found.\n     *\/\n    public function __construct()\n    {\n        $this->id = bin2hex(random_bytes(8));\n    }\n    public function setTraceHeader(string $traceHeader = null) : self\n    {\n        if (is_null($traceHeader)) {\n            return $this;\n        }\n        $parts = explode(';', $traceHeader);\n        $variables = array_map(function ($str) : array {\n            return explode('=', $str);\n        }, $parts);\n        $variables = array_column($variables, 1, 0);\n        if (isset($variables['Root'])) {\n            $this->setTraceId($variables['Root']);\n        }\n        if (isset($variables['Sampled'])) {\n            $this->setSampled((bool) $variables['Sampled'] ?? false);\n        }\n        if (isset($variables['Parent'])) {\n            $this->setParentId($variables['Parent'] ?? null);\n        }\n        return $this;\n    }\n    public function begin() : self\n    {\n        $this->startTime = microtime(true);\n        return $this;\n    }\n    public function end() : self\n    {\n        $this->endTime = microtime(true);\n        return $this;\n    }\n    public function setName(string $name) : self\n    {\n        $this->name = $name;\n        return $this;\n    }\n    public function setError(bool $error) : self\n    {\n        $this->error = $error;\n        return $this;\n    }\n    public function setFault(bool $fault) : self\n    {\n        $this->fault = $fault;\n        return $this;\n    }\n    public function addSubsegment(Segment $subsegment) : self\n    {\n        if (!$this->isOpen()) {\n            return $this;\n        }\n        $this->subsegments[] = $subsegment;\n        $subsegment->setSampled($this->isSampled());\n        return $this;\n    }\n    public function submit(SegmentSubmitter $submitter) : void\n    {\n        if (!$this->isSampled()) {\n            return;\n        }\n        $submitter->submitSegment($this);\n    }\n    public function isSampled() : bool\n    {\n        return $this->sampled;\n    }\n    public function setSampled(bool $sampled) : self\n    {\n        $this->sampled = $sampled;\n        return $this;\n    }\n    public function getId() : string\n    {\n        return $this->id;\n    }\n    public function setParentId(?string $parentId) : self\n    {\n        $this->parentId = $parentId;\n        return $this;\n    }\n    public function setTraceId(string $traceId) : self\n    {\n        $this->traceId = $traceId;\n        return $this;\n    }\n    public function getTraceId() : string\n    {\n        return $this->traceId;\n    }\n    public function isOpen() : bool\n    {\n        return isset($this->startTime) && !isset($this->endTime);\n    }\n    public function setIndependent(bool $independent) : self\n    {\n        $this->independent = $independent;\n        return $this;\n    }\n    public function addAnnotation(string $key, string $value) : self\n    {\n        $this->annotations[$key] = $value;\n        return $this;\n    }\n    public function addMetadata(string $key, mixed $value) : self\n    {\n        $this->metadata[$key] = $value;\n        return $this;\n    }\n    public function getCurrentSegment() : self\n    {\n        for ($max = count($this->subsegments); $this->lastOpenSegment < $max; $this->lastOpenSegment++) {\n            if ($this->subsegments[$this->lastOpenSegment]->isOpen()) {\n                return $this->subsegments[$this->lastOpenSegment]->getCurrentSegment();\n            }\n        }\n        return $this;\n    }\n    \/**\n     * @inheritDoc\n     * @return array<string, mixed>\n     *\/\n    public function jsonSerialize() : array\n    {\n        return array_filter(['id' => $this->id, 'parent_id' => $this->parentId, 'trace_id' => $this->traceId ?? null, 'name' => $this->name, 'start_time' => $this->startTime ?? null, 'end_time' => $this->endTime ?? null, 'subsegments' => $this->subsegments ?? null ?: null, 'type' => $this->independent ? 'subsegment' : null, 'fault' => $this->fault ?? null, 'error' => $this->error ?? null, 'annotations' => $this->annotations ?? null ?: null, 'metadata' => $this->metadata ?? null ?: null]);\n    }\n}","mutatedSourceCode":"<?php\n\nnamespace Fido\\PHPXray;\n\nuse JsonSerializable;\nuse Fido\\PHPXray\\Submission\\SegmentSubmitter;\nclass Segment implements JsonSerializable\n{\n    protected string $id;\n    protected ?string $parentId = null;\n    protected string $traceId;\n    protected ?string $name = null;\n    protected float $startTime;\n    protected float $endTime;\n    \/** @var Segment[] *\/\n    protected array $subsegments = [];\n    protected bool $error = false;\n    protected bool $fault = false;\n    protected bool $sampled = false;\n    protected bool $independent = false;\n    \/** @var array<string, mixed> *\/\n    private array $annotations;\n    \/** @var array<string, mixed> *\/\n    private array $metadata;\n    private int $lastOpenSegment = 0;\n    \/**\n     * @throws \\Exception if an appropriate source of randomness cannot be found.\n     *\/\n    public function __construct()\n    {\n        $this->id = bin2hex(random_bytes(8));\n    }\n    public function setTraceHeader(string $traceHeader = null) : self\n    {\n        if (is_null($traceHeader)) {\n            return $this;\n        }\n        $parts = explode(';', $traceHeader);\n        $variables = array_map(function ($str) : array {\n            return explode('=', $str);\n        }, $parts);\n        $variables = array_column($variables, 1, 0);\n        if (isset($variables['Root'])) {\n            $this->setTraceId($variables['Root']);\n        }\n        if (isset($variables['Sampled'])) {\n            $this->setSampled((bool) $variables['Sampled'] ?? false);\n        }\n        if (isset($variables['Parent'])) {\n            $this->setParentId($variables['Parent'] ?? null);\n        }\n        return $this;\n    }\n    public function begin() : self\n    {\n        $this->startTime = microtime(true);\n        return $this;\n    }\n    public function end() : self\n    {\n        $this->endTime = microtime(true);\n        return $this;\n    }\n    public function setName(string $name) : self\n    {\n        $this->name = $name;\n        return $this;\n    }\n    public function setError(bool $error) : self\n    {\n        $this->error = $error;\n        return $this;\n    }\n    public function setFault(bool $fault) : self\n    {\n        $this->fault = $fault;\n        return $this;\n    }\n    public function addSubsegment(Segment $subsegment) : self\n    {\n        if (!$this->isOpen()) {\n            return $this;\n        }\n        $this->subsegments[] = $subsegment;\n        $subsegment->setSampled($this->isSampled());\n        return $this;\n    }\n    public function submit(SegmentSubmitter $submitter) : void\n    {\n        if (!$this->isSampled()) {\n            return;\n        }\n        $submitter->submitSegment($this);\n    }\n    public function isSampled() : bool\n    {\n        return $this->sampled;\n    }\n    public function setSampled(bool $sampled) : self\n    {\n        $this->sampled = $sampled;\n        return $this;\n    }\n    public function getId() : string\n    {\n        return $this->id;\n    }\n    public function setParentId(?string $parentId) : self\n    {\n        $this->parentId = $parentId;\n        return $this;\n    }\n    public function setTraceId(string $traceId) : self\n    {\n        $this->traceId = $traceId;\n        return $this;\n    }\n    public function getTraceId() : string\n    {\n        return $this->traceId;\n    }\n    public function isOpen() : bool\n    {\n        return isset($this->startTime) || !isset($this->endTime);\n    }\n    public function setIndependent(bool $independent) : self\n    {\n        $this->independent = $independent;\n        return $this;\n    }\n    public function addAnnotation(string $key, string $value) : self\n    {\n        $this->annotations[$key] = $value;\n        return $this;\n    }\n    public function addMetadata(string $key, mixed $value) : self\n    {\n        $this->metadata[$key] = $value;\n        return $this;\n    }\n    public function getCurrentSegment() : self\n    {\n        for ($max = count($this->subsegments); $this->lastOpenSegment < $max; $this->lastOpenSegment++) {\n            if ($this->subsegments[$this->lastOpenSegment]->isOpen()) {\n                return $this->subsegments[$this->lastOpenSegment]->getCurrentSegment();\n            }\n        }\n        return $this;\n    }\n    \/**\n     * @inheritDoc\n     * @return array<string, mixed>\n     *\/\n    public function jsonSerialize() : array\n    {\n        return array_filter(['id' => $this->id, 'parent_id' => $this->parentId, 'trace_id' => $this->traceId ?? null, 'name' => $this->name, 'start_time' => $this->startTime ?? null, 'end_time' => $this->endTime ?? null, 'subsegments' => $this->subsegments ?? null ?: null, 'type' => $this->independent ? 'subsegment' : null, 'fault' => $this->fault ?? null, 'error' => $this->error ?? null, 'annotations' => $this->annotations ?? null ?: null, 'metadata' => $this->metadata ?? null ?: null]);\n    }\n}","originalFilePath":"\/home\/ranpafin\/php-xray\/src\/Segment.php","originalStartLine":157},"diff":"--- Original\n+++ New\n@@ @@\n     }\n     public function isOpen() : bool\n     {\n-        return isset($this->startTime) && !isset($this->endTime);\n+        return isset($this->startTime) || !isset($this->endTime);\n     }\n     public function setIndependent(bool $independent) : self\n     {","processOutput":"PHPUnit 9.5.10 by Sebastian Bergmann and contributors.\n\nRuntime:       PHP 8.0.13\nConfiguration: \/tmp\/tmp-folder\/infection\/phpunitConfiguration.184702e88056be2769e13a15962d8927.infection.xml\n\nE\n\nTime: 00:00.003, Memory: 8.00 MB\n\nThere was 1 error:\n\n1) Fido\\PHPXray\\DaemonSegmentSubmitterTest::testSubmitsToDaemon\nsocket_bind(): Unable to bind address [98]: Address already in use\n\n\/home\/ranpafin\/php-xray\/tests\/DaemonSegmentSubmitterTest.php:18\n\nERRORS!\nTests: 1, Assertions: 0, Errors: 1."},{"mutator":{"mutatorName":"PublicVisibility","originalSourceCode":"<?php\n\nnamespace Fido\\PHPXray;\n\nuse JsonSerializable;\nuse Fido\\PHPXray\\Submission\\SegmentSubmitter;\nclass Segment implements JsonSerializable\n{\n    protected string $id;\n    protected ?string $parentId = null;\n    protected string $traceId;\n    protected ?string $name = null;\n    protected float $startTime;\n    protected float $endTime;\n    \/** @var Segment[] *\/\n    protected array $subsegments = [];\n    protected bool $error = false;\n    protected bool $fault = false;\n    protected bool $sampled = false;\n    protected bool $independent = false;\n    \/** @var array<string, mixed> *\/\n    private array $annotations;\n    \/** @var array<string, mixed> *\/\n    private array $metadata;\n    private int $lastOpenSegment = 0;\n    \/**\n     * @throws \\Exception if an appropriate source of randomness cannot be found.\n     *\/\n    public function __construct()\n    {\n        $this->id = bin2hex(random_bytes(8));\n    }\n    public function setTraceHeader(string $traceHeader = null) : self\n    {\n        if (is_null($traceHeader)) {\n            return $this;\n        }\n        $parts = explode(';', $traceHeader);\n        $variables = array_map(function ($str) : array {\n            return explode('=', $str);\n        }, $parts);\n        $variables = array_column($variables, 1, 0);\n        if (isset($variables['Root'])) {\n            $this->setTraceId($variables['Root']);\n        }\n        if (isset($variables['Sampled'])) {\n            $this->setSampled((bool) $variables['Sampled'] ?? false);\n        }\n        if (isset($variables['Parent'])) {\n            $this->setParentId($variables['Parent'] ?? null);\n        }\n        return $this;\n    }\n    public function begin() : self\n    {\n        $this->startTime = microtime(true);\n        return $this;\n    }\n    public function end() : self\n    {\n        $this->endTime = microtime(true);\n        return $this;\n    }\n    public function setName(string $name) : self\n    {\n        $this->name = $name;\n        return $this;\n    }\n    public function setError(bool $error) : self\n    {\n        $this->error = $error;\n        return $this;\n    }\n    public function setFault(bool $fault) : self\n    {\n        $this->fault = $fault;\n        return $this;\n    }\n    public function addSubsegment(Segment $subsegment) : self\n    {\n        if (!$this->isOpen()) {\n            return $this;\n        }\n        $this->subsegments[] = $subsegment;\n        $subsegment->setSampled($this->isSampled());\n        return $this;\n    }\n    public function submit(SegmentSubmitter $submitter) : void\n    {\n        if (!$this->isSampled()) {\n            return;\n        }\n        $submitter->submitSegment($this);\n    }\n    public function isSampled() : bool\n    {\n        return $this->sampled;\n    }\n    public function setSampled(bool $sampled) : self\n    {\n        $this->sampled = $sampled;\n        return $this;\n    }\n    public function getId() : string\n    {\n        return $this->id;\n    }\n    public function setParentId(?string $parentId) : self\n    {\n        $this->parentId = $parentId;\n        return $this;\n    }\n    public function setTraceId(string $traceId) : self\n    {\n        $this->traceId = $traceId;\n        return $this;\n    }\n    public function getTraceId() : string\n    {\n        return $this->traceId;\n    }\n    public function isOpen() : bool\n    {\n        return isset($this->startTime) && !isset($this->endTime);\n    }\n    public function setIndependent(bool $independent) : self\n    {\n        $this->independent = $independent;\n        return $this;\n    }\n    public function addAnnotation(string $key, string $value) : self\n    {\n        $this->annotations[$key] = $value;\n        return $this;\n    }\n    public function addMetadata(string $key, mixed $value) : self\n    {\n        $this->metadata[$key] = $value;\n        return $this;\n    }\n    public function getCurrentSegment() : self\n    {\n        for ($max = count($this->subsegments); $this->lastOpenSegment < $max; $this->lastOpenSegment++) {\n            if ($this->subsegments[$this->lastOpenSegment]->isOpen()) {\n                return $this->subsegments[$this->lastOpenSegment]->getCurrentSegment();\n            }\n        }\n        return $this;\n    }\n    \/**\n     * @inheritDoc\n     * @return array<string, mixed>\n     *\/\n    public function jsonSerialize() : array\n    {\n        return array_filter(['id' => $this->id, 'parent_id' => $this->parentId, 'trace_id' => $this->traceId ?? null, 'name' => $this->name, 'start_time' => $this->startTime ?? null, 'end_time' => $this->endTime ?? null, 'subsegments' => $this->subsegments ?? null ?: null, 'type' => $this->independent ? 'subsegment' : null, 'fault' => $this->fault ?? null, 'error' => $this->error ?? null, 'annotations' => $this->annotations ?? null ?: null, 'metadata' => $this->metadata ?? null ?: null]);\n    }\n}","mutatedSourceCode":"<?php\n\nnamespace Fido\\PHPXray;\n\nuse JsonSerializable;\nuse Fido\\PHPXray\\Submission\\SegmentSubmitter;\nclass Segment implements JsonSerializable\n{\n    protected string $id;\n    protected ?string $parentId = null;\n    protected string $traceId;\n    protected ?string $name = null;\n    protected float $startTime;\n    protected float $endTime;\n    \/** @var Segment[] *\/\n    protected array $subsegments = [];\n    protected bool $error = false;\n    protected bool $fault = false;\n    protected bool $sampled = false;\n    protected bool $independent = false;\n    \/** @var array<string, mixed> *\/\n    private array $annotations;\n    \/** @var array<string, mixed> *\/\n    private array $metadata;\n    private int $lastOpenSegment = 0;\n    \/**\n     * @throws \\Exception if an appropriate source of randomness cannot be found.\n     *\/\n    public function __construct()\n    {\n        $this->id = bin2hex(random_bytes(8));\n    }\n    public function setTraceHeader(string $traceHeader = null) : self\n    {\n        if (is_null($traceHeader)) {\n            return $this;\n        }\n        $parts = explode(';', $traceHeader);\n        $variables = array_map(function ($str) : array {\n            return explode('=', $str);\n        }, $parts);\n        $variables = array_column($variables, 1, 0);\n        if (isset($variables['Root'])) {\n            $this->setTraceId($variables['Root']);\n        }\n        if (isset($variables['Sampled'])) {\n            $this->setSampled((bool) $variables['Sampled'] ?? false);\n        }\n        if (isset($variables['Parent'])) {\n            $this->setParentId($variables['Parent'] ?? null);\n        }\n        return $this;\n    }\n    public function begin() : self\n    {\n        $this->startTime = microtime(true);\n        return $this;\n    }\n    public function end() : self\n    {\n        $this->endTime = microtime(true);\n        return $this;\n    }\n    public function setName(string $name) : self\n    {\n        $this->name = $name;\n        return $this;\n    }\n    public function setError(bool $error) : self\n    {\n        $this->error = $error;\n        return $this;\n    }\n    public function setFault(bool $fault) : self\n    {\n        $this->fault = $fault;\n        return $this;\n    }\n    public function addSubsegment(Segment $subsegment) : self\n    {\n        if (!$this->isOpen()) {\n            return $this;\n        }\n        $this->subsegments[] = $subsegment;\n        $subsegment->setSampled($this->isSampled());\n        return $this;\n    }\n    public function submit(SegmentSubmitter $submitter) : void\n    {\n        if (!$this->isSampled()) {\n            return;\n        }\n        $submitter->submitSegment($this);\n    }\n    public function isSampled() : bool\n    {\n        return $this->sampled;\n    }\n    public function setSampled(bool $sampled) : self\n    {\n        $this->sampled = $sampled;\n        return $this;\n    }\n    public function getId() : string\n    {\n        return $this->id;\n    }\n    public function setParentId(?string $parentId) : self\n    {\n        $this->parentId = $parentId;\n        return $this;\n    }\n    public function setTraceId(string $traceId) : self\n    {\n        $this->traceId = $traceId;\n        return $this;\n    }\n    public function getTraceId() : string\n    {\n        return $this->traceId;\n    }\n    public function isOpen() : bool\n    {\n        return isset($this->startTime) && !isset($this->endTime);\n    }\n    protected function setIndependent(bool $independent) : self\n    {\n        $this->independent = $independent;\n        return $this;\n    }\n    public function addAnnotation(string $key, string $value) : self\n    {\n        $this->annotations[$key] = $value;\n        return $this;\n    }\n    public function addMetadata(string $key, mixed $value) : self\n    {\n        $this->metadata[$key] = $value;\n        return $this;\n    }\n    public function getCurrentSegment() : self\n    {\n        for ($max = count($this->subsegments); $this->lastOpenSegment < $max; $this->lastOpenSegment++) {\n            if ($this->subsegments[$this->lastOpenSegment]->isOpen()) {\n                return $this->subsegments[$this->lastOpenSegment]->getCurrentSegment();\n            }\n        }\n        return $this;\n    }\n    \/**\n     * @inheritDoc\n     * @return array<string, mixed>\n     *\/\n    public function jsonSerialize() : array\n    {\n        return array_filter(['id' => $this->id, 'parent_id' => $this->parentId, 'trace_id' => $this->traceId ?? null, 'name' => $this->name, 'start_time' => $this->startTime ?? null, 'end_time' => $this->endTime ?? null, 'subsegments' => $this->subsegments ?? null ?: null, 'type' => $this->independent ? 'subsegment' : null, 'fault' => $this->fault ?? null, 'error' => $this->error ?? null, 'annotations' => $this->annotations ?? null ?: null, 'metadata' => $this->metadata ?? null ?: null]);\n    }\n}","originalFilePath":"\/home\/ranpafin\/php-xray\/src\/Segment.php","originalStartLine":160},"diff":"--- Original\n+++ New\n@@ @@\n     {\n         return isset($this->startTime) && !isset($this->endTime);\n     }\n-    public function setIndependent(bool $independent) : self\n+    protected function setIndependent(bool $independent) : self\n     {\n         $this->independent = $independent;\n         return $this;","processOutput":"PHPUnit 9.5.10 by Sebastian Bergmann and contributors.\n\nRuntime:       PHP 8.0.13\nConfiguration: \/tmp\/tmp-folder\/infection\/phpunitConfiguration.3c1d8dac96c14d51deef6b431f3a04a9.infection.xml\n\nE\n\nTime: 00:00.003, Memory: 8.00 MB\n\nThere was 1 error:\n\n1) Fido\\PHPXray\\DaemonSegmentSubmitterTest::testSubmitsToDaemon\nsocket_bind(): Unable to bind address [98]: Address already in use\n\n\/home\/ranpafin\/php-xray\/tests\/DaemonSegmentSubmitterTest.php:18\n\nERRORS!\nTests: 1, Assertions: 0, Errors: 1."},{"mutator":{"mutatorName":"PublicVisibility","originalSourceCode":"<?php\n\nnamespace Fido\\PHPXray;\n\nuse JsonSerializable;\nuse Fido\\PHPXray\\Submission\\SegmentSubmitter;\nclass Segment implements JsonSerializable\n{\n    protected string $id;\n    protected ?string $parentId = null;\n    protected string $traceId;\n    protected ?string $name = null;\n    protected float $startTime;\n    protected float $endTime;\n    \/** @var Segment[] *\/\n    protected array $subsegments = [];\n    protected bool $error = false;\n    protected bool $fault = false;\n    protected bool $sampled = false;\n    protected bool $independent = false;\n    \/** @var array<string, mixed> *\/\n    private array $annotations;\n    \/** @var array<string, mixed> *\/\n    private array $metadata;\n    private int $lastOpenSegment = 0;\n    \/**\n     * @throws \\Exception if an appropriate source of randomness cannot be found.\n     *\/\n    public function __construct()\n    {\n        $this->id = bin2hex(random_bytes(8));\n    }\n    public function setTraceHeader(string $traceHeader = null) : self\n    {\n        if (is_null($traceHeader)) {\n            return $this;\n        }\n        $parts = explode(';', $traceHeader);\n        $variables = array_map(function ($str) : array {\n            return explode('=', $str);\n        }, $parts);\n        $variables = array_column($variables, 1, 0);\n        if (isset($variables['Root'])) {\n            $this->setTraceId($variables['Root']);\n        }\n        if (isset($variables['Sampled'])) {\n            $this->setSampled((bool) $variables['Sampled'] ?? false);\n        }\n        if (isset($variables['Parent'])) {\n            $this->setParentId($variables['Parent'] ?? null);\n        }\n        return $this;\n    }\n    public function begin() : self\n    {\n        $this->startTime = microtime(true);\n        return $this;\n    }\n    public function end() : self\n    {\n        $this->endTime = microtime(true);\n        return $this;\n    }\n    public function setName(string $name) : self\n    {\n        $this->name = $name;\n        return $this;\n    }\n    public function setError(bool $error) : self\n    {\n        $this->error = $error;\n        return $this;\n    }\n    public function setFault(bool $fault) : self\n    {\n        $this->fault = $fault;\n        return $this;\n    }\n    public function addSubsegment(Segment $subsegment) : self\n    {\n        if (!$this->isOpen()) {\n            return $this;\n        }\n        $this->subsegments[] = $subsegment;\n        $subsegment->setSampled($this->isSampled());\n        return $this;\n    }\n    public function submit(SegmentSubmitter $submitter) : void\n    {\n        if (!$this->isSampled()) {\n            return;\n        }\n        $submitter->submitSegment($this);\n    }\n    public function isSampled() : bool\n    {\n        return $this->sampled;\n    }\n    public function setSampled(bool $sampled) : self\n    {\n        $this->sampled = $sampled;\n        return $this;\n    }\n    public function getId() : string\n    {\n        return $this->id;\n    }\n    public function setParentId(?string $parentId) : self\n    {\n        $this->parentId = $parentId;\n        return $this;\n    }\n    public function setTraceId(string $traceId) : self\n    {\n        $this->traceId = $traceId;\n        return $this;\n    }\n    public function getTraceId() : string\n    {\n        return $this->traceId;\n    }\n    public function isOpen() : bool\n    {\n        return isset($this->startTime) && !isset($this->endTime);\n    }\n    public function setIndependent(bool $independent) : self\n    {\n        $this->independent = $independent;\n        return $this;\n    }\n    public function addAnnotation(string $key, string $value) : self\n    {\n        $this->annotations[$key] = $value;\n        return $this;\n    }\n    public function addMetadata(string $key, mixed $value) : self\n    {\n        $this->metadata[$key] = $value;\n        return $this;\n    }\n    public function getCurrentSegment() : self\n    {\n        for ($max = count($this->subsegments); $this->lastOpenSegment < $max; $this->lastOpenSegment++) {\n            if ($this->subsegments[$this->lastOpenSegment]->isOpen()) {\n                return $this->subsegments[$this->lastOpenSegment]->getCurrentSegment();\n            }\n        }\n        return $this;\n    }\n    \/**\n     * @inheritDoc\n     * @return array<string, mixed>\n     *\/\n    public function jsonSerialize() : array\n    {\n        return array_filter(['id' => $this->id, 'parent_id' => $this->parentId, 'trace_id' => $this->traceId ?? null, 'name' => $this->name, 'start_time' => $this->startTime ?? null, 'end_time' => $this->endTime ?? null, 'subsegments' => $this->subsegments ?? null ?: null, 'type' => $this->independent ? 'subsegment' : null, 'fault' => $this->fault ?? null, 'error' => $this->error ?? null, 'annotations' => $this->annotations ?? null ?: null, 'metadata' => $this->metadata ?? null ?: null]);\n    }\n}","mutatedSourceCode":"<?php\n\nnamespace Fido\\PHPXray;\n\nuse JsonSerializable;\nuse Fido\\PHPXray\\Submission\\SegmentSubmitter;\nclass Segment implements JsonSerializable\n{\n    protected string $id;\n    protected ?string $parentId = null;\n    protected string $traceId;\n    protected ?string $name = null;\n    protected float $startTime;\n    protected float $endTime;\n    \/** @var Segment[] *\/\n    protected array $subsegments = [];\n    protected bool $error = false;\n    protected bool $fault = false;\n    protected bool $sampled = false;\n    protected bool $independent = false;\n    \/** @var array<string, mixed> *\/\n    private array $annotations;\n    \/** @var array<string, mixed> *\/\n    private array $metadata;\n    private int $lastOpenSegment = 0;\n    \/**\n     * @throws \\Exception if an appropriate source of randomness cannot be found.\n     *\/\n    public function __construct()\n    {\n        $this->id = bin2hex(random_bytes(8));\n    }\n    public function setTraceHeader(string $traceHeader = null) : self\n    {\n        if (is_null($traceHeader)) {\n            return $this;\n        }\n        $parts = explode(';', $traceHeader);\n        $variables = array_map(function ($str) : array {\n            return explode('=', $str);\n        }, $parts);\n        $variables = array_column($variables, 1, 0);\n        if (isset($variables['Root'])) {\n            $this->setTraceId($variables['Root']);\n        }\n        if (isset($variables['Sampled'])) {\n            $this->setSampled((bool) $variables['Sampled'] ?? false);\n        }\n        if (isset($variables['Parent'])) {\n            $this->setParentId($variables['Parent'] ?? null);\n        }\n        return $this;\n    }\n    public function begin() : self\n    {\n        $this->startTime = microtime(true);\n        return $this;\n    }\n    public function end() : self\n    {\n        $this->endTime = microtime(true);\n        return $this;\n    }\n    public function setName(string $name) : self\n    {\n        $this->name = $name;\n        return $this;\n    }\n    public function setError(bool $error) : self\n    {\n        $this->error = $error;\n        return $this;\n    }\n    public function setFault(bool $fault) : self\n    {\n        $this->fault = $fault;\n        return $this;\n    }\n    public function addSubsegment(Segment $subsegment) : self\n    {\n        if (!$this->isOpen()) {\n            return $this;\n        }\n        $this->subsegments[] = $subsegment;\n        $subsegment->setSampled($this->isSampled());\n        return $this;\n    }\n    public function submit(SegmentSubmitter $submitter) : void\n    {\n        if (!$this->isSampled()) {\n            return;\n        }\n        $submitter->submitSegment($this);\n    }\n    public function isSampled() : bool\n    {\n        return $this->sampled;\n    }\n    public function setSampled(bool $sampled) : self\n    {\n        $this->sampled = $sampled;\n        return $this;\n    }\n    public function getId() : string\n    {\n        return $this->id;\n    }\n    public function setParentId(?string $parentId) : self\n    {\n        $this->parentId = $parentId;\n        return $this;\n    }\n    public function setTraceId(string $traceId) : self\n    {\n        $this->traceId = $traceId;\n        return $this;\n    }\n    public function getTraceId() : string\n    {\n        return $this->traceId;\n    }\n    public function isOpen() : bool\n    {\n        return isset($this->startTime) && !isset($this->endTime);\n    }\n    public function setIndependent(bool $independent) : self\n    {\n        $this->independent = $independent;\n        return $this;\n    }\n    protected function addAnnotation(string $key, string $value) : self\n    {\n        $this->annotations[$key] = $value;\n        return $this;\n    }\n    public function addMetadata(string $key, mixed $value) : self\n    {\n        $this->metadata[$key] = $value;\n        return $this;\n    }\n    public function getCurrentSegment() : self\n    {\n        for ($max = count($this->subsegments); $this->lastOpenSegment < $max; $this->lastOpenSegment++) {\n            if ($this->subsegments[$this->lastOpenSegment]->isOpen()) {\n                return $this->subsegments[$this->lastOpenSegment]->getCurrentSegment();\n            }\n        }\n        return $this;\n    }\n    \/**\n     * @inheritDoc\n     * @return array<string, mixed>\n     *\/\n    public function jsonSerialize() : array\n    {\n        return array_filter(['id' => $this->id, 'parent_id' => $this->parentId, 'trace_id' => $this->traceId ?? null, 'name' => $this->name, 'start_time' => $this->startTime ?? null, 'end_time' => $this->endTime ?? null, 'subsegments' => $this->subsegments ?? null ?: null, 'type' => $this->independent ? 'subsegment' : null, 'fault' => $this->fault ?? null, 'error' => $this->error ?? null, 'annotations' => $this->annotations ?? null ?: null, 'metadata' => $this->metadata ?? null ?: null]);\n    }\n}","originalFilePath":"\/home\/ranpafin\/php-xray\/src\/Segment.php","originalStartLine":167},"diff":"--- Original\n+++ New\n@@ @@\n         $this->independent = $independent;\n         return $this;\n     }\n-    public function addAnnotation(string $key, string $value) : self\n+    protected function addAnnotation(string $key, string $value) : self\n     {\n         $this->annotations[$key] = $value;\n         return $this;","processOutput":"PHPUnit 9.5.10 by Sebastian Bergmann and contributors.\n\nRuntime:       PHP 8.0.13\nConfiguration: \/tmp\/tmp-folder\/infection\/phpunitConfiguration.52b528255ac2d762ae9a8c47ca02a54d.infection.xml\n\nE\n\nTime: 00:00.004, Memory: 8.00 MB\n\nThere was 1 error:\n\n1) Fido\\PHPXray\\SegmentTest::testGivenAnnotationsSerialisesCorrectly\nError: Call to protected method Fido\\PHPXray\\Segment::addAnnotation() from scope Fido\\PHPXray\\SegmentTest\n\n\/home\/ranpafin\/php-xray\/tests\/SegmentTest.php:126\n\nERRORS!\nTests: 1, Assertions: 0, Errors: 1."},{"mutator":{"mutatorName":"PublicVisibility","originalSourceCode":"<?php\n\nnamespace Fido\\PHPXray;\n\nuse JsonSerializable;\nuse Fido\\PHPXray\\Submission\\SegmentSubmitter;\nclass Segment implements JsonSerializable\n{\n    protected string $id;\n    protected ?string $parentId = null;\n    protected string $traceId;\n    protected ?string $name = null;\n    protected float $startTime;\n    protected float $endTime;\n    \/** @var Segment[] *\/\n    protected array $subsegments = [];\n    protected bool $error = false;\n    protected bool $fault = false;\n    protected bool $sampled = false;\n    protected bool $independent = false;\n    \/** @var array<string, mixed> *\/\n    private array $annotations;\n    \/** @var array<string, mixed> *\/\n    private array $metadata;\n    private int $lastOpenSegment = 0;\n    \/**\n     * @throws \\Exception if an appropriate source of randomness cannot be found.\n     *\/\n    public function __construct()\n    {\n        $this->id = bin2hex(random_bytes(8));\n    }\n    public function setTraceHeader(string $traceHeader = null) : self\n    {\n        if (is_null($traceHeader)) {\n            return $this;\n        }\n        $parts = explode(';', $traceHeader);\n        $variables = array_map(function ($str) : array {\n            return explode('=', $str);\n        }, $parts);\n        $variables = array_column($variables, 1, 0);\n        if (isset($variables['Root'])) {\n            $this->setTraceId($variables['Root']);\n        }\n        if (isset($variables['Sampled'])) {\n            $this->setSampled((bool) $variables['Sampled'] ?? false);\n        }\n        if (isset($variables['Parent'])) {\n            $this->setParentId($variables['Parent'] ?? null);\n        }\n        return $this;\n    }\n    public function begin() : self\n    {\n        $this->startTime = microtime(true);\n        return $this;\n    }\n    public function end() : self\n    {\n        $this->endTime = microtime(true);\n        return $this;\n    }\n    public function setName(string $name) : self\n    {\n        $this->name = $name;\n        return $this;\n    }\n    public function setError(bool $error) : self\n    {\n        $this->error = $error;\n        return $this;\n    }\n    public function setFault(bool $fault) : self\n    {\n        $this->fault = $fault;\n        return $this;\n    }\n    public function addSubsegment(Segment $subsegment) : self\n    {\n        if (!$this->isOpen()) {\n            return $this;\n        }\n        $this->subsegments[] = $subsegment;\n        $subsegment->setSampled($this->isSampled());\n        return $this;\n    }\n    public function submit(SegmentSubmitter $submitter) : void\n    {\n        if (!$this->isSampled()) {\n            return;\n        }\n        $submitter->submitSegment($this);\n    }\n    public function isSampled() : bool\n    {\n        return $this->sampled;\n    }\n    public function setSampled(bool $sampled) : self\n    {\n        $this->sampled = $sampled;\n        return $this;\n    }\n    public function getId() : string\n    {\n        return $this->id;\n    }\n    public function setParentId(?string $parentId) : self\n    {\n        $this->parentId = $parentId;\n        return $this;\n    }\n    public function setTraceId(string $traceId) : self\n    {\n        $this->traceId = $traceId;\n        return $this;\n    }\n    public function getTraceId() : string\n    {\n        return $this->traceId;\n    }\n    public function isOpen() : bool\n    {\n        return isset($this->startTime) && !isset($this->endTime);\n    }\n    public function setIndependent(bool $independent) : self\n    {\n        $this->independent = $independent;\n        return $this;\n    }\n    public function addAnnotation(string $key, string $value) : self\n    {\n        $this->annotations[$key] = $value;\n        return $this;\n    }\n    public function addMetadata(string $key, mixed $value) : self\n    {\n        $this->metadata[$key] = $value;\n        return $this;\n    }\n    public function getCurrentSegment() : self\n    {\n        for ($max = count($this->subsegments); $this->lastOpenSegment < $max; $this->lastOpenSegment++) {\n            if ($this->subsegments[$this->lastOpenSegment]->isOpen()) {\n                return $this->subsegments[$this->lastOpenSegment]->getCurrentSegment();\n            }\n        }\n        return $this;\n    }\n    \/**\n     * @inheritDoc\n     * @return array<string, mixed>\n     *\/\n    public function jsonSerialize() : array\n    {\n        return array_filter(['id' => $this->id, 'parent_id' => $this->parentId, 'trace_id' => $this->traceId ?? null, 'name' => $this->name, 'start_time' => $this->startTime ?? null, 'end_time' => $this->endTime ?? null, 'subsegments' => $this->subsegments ?? null ?: null, 'type' => $this->independent ? 'subsegment' : null, 'fault' => $this->fault ?? null, 'error' => $this->error ?? null, 'annotations' => $this->annotations ?? null ?: null, 'metadata' => $this->metadata ?? null ?: null]);\n    }\n}","mutatedSourceCode":"<?php\n\nnamespace Fido\\PHPXray;\n\nuse JsonSerializable;\nuse Fido\\PHPXray\\Submission\\SegmentSubmitter;\nclass Segment implements JsonSerializable\n{\n    protected string $id;\n    protected ?string $parentId = null;\n    protected string $traceId;\n    protected ?string $name = null;\n    protected float $startTime;\n    protected float $endTime;\n    \/** @var Segment[] *\/\n    protected array $subsegments = [];\n    protected bool $error = false;\n    protected bool $fault = false;\n    protected bool $sampled = false;\n    protected bool $independent = false;\n    \/** @var array<string, mixed> *\/\n    private array $annotations;\n    \/** @var array<string, mixed> *\/\n    private array $metadata;\n    private int $lastOpenSegment = 0;\n    \/**\n     * @throws \\Exception if an appropriate source of randomness cannot be found.\n     *\/\n    public function __construct()\n    {\n        $this->id = bin2hex(random_bytes(8));\n    }\n    public function setTraceHeader(string $traceHeader = null) : self\n    {\n        if (is_null($traceHeader)) {\n            return $this;\n        }\n        $parts = explode(';', $traceHeader);\n        $variables = array_map(function ($str) : array {\n            return explode('=', $str);\n        }, $parts);\n        $variables = array_column($variables, 1, 0);\n        if (isset($variables['Root'])) {\n            $this->setTraceId($variables['Root']);\n        }\n        if (isset($variables['Sampled'])) {\n            $this->setSampled((bool) $variables['Sampled'] ?? false);\n        }\n        if (isset($variables['Parent'])) {\n            $this->setParentId($variables['Parent'] ?? null);\n        }\n        return $this;\n    }\n    public function begin() : self\n    {\n        $this->startTime = microtime(true);\n        return $this;\n    }\n    public function end() : self\n    {\n        $this->endTime = microtime(true);\n        return $this;\n    }\n    public function setName(string $name) : self\n    {\n        $this->name = $name;\n        return $this;\n    }\n    public function setError(bool $error) : self\n    {\n        $this->error = $error;\n        return $this;\n    }\n    public function setFault(bool $fault) : self\n    {\n        $this->fault = $fault;\n        return $this;\n    }\n    public function addSubsegment(Segment $subsegment) : self\n    {\n        if (!$this->isOpen()) {\n            return $this;\n        }\n        $this->subsegments[] = $subsegment;\n        $subsegment->setSampled($this->isSampled());\n        return $this;\n    }\n    public function submit(SegmentSubmitter $submitter) : void\n    {\n        if (!$this->isSampled()) {\n            return;\n        }\n        $submitter->submitSegment($this);\n    }\n    public function isSampled() : bool\n    {\n        return $this->sampled;\n    }\n    public function setSampled(bool $sampled) : self\n    {\n        $this->sampled = $sampled;\n        return $this;\n    }\n    public function getId() : string\n    {\n        return $this->id;\n    }\n    public function setParentId(?string $parentId) : self\n    {\n        $this->parentId = $parentId;\n        return $this;\n    }\n    public function setTraceId(string $traceId) : self\n    {\n        $this->traceId = $traceId;\n        return $this;\n    }\n    public function getTraceId() : string\n    {\n        return $this->traceId;\n    }\n    public function isOpen() : bool\n    {\n        return isset($this->startTime) && !isset($this->endTime);\n    }\n    public function setIndependent(bool $independent) : self\n    {\n        $this->independent = $independent;\n        return $this;\n    }\n    public function addAnnotation(string $key, string $value) : self\n    {\n        $this->annotations[$key] = $value;\n        return $this;\n    }\n    protected function addMetadata(string $key, mixed $value) : self\n    {\n        $this->metadata[$key] = $value;\n        return $this;\n    }\n    public function getCurrentSegment() : self\n    {\n        for ($max = count($this->subsegments); $this->lastOpenSegment < $max; $this->lastOpenSegment++) {\n            if ($this->subsegments[$this->lastOpenSegment]->isOpen()) {\n                return $this->subsegments[$this->lastOpenSegment]->getCurrentSegment();\n            }\n        }\n        return $this;\n    }\n    \/**\n     * @inheritDoc\n     * @return array<string, mixed>\n     *\/\n    public function jsonSerialize() : array\n    {\n        return array_filter(['id' => $this->id, 'parent_id' => $this->parentId, 'trace_id' => $this->traceId ?? null, 'name' => $this->name, 'start_time' => $this->startTime ?? null, 'end_time' => $this->endTime ?? null, 'subsegments' => $this->subsegments ?? null ?: null, 'type' => $this->independent ? 'subsegment' : null, 'fault' => $this->fault ?? null, 'error' => $this->error ?? null, 'annotations' => $this->annotations ?? null ?: null, 'metadata' => $this->metadata ?? null ?: null]);\n    }\n}","originalFilePath":"\/home\/ranpafin\/php-xray\/src\/Segment.php","originalStartLine":174},"diff":"--- Original\n+++ New\n@@ @@\n         $this->annotations[$key] = $value;\n         return $this;\n     }\n-    public function addMetadata(string $key, mixed $value) : self\n+    protected function addMetadata(string $key, mixed $value) : self\n     {\n         $this->metadata[$key] = $value;\n         return $this;","processOutput":"PHPUnit 9.5.10 by Sebastian Bergmann and contributors.\n\nRuntime:       PHP 8.0.13\nConfiguration: \/tmp\/tmp-folder\/infection\/phpunitConfiguration.16362d5b8315b93d3f1959db503d5e8a.infection.xml\n\nE\n\nTime: 00:00.004, Memory: 8.00 MB\n\nThere was 1 error:\n\n1) Fido\\PHPXray\\SegmentTest::testGivenMetadataSerialisesCorrectly\nError: Call to protected method Fido\\PHPXray\\Segment::addMetadata() from scope Fido\\PHPXray\\SegmentTest\n\n\/home\/ranpafin\/php-xray\/tests\/SegmentTest.php:144\n\nERRORS!\nTests: 1, Assertions: 0, Errors: 1."},{"mutator":{"mutatorName":"PublicVisibility","originalSourceCode":"<?php\n\nnamespace Fido\\PHPXray;\n\nuse JsonSerializable;\nuse Fido\\PHPXray\\Submission\\SegmentSubmitter;\nclass Segment implements JsonSerializable\n{\n    protected string $id;\n    protected ?string $parentId = null;\n    protected string $traceId;\n    protected ?string $name = null;\n    protected float $startTime;\n    protected float $endTime;\n    \/** @var Segment[] *\/\n    protected array $subsegments = [];\n    protected bool $error = false;\n    protected bool $fault = false;\n    protected bool $sampled = false;\n    protected bool $independent = false;\n    \/** @var array<string, mixed> *\/\n    private array $annotations;\n    \/** @var array<string, mixed> *\/\n    private array $metadata;\n    private int $lastOpenSegment = 0;\n    \/**\n     * @throws \\Exception if an appropriate source of randomness cannot be found.\n     *\/\n    public function __construct()\n    {\n        $this->id = bin2hex(random_bytes(8));\n    }\n    public function setTraceHeader(string $traceHeader = null) : self\n    {\n        if (is_null($traceHeader)) {\n            return $this;\n        }\n        $parts = explode(';', $traceHeader);\n        $variables = array_map(function ($str) : array {\n            return explode('=', $str);\n        }, $parts);\n        $variables = array_column($variables, 1, 0);\n        if (isset($variables['Root'])) {\n            $this->setTraceId($variables['Root']);\n        }\n        if (isset($variables['Sampled'])) {\n            $this->setSampled((bool) $variables['Sampled'] ?? false);\n        }\n        if (isset($variables['Parent'])) {\n            $this->setParentId($variables['Parent'] ?? null);\n        }\n        return $this;\n    }\n    public function begin() : self\n    {\n        $this->startTime = microtime(true);\n        return $this;\n    }\n    public function end() : self\n    {\n        $this->endTime = microtime(true);\n        return $this;\n    }\n    public function setName(string $name) : self\n    {\n        $this->name = $name;\n        return $this;\n    }\n    public function setError(bool $error) : self\n    {\n        $this->error = $error;\n        return $this;\n    }\n    public function setFault(bool $fault) : self\n    {\n        $this->fault = $fault;\n        return $this;\n    }\n    public function addSubsegment(Segment $subsegment) : self\n    {\n        if (!$this->isOpen()) {\n            return $this;\n        }\n        $this->subsegments[] = $subsegment;\n        $subsegment->setSampled($this->isSampled());\n        return $this;\n    }\n    public function submit(SegmentSubmitter $submitter) : void\n    {\n        if (!$this->isSampled()) {\n            return;\n        }\n        $submitter->submitSegment($this);\n    }\n    public function isSampled() : bool\n    {\n        return $this->sampled;\n    }\n    public function setSampled(bool $sampled) : self\n    {\n        $this->sampled = $sampled;\n        return $this;\n    }\n    public function getId() : string\n    {\n        return $this->id;\n    }\n    public function setParentId(?string $parentId) : self\n    {\n        $this->parentId = $parentId;\n        return $this;\n    }\n    public function setTraceId(string $traceId) : self\n    {\n        $this->traceId = $traceId;\n        return $this;\n    }\n    public function getTraceId() : string\n    {\n        return $this->traceId;\n    }\n    public function isOpen() : bool\n    {\n        return isset($this->startTime) && !isset($this->endTime);\n    }\n    public function setIndependent(bool $independent) : self\n    {\n        $this->independent = $independent;\n        return $this;\n    }\n    public function addAnnotation(string $key, string $value) : self\n    {\n        $this->annotations[$key] = $value;\n        return $this;\n    }\n    public function addMetadata(string $key, mixed $value) : self\n    {\n        $this->metadata[$key] = $value;\n        return $this;\n    }\n    public function getCurrentSegment() : self\n    {\n        for ($max = count($this->subsegments); $this->lastOpenSegment < $max; $this->lastOpenSegment++) {\n            if ($this->subsegments[$this->lastOpenSegment]->isOpen()) {\n                return $this->subsegments[$this->lastOpenSegment]->getCurrentSegment();\n            }\n        }\n        return $this;\n    }\n    \/**\n     * @inheritDoc\n     * @return array<string, mixed>\n     *\/\n    public function jsonSerialize() : array\n    {\n        return array_filter(['id' => $this->id, 'parent_id' => $this->parentId, 'trace_id' => $this->traceId ?? null, 'name' => $this->name, 'start_time' => $this->startTime ?? null, 'end_time' => $this->endTime ?? null, 'subsegments' => $this->subsegments ?? null ?: null, 'type' => $this->independent ? 'subsegment' : null, 'fault' => $this->fault ?? null, 'error' => $this->error ?? null, 'annotations' => $this->annotations ?? null ?: null, 'metadata' => $this->metadata ?? null ?: null]);\n    }\n}","mutatedSourceCode":"<?php\n\nnamespace Fido\\PHPXray;\n\nuse JsonSerializable;\nuse Fido\\PHPXray\\Submission\\SegmentSubmitter;\nclass Segment implements JsonSerializable\n{\n    protected string $id;\n    protected ?string $parentId = null;\n    protected string $traceId;\n    protected ?string $name = null;\n    protected float $startTime;\n    protected float $endTime;\n    \/** @var Segment[] *\/\n    protected array $subsegments = [];\n    protected bool $error = false;\n    protected bool $fault = false;\n    protected bool $sampled = false;\n    protected bool $independent = false;\n    \/** @var array<string, mixed> *\/\n    private array $annotations;\n    \/** @var array<string, mixed> *\/\n    private array $metadata;\n    private int $lastOpenSegment = 0;\n    \/**\n     * @throws \\Exception if an appropriate source of randomness cannot be found.\n     *\/\n    public function __construct()\n    {\n        $this->id = bin2hex(random_bytes(8));\n    }\n    public function setTraceHeader(string $traceHeader = null) : self\n    {\n        if (is_null($traceHeader)) {\n            return $this;\n        }\n        $parts = explode(';', $traceHeader);\n        $variables = array_map(function ($str) : array {\n            return explode('=', $str);\n        }, $parts);\n        $variables = array_column($variables, 1, 0);\n        if (isset($variables['Root'])) {\n            $this->setTraceId($variables['Root']);\n        }\n        if (isset($variables['Sampled'])) {\n            $this->setSampled((bool) $variables['Sampled'] ?? false);\n        }\n        if (isset($variables['Parent'])) {\n            $this->setParentId($variables['Parent'] ?? null);\n        }\n        return $this;\n    }\n    public function begin() : self\n    {\n        $this->startTime = microtime(true);\n        return $this;\n    }\n    public function end() : self\n    {\n        $this->endTime = microtime(true);\n        return $this;\n    }\n    public function setName(string $name) : self\n    {\n        $this->name = $name;\n        return $this;\n    }\n    public function setError(bool $error) : self\n    {\n        $this->error = $error;\n        return $this;\n    }\n    public function setFault(bool $fault) : self\n    {\n        $this->fault = $fault;\n        return $this;\n    }\n    public function addSubsegment(Segment $subsegment) : self\n    {\n        if (!$this->isOpen()) {\n            return $this;\n        }\n        $this->subsegments[] = $subsegment;\n        $subsegment->setSampled($this->isSampled());\n        return $this;\n    }\n    public function submit(SegmentSubmitter $submitter) : void\n    {\n        if (!$this->isSampled()) {\n            return;\n        }\n        $submitter->submitSegment($this);\n    }\n    public function isSampled() : bool\n    {\n        return $this->sampled;\n    }\n    public function setSampled(bool $sampled) : self\n    {\n        $this->sampled = $sampled;\n        return $this;\n    }\n    public function getId() : string\n    {\n        return $this->id;\n    }\n    public function setParentId(?string $parentId) : self\n    {\n        $this->parentId = $parentId;\n        return $this;\n    }\n    public function setTraceId(string $traceId) : self\n    {\n        $this->traceId = $traceId;\n        return $this;\n    }\n    public function getTraceId() : string\n    {\n        return $this->traceId;\n    }\n    public function isOpen() : bool\n    {\n        return isset($this->startTime) && !isset($this->endTime);\n    }\n    public function setIndependent(bool $independent) : self\n    {\n        $this->independent = $independent;\n        return $this;\n    }\n    public function addAnnotation(string $key, string $value) : self\n    {\n        $this->annotations[$key] = $value;\n        return $this;\n    }\n    public function addMetadata(string $key, mixed $value) : self\n    {\n        $this->metadata[$key] = $value;\n        return $this;\n    }\n    protected function getCurrentSegment() : self\n    {\n        for ($max = count($this->subsegments); $this->lastOpenSegment < $max; $this->lastOpenSegment++) {\n            if ($this->subsegments[$this->lastOpenSegment]->isOpen()) {\n                return $this->subsegments[$this->lastOpenSegment]->getCurrentSegment();\n            }\n        }\n        return $this;\n    }\n    \/**\n     * @inheritDoc\n     * @return array<string, mixed>\n     *\/\n    public function jsonSerialize() : array\n    {\n        return array_filter(['id' => $this->id, 'parent_id' => $this->parentId, 'trace_id' => $this->traceId ?? null, 'name' => $this->name, 'start_time' => $this->startTime ?? null, 'end_time' => $this->endTime ?? null, 'subsegments' => $this->subsegments ?? null ?: null, 'type' => $this->independent ? 'subsegment' : null, 'fault' => $this->fault ?? null, 'error' => $this->error ?? null, 'annotations' => $this->annotations ?? null ?: null, 'metadata' => $this->metadata ?? null ?: null]);\n    }\n}","originalFilePath":"\/home\/ranpafin\/php-xray\/src\/Segment.php","originalStartLine":181},"diff":"--- Original\n+++ New\n@@ @@\n         $this->metadata[$key] = $value;\n         return $this;\n     }\n-    public function getCurrentSegment() : self\n+    protected function getCurrentSegment() : self\n     {\n         for ($max = count($this->subsegments); $this->lastOpenSegment < $max; $this->lastOpenSegment++) {\n             if ($this->subsegments[$this->lastOpenSegment]->isOpen()) {","processOutput":"PHPUnit 9.5.10 by Sebastian Bergmann and contributors.\n\nRuntime:       PHP 8.0.13\nConfiguration: \/tmp\/tmp-folder\/infection\/phpunitConfiguration.26119041b380aace1ac3ad66e0e131c8.infection.xml\n\nE\n\nTime: 00:00.004, Memory: 8.00 MB\n\nThere was 1 error:\n\n1) Fido\\PHPXray\\SegmentTest::testGivenNoSubsegmentsCurrentSegmentReturnsSegment\nError: Call to protected method Fido\\PHPXray\\Segment::getCurrentSegment() from scope Fido\\PHPXray\\SegmentTest\n\n\/home\/ranpafin\/php-xray\/tests\/SegmentTest.php:258\n\nERRORS!\nTests: 1, Assertions: 0, Errors: 1."},{"mutator":{"mutatorName":"LessThan","originalSourceCode":"<?php\n\nnamespace Fido\\PHPXray;\n\nuse JsonSerializable;\nuse Fido\\PHPXray\\Submission\\SegmentSubmitter;\nclass Segment implements JsonSerializable\n{\n    protected string $id;\n    protected ?string $parentId = null;\n    protected string $traceId;\n    protected ?string $name = null;\n    protected float $startTime;\n    protected float $endTime;\n    \/** @var Segment[] *\/\n    protected array $subsegments = [];\n    protected bool $error = false;\n    protected bool $fault = false;\n    protected bool $sampled = false;\n    protected bool $independent = false;\n    \/** @var array<string, mixed> *\/\n    private array $annotations;\n    \/** @var array<string, mixed> *\/\n    private array $metadata;\n    private int $lastOpenSegment = 0;\n    \/**\n     * @throws \\Exception if an appropriate source of randomness cannot be found.\n     *\/\n    public function __construct()\n    {\n        $this->id = bin2hex(random_bytes(8));\n    }\n    public function setTraceHeader(string $traceHeader = null) : self\n    {\n        if (is_null($traceHeader)) {\n            return $this;\n        }\n        $parts = explode(';', $traceHeader);\n        $variables = array_map(function ($str) : array {\n            return explode('=', $str);\n        }, $parts);\n        $variables = array_column($variables, 1, 0);\n        if (isset($variables['Root'])) {\n            $this->setTraceId($variables['Root']);\n        }\n        if (isset($variables['Sampled'])) {\n            $this->setSampled((bool) $variables['Sampled'] ?? false);\n        }\n        if (isset($variables['Parent'])) {\n            $this->setParentId($variables['Parent'] ?? null);\n        }\n        return $this;\n    }\n    public function begin() : self\n    {\n        $this->startTime = microtime(true);\n        return $this;\n    }\n    public function end() : self\n    {\n        $this->endTime = microtime(true);\n        return $this;\n    }\n    public function setName(string $name) : self\n    {\n        $this->name = $name;\n        return $this;\n    }\n    public function setError(bool $error) : self\n    {\n        $this->error = $error;\n        return $this;\n    }\n    public function setFault(bool $fault) : self\n    {\n        $this->fault = $fault;\n        return $this;\n    }\n    public function addSubsegment(Segment $subsegment) : self\n    {\n        if (!$this->isOpen()) {\n            return $this;\n        }\n        $this->subsegments[] = $subsegment;\n        $subsegment->setSampled($this->isSampled());\n        return $this;\n    }\n    public function submit(SegmentSubmitter $submitter) : void\n    {\n        if (!$this->isSampled()) {\n            return;\n        }\n        $submitter->submitSegment($this);\n    }\n    public function isSampled() : bool\n    {\n        return $this->sampled;\n    }\n    public function setSampled(bool $sampled) : self\n    {\n        $this->sampled = $sampled;\n        return $this;\n    }\n    public function getId() : string\n    {\n        return $this->id;\n    }\n    public function setParentId(?string $parentId) : self\n    {\n        $this->parentId = $parentId;\n        return $this;\n    }\n    public function setTraceId(string $traceId) : self\n    {\n        $this->traceId = $traceId;\n        return $this;\n    }\n    public function getTraceId() : string\n    {\n        return $this->traceId;\n    }\n    public function isOpen() : bool\n    {\n        return isset($this->startTime) && !isset($this->endTime);\n    }\n    public function setIndependent(bool $independent) : self\n    {\n        $this->independent = $independent;\n        return $this;\n    }\n    public function addAnnotation(string $key, string $value) : self\n    {\n        $this->annotations[$key] = $value;\n        return $this;\n    }\n    public function addMetadata(string $key, mixed $value) : self\n    {\n        $this->metadata[$key] = $value;\n        return $this;\n    }\n    public function getCurrentSegment() : self\n    {\n        for ($max = count($this->subsegments); $this->lastOpenSegment < $max; $this->lastOpenSegment++) {\n            if ($this->subsegments[$this->lastOpenSegment]->isOpen()) {\n                return $this->subsegments[$this->lastOpenSegment]->getCurrentSegment();\n            }\n        }\n        return $this;\n    }\n    \/**\n     * @inheritDoc\n     * @return array<string, mixed>\n     *\/\n    public function jsonSerialize() : array\n    {\n        return array_filter(['id' => $this->id, 'parent_id' => $this->parentId, 'trace_id' => $this->traceId ?? null, 'name' => $this->name, 'start_time' => $this->startTime ?? null, 'end_time' => $this->endTime ?? null, 'subsegments' => $this->subsegments ?? null ?: null, 'type' => $this->independent ? 'subsegment' : null, 'fault' => $this->fault ?? null, 'error' => $this->error ?? null, 'annotations' => $this->annotations ?? null ?: null, 'metadata' => $this->metadata ?? null ?: null]);\n    }\n}","mutatedSourceCode":"<?php\n\nnamespace Fido\\PHPXray;\n\nuse JsonSerializable;\nuse Fido\\PHPXray\\Submission\\SegmentSubmitter;\nclass Segment implements JsonSerializable\n{\n    protected string $id;\n    protected ?string $parentId = null;\n    protected string $traceId;\n    protected ?string $name = null;\n    protected float $startTime;\n    protected float $endTime;\n    \/** @var Segment[] *\/\n    protected array $subsegments = [];\n    protected bool $error = false;\n    protected bool $fault = false;\n    protected bool $sampled = false;\n    protected bool $independent = false;\n    \/** @var array<string, mixed> *\/\n    private array $annotations;\n    \/** @var array<string, mixed> *\/\n    private array $metadata;\n    private int $lastOpenSegment = 0;\n    \/**\n     * @throws \\Exception if an appropriate source of randomness cannot be found.\n     *\/\n    public function __construct()\n    {\n        $this->id = bin2hex(random_bytes(8));\n    }\n    public function setTraceHeader(string $traceHeader = null) : self\n    {\n        if (is_null($traceHeader)) {\n            return $this;\n        }\n        $parts = explode(';', $traceHeader);\n        $variables = array_map(function ($str) : array {\n            return explode('=', $str);\n        }, $parts);\n        $variables = array_column($variables, 1, 0);\n        if (isset($variables['Root'])) {\n            $this->setTraceId($variables['Root']);\n        }\n        if (isset($variables['Sampled'])) {\n            $this->setSampled((bool) $variables['Sampled'] ?? false);\n        }\n        if (isset($variables['Parent'])) {\n            $this->setParentId($variables['Parent'] ?? null);\n        }\n        return $this;\n    }\n    public function begin() : self\n    {\n        $this->startTime = microtime(true);\n        return $this;\n    }\n    public function end() : self\n    {\n        $this->endTime = microtime(true);\n        return $this;\n    }\n    public function setName(string $name) : self\n    {\n        $this->name = $name;\n        return $this;\n    }\n    public function setError(bool $error) : self\n    {\n        $this->error = $error;\n        return $this;\n    }\n    public function setFault(bool $fault) : self\n    {\n        $this->fault = $fault;\n        return $this;\n    }\n    public function addSubsegment(Segment $subsegment) : self\n    {\n        if (!$this->isOpen()) {\n            return $this;\n        }\n        $this->subsegments[] = $subsegment;\n        $subsegment->setSampled($this->isSampled());\n        return $this;\n    }\n    public function submit(SegmentSubmitter $submitter) : void\n    {\n        if (!$this->isSampled()) {\n            return;\n        }\n        $submitter->submitSegment($this);\n    }\n    public function isSampled() : bool\n    {\n        return $this->sampled;\n    }\n    public function setSampled(bool $sampled) : self\n    {\n        $this->sampled = $sampled;\n        return $this;\n    }\n    public function getId() : string\n    {\n        return $this->id;\n    }\n    public function setParentId(?string $parentId) : self\n    {\n        $this->parentId = $parentId;\n        return $this;\n    }\n    public function setTraceId(string $traceId) : self\n    {\n        $this->traceId = $traceId;\n        return $this;\n    }\n    public function getTraceId() : string\n    {\n        return $this->traceId;\n    }\n    public function isOpen() : bool\n    {\n        return isset($this->startTime) && !isset($this->endTime);\n    }\n    public function setIndependent(bool $independent) : self\n    {\n        $this->independent = $independent;\n        return $this;\n    }\n    public function addAnnotation(string $key, string $value) : self\n    {\n        $this->annotations[$key] = $value;\n        return $this;\n    }\n    public function addMetadata(string $key, mixed $value) : self\n    {\n        $this->metadata[$key] = $value;\n        return $this;\n    }\n    public function getCurrentSegment() : self\n    {\n        for ($max = count($this->subsegments); $this->lastOpenSegment <= $max; $this->lastOpenSegment++) {\n            if ($this->subsegments[$this->lastOpenSegment]->isOpen()) {\n                return $this->subsegments[$this->lastOpenSegment]->getCurrentSegment();\n            }\n        }\n        return $this;\n    }\n    \/**\n     * @inheritDoc\n     * @return array<string, mixed>\n     *\/\n    public function jsonSerialize() : array\n    {\n        return array_filter(['id' => $this->id, 'parent_id' => $this->parentId, 'trace_id' => $this->traceId ?? null, 'name' => $this->name, 'start_time' => $this->startTime ?? null, 'end_time' => $this->endTime ?? null, 'subsegments' => $this->subsegments ?? null ?: null, 'type' => $this->independent ? 'subsegment' : null, 'fault' => $this->fault ?? null, 'error' => $this->error ?? null, 'annotations' => $this->annotations ?? null ?: null, 'metadata' => $this->metadata ?? null ?: null]);\n    }\n}","originalFilePath":"\/home\/ranpafin\/php-xray\/src\/Segment.php","originalStartLine":183},"diff":"--- Original\n+++ New\n@@ @@\n     }\n     public function getCurrentSegment() : self\n     {\n-        for ($max = count($this->subsegments); $this->lastOpenSegment < $max; $this->lastOpenSegment++) {\n+        for ($max = count($this->subsegments); $this->lastOpenSegment <= $max; $this->lastOpenSegment++) {\n             if ($this->subsegments[$this->lastOpenSegment]->isOpen()) {\n                 return $this->subsegments[$this->lastOpenSegment]->getCurrentSegment();\n             }","processOutput":"PHPUnit 9.5.10 by Sebastian Bergmann and contributors.\n\nRuntime:       PHP 8.0.13\nConfiguration: \/tmp\/tmp-folder\/infection\/phpunitConfiguration.1f80ca1ccfbc2642fab92455779f0421.infection.xml\n\nE\n\nTime: 00:00.003, Memory: 8.00 MB\n\nThere was 1 error:\n\n1) Fido\\PHPXray\\SegmentTest::testGivenNoSubsegmentsCurrentSegmentReturnsSegment\nUndefined array key 0\n\n\/home\/ranpafin\/php-xray\/src\/Segment.php:144\n\/home\/ranpafin\/php-xray\/tests\/SegmentTest.php:258\n\nERRORS!\nTests: 1, Assertions: 0, Errors: 1."},{"mutator":{"mutatorName":"LessThanNegotiation","originalSourceCode":"<?php\n\nnamespace Fido\\PHPXray;\n\nuse JsonSerializable;\nuse Fido\\PHPXray\\Submission\\SegmentSubmitter;\nclass Segment implements JsonSerializable\n{\n    protected string $id;\n    protected ?string $parentId = null;\n    protected string $traceId;\n    protected ?string $name = null;\n    protected float $startTime;\n    protected float $endTime;\n    \/** @var Segment[] *\/\n    protected array $subsegments = [];\n    protected bool $error = false;\n    protected bool $fault = false;\n    protected bool $sampled = false;\n    protected bool $independent = false;\n    \/** @var array<string, mixed> *\/\n    private array $annotations;\n    \/** @var array<string, mixed> *\/\n    private array $metadata;\n    private int $lastOpenSegment = 0;\n    \/**\n     * @throws \\Exception if an appropriate source of randomness cannot be found.\n     *\/\n    public function __construct()\n    {\n        $this->id = bin2hex(random_bytes(8));\n    }\n    public function setTraceHeader(string $traceHeader = null) : self\n    {\n        if (is_null($traceHeader)) {\n            return $this;\n        }\n        $parts = explode(';', $traceHeader);\n        $variables = array_map(function ($str) : array {\n            return explode('=', $str);\n        }, $parts);\n        $variables = array_column($variables, 1, 0);\n        if (isset($variables['Root'])) {\n            $this->setTraceId($variables['Root']);\n        }\n        if (isset($variables['Sampled'])) {\n            $this->setSampled((bool) $variables['Sampled'] ?? false);\n        }\n        if (isset($variables['Parent'])) {\n            $this->setParentId($variables['Parent'] ?? null);\n        }\n        return $this;\n    }\n    public function begin() : self\n    {\n        $this->startTime = microtime(true);\n        return $this;\n    }\n    public function end() : self\n    {\n        $this->endTime = microtime(true);\n        return $this;\n    }\n    public function setName(string $name) : self\n    {\n        $this->name = $name;\n        return $this;\n    }\n    public function setError(bool $error) : self\n    {\n        $this->error = $error;\n        return $this;\n    }\n    public function setFault(bool $fault) : self\n    {\n        $this->fault = $fault;\n        return $this;\n    }\n    public function addSubsegment(Segment $subsegment) : self\n    {\n        if (!$this->isOpen()) {\n            return $this;\n        }\n        $this->subsegments[] = $subsegment;\n        $subsegment->setSampled($this->isSampled());\n        return $this;\n    }\n    public function submit(SegmentSubmitter $submitter) : void\n    {\n        if (!$this->isSampled()) {\n            return;\n        }\n        $submitter->submitSegment($this);\n    }\n    public function isSampled() : bool\n    {\n        return $this->sampled;\n    }\n    public function setSampled(bool $sampled) : self\n    {\n        $this->sampled = $sampled;\n        return $this;\n    }\n    public function getId() : string\n    {\n        return $this->id;\n    }\n    public function setParentId(?string $parentId) : self\n    {\n        $this->parentId = $parentId;\n        return $this;\n    }\n    public function setTraceId(string $traceId) : self\n    {\n        $this->traceId = $traceId;\n        return $this;\n    }\n    public function getTraceId() : string\n    {\n        return $this->traceId;\n    }\n    public function isOpen() : bool\n    {\n        return isset($this->startTime) && !isset($this->endTime);\n    }\n    public function setIndependent(bool $independent) : self\n    {\n        $this->independent = $independent;\n        return $this;\n    }\n    public function addAnnotation(string $key, string $value) : self\n    {\n        $this->annotations[$key] = $value;\n        return $this;\n    }\n    public function addMetadata(string $key, mixed $value) : self\n    {\n        $this->metadata[$key] = $value;\n        return $this;\n    }\n    public function getCurrentSegment() : self\n    {\n        for ($max = count($this->subsegments); $this->lastOpenSegment < $max; $this->lastOpenSegment++) {\n            if ($this->subsegments[$this->lastOpenSegment]->isOpen()) {\n                return $this->subsegments[$this->lastOpenSegment]->getCurrentSegment();\n            }\n        }\n        return $this;\n    }\n    \/**\n     * @inheritDoc\n     * @return array<string, mixed>\n     *\/\n    public function jsonSerialize() : array\n    {\n        return array_filter(['id' => $this->id, 'parent_id' => $this->parentId, 'trace_id' => $this->traceId ?? null, 'name' => $this->name, 'start_time' => $this->startTime ?? null, 'end_time' => $this->endTime ?? null, 'subsegments' => $this->subsegments ?? null ?: null, 'type' => $this->independent ? 'subsegment' : null, 'fault' => $this->fault ?? null, 'error' => $this->error ?? null, 'annotations' => $this->annotations ?? null ?: null, 'metadata' => $this->metadata ?? null ?: null]);\n    }\n}","mutatedSourceCode":"<?php\n\nnamespace Fido\\PHPXray;\n\nuse JsonSerializable;\nuse Fido\\PHPXray\\Submission\\SegmentSubmitter;\nclass Segment implements JsonSerializable\n{\n    protected string $id;\n    protected ?string $parentId = null;\n    protected string $traceId;\n    protected ?string $name = null;\n    protected float $startTime;\n    protected float $endTime;\n    \/** @var Segment[] *\/\n    protected array $subsegments = [];\n    protected bool $error = false;\n    protected bool $fault = false;\n    protected bool $sampled = false;\n    protected bool $independent = false;\n    \/** @var array<string, mixed> *\/\n    private array $annotations;\n    \/** @var array<string, mixed> *\/\n    private array $metadata;\n    private int $lastOpenSegment = 0;\n    \/**\n     * @throws \\Exception if an appropriate source of randomness cannot be found.\n     *\/\n    public function __construct()\n    {\n        $this->id = bin2hex(random_bytes(8));\n    }\n    public function setTraceHeader(string $traceHeader = null) : self\n    {\n        if (is_null($traceHeader)) {\n            return $this;\n        }\n        $parts = explode(';', $traceHeader);\n        $variables = array_map(function ($str) : array {\n            return explode('=', $str);\n        }, $parts);\n        $variables = array_column($variables, 1, 0);\n        if (isset($variables['Root'])) {\n            $this->setTraceId($variables['Root']);\n        }\n        if (isset($variables['Sampled'])) {\n            $this->setSampled((bool) $variables['Sampled'] ?? false);\n        }\n        if (isset($variables['Parent'])) {\n            $this->setParentId($variables['Parent'] ?? null);\n        }\n        return $this;\n    }\n    public function begin() : self\n    {\n        $this->startTime = microtime(true);\n        return $this;\n    }\n    public function end() : self\n    {\n        $this->endTime = microtime(true);\n        return $this;\n    }\n    public function setName(string $name) : self\n    {\n        $this->name = $name;\n        return $this;\n    }\n    public function setError(bool $error) : self\n    {\n        $this->error = $error;\n        return $this;\n    }\n    public function setFault(bool $fault) : self\n    {\n        $this->fault = $fault;\n        return $this;\n    }\n    public function addSubsegment(Segment $subsegment) : self\n    {\n        if (!$this->isOpen()) {\n            return $this;\n        }\n        $this->subsegments[] = $subsegment;\n        $subsegment->setSampled($this->isSampled());\n        return $this;\n    }\n    public function submit(SegmentSubmitter $submitter) : void\n    {\n        if (!$this->isSampled()) {\n            return;\n        }\n        $submitter->submitSegment($this);\n    }\n    public function isSampled() : bool\n    {\n        return $this->sampled;\n    }\n    public function setSampled(bool $sampled) : self\n    {\n        $this->sampled = $sampled;\n        return $this;\n    }\n    public function getId() : string\n    {\n        return $this->id;\n    }\n    public function setParentId(?string $parentId) : self\n    {\n        $this->parentId = $parentId;\n        return $this;\n    }\n    public function setTraceId(string $traceId) : self\n    {\n        $this->traceId = $traceId;\n        return $this;\n    }\n    public function getTraceId() : string\n    {\n        return $this->traceId;\n    }\n    public function isOpen() : bool\n    {\n        return isset($this->startTime) && !isset($this->endTime);\n    }\n    public function setIndependent(bool $independent) : self\n    {\n        $this->independent = $independent;\n        return $this;\n    }\n    public function addAnnotation(string $key, string $value) : self\n    {\n        $this->annotations[$key] = $value;\n        return $this;\n    }\n    public function addMetadata(string $key, mixed $value) : self\n    {\n        $this->metadata[$key] = $value;\n        return $this;\n    }\n    public function getCurrentSegment() : self\n    {\n        for ($max = count($this->subsegments); $this->lastOpenSegment >= $max; $this->lastOpenSegment++) {\n            if ($this->subsegments[$this->lastOpenSegment]->isOpen()) {\n                return $this->subsegments[$this->lastOpenSegment]->getCurrentSegment();\n            }\n        }\n        return $this;\n    }\n    \/**\n     * @inheritDoc\n     * @return array<string, mixed>\n     *\/\n    public function jsonSerialize() : array\n    {\n        return array_filter(['id' => $this->id, 'parent_id' => $this->parentId, 'trace_id' => $this->traceId ?? null, 'name' => $this->name, 'start_time' => $this->startTime ?? null, 'end_time' => $this->endTime ?? null, 'subsegments' => $this->subsegments ?? null ?: null, 'type' => $this->independent ? 'subsegment' : null, 'fault' => $this->fault ?? null, 'error' => $this->error ?? null, 'annotations' => $this->annotations ?? null ?: null, 'metadata' => $this->metadata ?? null ?: null]);\n    }\n}","originalFilePath":"\/home\/ranpafin\/php-xray\/src\/Segment.php","originalStartLine":183},"diff":"--- Original\n+++ New\n@@ @@\n     }\n     public function getCurrentSegment() : self\n     {\n-        for ($max = count($this->subsegments); $this->lastOpenSegment < $max; $this->lastOpenSegment++) {\n+        for ($max = count($this->subsegments); $this->lastOpenSegment >= $max; $this->lastOpenSegment++) {\n             if ($this->subsegments[$this->lastOpenSegment]->isOpen()) {\n                 return $this->subsegments[$this->lastOpenSegment]->getCurrentSegment();\n             }","processOutput":"PHPUnit 9.5.10 by Sebastian Bergmann and contributors.\n\nRuntime:       PHP 8.0.13\nConfiguration: \/tmp\/tmp-folder\/infection\/phpunitConfiguration.a8347fc9f0af0500036861f328a08065.infection.xml\n\nE\n\nTime: 00:00.005, Memory: 8.00 MB\n\nThere was 1 error:\n\n1) Fido\\PHPXray\\SegmentTest::testGivenNoSubsegmentsCurrentSegmentReturnsSegment\nUndefined array key 0\n\n\/home\/ranpafin\/php-xray\/src\/Segment.php:144\n\/home\/ranpafin\/php-xray\/tests\/SegmentTest.php:258\n\nERRORS!\nTests: 1, Assertions: 0, Errors: 1."},{"mutator":{"mutatorName":"Increment","originalSourceCode":"<?php\n\nnamespace Fido\\PHPXray;\n\nuse JsonSerializable;\nuse Fido\\PHPXray\\Submission\\SegmentSubmitter;\nclass Segment implements JsonSerializable\n{\n    protected string $id;\n    protected ?string $parentId = null;\n    protected string $traceId;\n    protected ?string $name = null;\n    protected float $startTime;\n    protected float $endTime;\n    \/** @var Segment[] *\/\n    protected array $subsegments = [];\n    protected bool $error = false;\n    protected bool $fault = false;\n    protected bool $sampled = false;\n    protected bool $independent = false;\n    \/** @var array<string, mixed> *\/\n    private array $annotations;\n    \/** @var array<string, mixed> *\/\n    private array $metadata;\n    private int $lastOpenSegment = 0;\n    \/**\n     * @throws \\Exception if an appropriate source of randomness cannot be found.\n     *\/\n    public function __construct()\n    {\n        $this->id = bin2hex(random_bytes(8));\n    }\n    public function setTraceHeader(string $traceHeader = null) : self\n    {\n        if (is_null($traceHeader)) {\n            return $this;\n        }\n        $parts = explode(';', $traceHeader);\n        $variables = array_map(function ($str) : array {\n            return explode('=', $str);\n        }, $parts);\n        $variables = array_column($variables, 1, 0);\n        if (isset($variables['Root'])) {\n            $this->setTraceId($variables['Root']);\n        }\n        if (isset($variables['Sampled'])) {\n            $this->setSampled((bool) $variables['Sampled'] ?? false);\n        }\n        if (isset($variables['Parent'])) {\n            $this->setParentId($variables['Parent'] ?? null);\n        }\n        return $this;\n    }\n    public function begin() : self\n    {\n        $this->startTime = microtime(true);\n        return $this;\n    }\n    public function end() : self\n    {\n        $this->endTime = microtime(true);\n        return $this;\n    }\n    public function setName(string $name) : self\n    {\n        $this->name = $name;\n        return $this;\n    }\n    public function setError(bool $error) : self\n    {\n        $this->error = $error;\n        return $this;\n    }\n    public function setFault(bool $fault) : self\n    {\n        $this->fault = $fault;\n        return $this;\n    }\n    public function addSubsegment(Segment $subsegment) : self\n    {\n        if (!$this->isOpen()) {\n            return $this;\n        }\n        $this->subsegments[] = $subsegment;\n        $subsegment->setSampled($this->isSampled());\n        return $this;\n    }\n    public function submit(SegmentSubmitter $submitter) : void\n    {\n        if (!$this->isSampled()) {\n            return;\n        }\n        $submitter->submitSegment($this);\n    }\n    public function isSampled() : bool\n    {\n        return $this->sampled;\n    }\n    public function setSampled(bool $sampled) : self\n    {\n        $this->sampled = $sampled;\n        return $this;\n    }\n    public function getId() : string\n    {\n        return $this->id;\n    }\n    public function setParentId(?string $parentId) : self\n    {\n        $this->parentId = $parentId;\n        return $this;\n    }\n    public function setTraceId(string $traceId) : self\n    {\n        $this->traceId = $traceId;\n        return $this;\n    }\n    public function getTraceId() : string\n    {\n        return $this->traceId;\n    }\n    public function isOpen() : bool\n    {\n        return isset($this->startTime) && !isset($this->endTime);\n    }\n    public function setIndependent(bool $independent) : self\n    {\n        $this->independent = $independent;\n        return $this;\n    }\n    public function addAnnotation(string $key, string $value) : self\n    {\n        $this->annotations[$key] = $value;\n        return $this;\n    }\n    public function addMetadata(string $key, mixed $value) : self\n    {\n        $this->metadata[$key] = $value;\n        return $this;\n    }\n    public function getCurrentSegment() : self\n    {\n        for ($max = count($this->subsegments); $this->lastOpenSegment < $max; $this->lastOpenSegment++) {\n            if ($this->subsegments[$this->lastOpenSegment]->isOpen()) {\n                return $this->subsegments[$this->lastOpenSegment]->getCurrentSegment();\n            }\n        }\n        return $this;\n    }\n    \/**\n     * @inheritDoc\n     * @return array<string, mixed>\n     *\/\n    public function jsonSerialize() : array\n    {\n        return array_filter(['id' => $this->id, 'parent_id' => $this->parentId, 'trace_id' => $this->traceId ?? null, 'name' => $this->name, 'start_time' => $this->startTime ?? null, 'end_time' => $this->endTime ?? null, 'subsegments' => $this->subsegments ?? null ?: null, 'type' => $this->independent ? 'subsegment' : null, 'fault' => $this->fault ?? null, 'error' => $this->error ?? null, 'annotations' => $this->annotations ?? null ?: null, 'metadata' => $this->metadata ?? null ?: null]);\n    }\n}","mutatedSourceCode":"<?php\n\nnamespace Fido\\PHPXray;\n\nuse JsonSerializable;\nuse Fido\\PHPXray\\Submission\\SegmentSubmitter;\nclass Segment implements JsonSerializable\n{\n    protected string $id;\n    protected ?string $parentId = null;\n    protected string $traceId;\n    protected ?string $name = null;\n    protected float $startTime;\n    protected float $endTime;\n    \/** @var Segment[] *\/\n    protected array $subsegments = [];\n    protected bool $error = false;\n    protected bool $fault = false;\n    protected bool $sampled = false;\n    protected bool $independent = false;\n    \/** @var array<string, mixed> *\/\n    private array $annotations;\n    \/** @var array<string, mixed> *\/\n    private array $metadata;\n    private int $lastOpenSegment = 0;\n    \/**\n     * @throws \\Exception if an appropriate source of randomness cannot be found.\n     *\/\n    public function __construct()\n    {\n        $this->id = bin2hex(random_bytes(8));\n    }\n    public function setTraceHeader(string $traceHeader = null) : self\n    {\n        if (is_null($traceHeader)) {\n            return $this;\n        }\n        $parts = explode(';', $traceHeader);\n        $variables = array_map(function ($str) : array {\n            return explode('=', $str);\n        }, $parts);\n        $variables = array_column($variables, 1, 0);\n        if (isset($variables['Root'])) {\n            $this->setTraceId($variables['Root']);\n        }\n        if (isset($variables['Sampled'])) {\n            $this->setSampled((bool) $variables['Sampled'] ?? false);\n        }\n        if (isset($variables['Parent'])) {\n            $this->setParentId($variables['Parent'] ?? null);\n        }\n        return $this;\n    }\n    public function begin() : self\n    {\n        $this->startTime = microtime(true);\n        return $this;\n    }\n    public function end() : self\n    {\n        $this->endTime = microtime(true);\n        return $this;\n    }\n    public function setName(string $name) : self\n    {\n        $this->name = $name;\n        return $this;\n    }\n    public function setError(bool $error) : self\n    {\n        $this->error = $error;\n        return $this;\n    }\n    public function setFault(bool $fault) : self\n    {\n        $this->fault = $fault;\n        return $this;\n    }\n    public function addSubsegment(Segment $subsegment) : self\n    {\n        if (!$this->isOpen()) {\n            return $this;\n        }\n        $this->subsegments[] = $subsegment;\n        $subsegment->setSampled($this->isSampled());\n        return $this;\n    }\n    public function submit(SegmentSubmitter $submitter) : void\n    {\n        if (!$this->isSampled()) {\n            return;\n        }\n        $submitter->submitSegment($this);\n    }\n    public function isSampled() : bool\n    {\n        return $this->sampled;\n    }\n    public function setSampled(bool $sampled) : self\n    {\n        $this->sampled = $sampled;\n        return $this;\n    }\n    public function getId() : string\n    {\n        return $this->id;\n    }\n    public function setParentId(?string $parentId) : self\n    {\n        $this->parentId = $parentId;\n        return $this;\n    }\n    public function setTraceId(string $traceId) : self\n    {\n        $this->traceId = $traceId;\n        return $this;\n    }\n    public function getTraceId() : string\n    {\n        return $this->traceId;\n    }\n    public function isOpen() : bool\n    {\n        return isset($this->startTime) && !isset($this->endTime);\n    }\n    public function setIndependent(bool $independent) : self\n    {\n        $this->independent = $independent;\n        return $this;\n    }\n    public function addAnnotation(string $key, string $value) : self\n    {\n        $this->annotations[$key] = $value;\n        return $this;\n    }\n    public function addMetadata(string $key, mixed $value) : self\n    {\n        $this->metadata[$key] = $value;\n        return $this;\n    }\n    public function getCurrentSegment() : self\n    {\n        for ($max = count($this->subsegments); $this->lastOpenSegment < $max; $this->lastOpenSegment--) {\n            if ($this->subsegments[$this->lastOpenSegment]->isOpen()) {\n                return $this->subsegments[$this->lastOpenSegment]->getCurrentSegment();\n            }\n        }\n        return $this;\n    }\n    \/**\n     * @inheritDoc\n     * @return array<string, mixed>\n     *\/\n    public function jsonSerialize() : array\n    {\n        return array_filter(['id' => $this->id, 'parent_id' => $this->parentId, 'trace_id' => $this->traceId ?? null, 'name' => $this->name, 'start_time' => $this->startTime ?? null, 'end_time' => $this->endTime ?? null, 'subsegments' => $this->subsegments ?? null ?: null, 'type' => $this->independent ? 'subsegment' : null, 'fault' => $this->fault ?? null, 'error' => $this->error ?? null, 'annotations' => $this->annotations ?? null ?: null, 'metadata' => $this->metadata ?? null ?: null]);\n    }\n}","originalFilePath":"\/home\/ranpafin\/php-xray\/src\/Segment.php","originalStartLine":183},"diff":"--- Original\n+++ New\n@@ @@\n     }\n     public function getCurrentSegment() : self\n     {\n-        for ($max = count($this->subsegments); $this->lastOpenSegment < $max; $this->lastOpenSegment++) {\n+        for ($max = count($this->subsegments); $this->lastOpenSegment < $max; $this->lastOpenSegment--) {\n             if ($this->subsegments[$this->lastOpenSegment]->isOpen()) {\n                 return $this->subsegments[$this->lastOpenSegment]->getCurrentSegment();\n             }","processOutput":"PHPUnit 9.5.10 by Sebastian Bergmann and contributors.\n\nRuntime:       PHP 8.0.13\nConfiguration: \/tmp\/tmp-folder\/infection\/phpunitConfiguration.a276c2d11f1c0679f1c90f4fcb54486f.infection.xml\n\nE\n\nTime: 00:00.003, Memory: 8.00 MB\n\nThere was 1 error:\n\n1) Fido\\PHPXray\\SegmentTest::testClosedSubsegmentCurrentSegmentReturnsSegment\nUndefined array key -1\n\n\/home\/ranpafin\/php-xray\/src\/Segment.php:144\n\/home\/ranpafin\/php-xray\/tests\/SegmentTest.php:272\n\nERRORS!\nTests: 1, Assertions: 0, Errors: 1."},{"mutator":{"mutatorName":"For_","originalSourceCode":"<?php\n\nnamespace Fido\\PHPXray;\n\nuse JsonSerializable;\nuse Fido\\PHPXray\\Submission\\SegmentSubmitter;\nclass Segment implements JsonSerializable\n{\n    protected string $id;\n    protected ?string $parentId = null;\n    protected string $traceId;\n    protected ?string $name = null;\n    protected float $startTime;\n    protected float $endTime;\n    \/** @var Segment[] *\/\n    protected array $subsegments = [];\n    protected bool $error = false;\n    protected bool $fault = false;\n    protected bool $sampled = false;\n    protected bool $independent = false;\n    \/** @var array<string, mixed> *\/\n    private array $annotations;\n    \/** @var array<string, mixed> *\/\n    private array $metadata;\n    private int $lastOpenSegment = 0;\n    \/**\n     * @throws \\Exception if an appropriate source of randomness cannot be found.\n     *\/\n    public function __construct()\n    {\n        $this->id = bin2hex(random_bytes(8));\n    }\n    public function setTraceHeader(string $traceHeader = null) : self\n    {\n        if (is_null($traceHeader)) {\n            return $this;\n        }\n        $parts = explode(';', $traceHeader);\n        $variables = array_map(function ($str) : array {\n            return explode('=', $str);\n        }, $parts);\n        $variables = array_column($variables, 1, 0);\n        if (isset($variables['Root'])) {\n            $this->setTraceId($variables['Root']);\n        }\n        if (isset($variables['Sampled'])) {\n            $this->setSampled((bool) $variables['Sampled'] ?? false);\n        }\n        if (isset($variables['Parent'])) {\n            $this->setParentId($variables['Parent'] ?? null);\n        }\n        return $this;\n    }\n    public function begin() : self\n    {\n        $this->startTime = microtime(true);\n        return $this;\n    }\n    public function end() : self\n    {\n        $this->endTime = microtime(true);\n        return $this;\n    }\n    public function setName(string $name) : self\n    {\n        $this->name = $name;\n        return $this;\n    }\n    public function setError(bool $error) : self\n    {\n        $this->error = $error;\n        return $this;\n    }\n    public function setFault(bool $fault) : self\n    {\n        $this->fault = $fault;\n        return $this;\n    }\n    public function addSubsegment(Segment $subsegment) : self\n    {\n        if (!$this->isOpen()) {\n            return $this;\n        }\n        $this->subsegments[] = $subsegment;\n        $subsegment->setSampled($this->isSampled());\n        return $this;\n    }\n    public function submit(SegmentSubmitter $submitter) : void\n    {\n        if (!$this->isSampled()) {\n            return;\n        }\n        $submitter->submitSegment($this);\n    }\n    public function isSampled() : bool\n    {\n        return $this->sampled;\n    }\n    public function setSampled(bool $sampled) : self\n    {\n        $this->sampled = $sampled;\n        return $this;\n    }\n    public function getId() : string\n    {\n        return $this->id;\n    }\n    public function setParentId(?string $parentId) : self\n    {\n        $this->parentId = $parentId;\n        return $this;\n    }\n    public function setTraceId(string $traceId) : self\n    {\n        $this->traceId = $traceId;\n        return $this;\n    }\n    public function getTraceId() : string\n    {\n        return $this->traceId;\n    }\n    public function isOpen() : bool\n    {\n        return isset($this->startTime) && !isset($this->endTime);\n    }\n    public function setIndependent(bool $independent) : self\n    {\n        $this->independent = $independent;\n        return $this;\n    }\n    public function addAnnotation(string $key, string $value) : self\n    {\n        $this->annotations[$key] = $value;\n        return $this;\n    }\n    public function addMetadata(string $key, mixed $value) : self\n    {\n        $this->metadata[$key] = $value;\n        return $this;\n    }\n    public function getCurrentSegment() : self\n    {\n        for ($max = count($this->subsegments); $this->lastOpenSegment < $max; $this->lastOpenSegment++) {\n            if ($this->subsegments[$this->lastOpenSegment]->isOpen()) {\n                return $this->subsegments[$this->lastOpenSegment]->getCurrentSegment();\n            }\n        }\n        return $this;\n    }\n    \/**\n     * @inheritDoc\n     * @return array<string, mixed>\n     *\/\n    public function jsonSerialize() : array\n    {\n        return array_filter(['id' => $this->id, 'parent_id' => $this->parentId, 'trace_id' => $this->traceId ?? null, 'name' => $this->name, 'start_time' => $this->startTime ?? null, 'end_time' => $this->endTime ?? null, 'subsegments' => $this->subsegments ?? null ?: null, 'type' => $this->independent ? 'subsegment' : null, 'fault' => $this->fault ?? null, 'error' => $this->error ?? null, 'annotations' => $this->annotations ?? null ?: null, 'metadata' => $this->metadata ?? null ?: null]);\n    }\n}","mutatedSourceCode":"<?php\n\nnamespace Fido\\PHPXray;\n\nuse JsonSerializable;\nuse Fido\\PHPXray\\Submission\\SegmentSubmitter;\nclass Segment implements JsonSerializable\n{\n    protected string $id;\n    protected ?string $parentId = null;\n    protected string $traceId;\n    protected ?string $name = null;\n    protected float $startTime;\n    protected float $endTime;\n    \/** @var Segment[] *\/\n    protected array $subsegments = [];\n    protected bool $error = false;\n    protected bool $fault = false;\n    protected bool $sampled = false;\n    protected bool $independent = false;\n    \/** @var array<string, mixed> *\/\n    private array $annotations;\n    \/** @var array<string, mixed> *\/\n    private array $metadata;\n    private int $lastOpenSegment = 0;\n    \/**\n     * @throws \\Exception if an appropriate source of randomness cannot be found.\n     *\/\n    public function __construct()\n    {\n        $this->id = bin2hex(random_bytes(8));\n    }\n    public function setTraceHeader(string $traceHeader = null) : self\n    {\n        if (is_null($traceHeader)) {\n            return $this;\n        }\n        $parts = explode(';', $traceHeader);\n        $variables = array_map(function ($str) : array {\n            return explode('=', $str);\n        }, $parts);\n        $variables = array_column($variables, 1, 0);\n        if (isset($variables['Root'])) {\n            $this->setTraceId($variables['Root']);\n        }\n        if (isset($variables['Sampled'])) {\n            $this->setSampled((bool) $variables['Sampled'] ?? false);\n        }\n        if (isset($variables['Parent'])) {\n            $this->setParentId($variables['Parent'] ?? null);\n        }\n        return $this;\n    }\n    public function begin() : self\n    {\n        $this->startTime = microtime(true);\n        return $this;\n    }\n    public function end() : self\n    {\n        $this->endTime = microtime(true);\n        return $this;\n    }\n    public function setName(string $name) : self\n    {\n        $this->name = $name;\n        return $this;\n    }\n    public function setError(bool $error) : self\n    {\n        $this->error = $error;\n        return $this;\n    }\n    public function setFault(bool $fault) : self\n    {\n        $this->fault = $fault;\n        return $this;\n    }\n    public function addSubsegment(Segment $subsegment) : self\n    {\n        if (!$this->isOpen()) {\n            return $this;\n        }\n        $this->subsegments[] = $subsegment;\n        $subsegment->setSampled($this->isSampled());\n        return $this;\n    }\n    public function submit(SegmentSubmitter $submitter) : void\n    {\n        if (!$this->isSampled()) {\n            return;\n        }\n        $submitter->submitSegment($this);\n    }\n    public function isSampled() : bool\n    {\n        return $this->sampled;\n    }\n    public function setSampled(bool $sampled) : self\n    {\n        $this->sampled = $sampled;\n        return $this;\n    }\n    public function getId() : string\n    {\n        return $this->id;\n    }\n    public function setParentId(?string $parentId) : self\n    {\n        $this->parentId = $parentId;\n        return $this;\n    }\n    public function setTraceId(string $traceId) : self\n    {\n        $this->traceId = $traceId;\n        return $this;\n    }\n    public function getTraceId() : string\n    {\n        return $this->traceId;\n    }\n    public function isOpen() : bool\n    {\n        return isset($this->startTime) && !isset($this->endTime);\n    }\n    public function setIndependent(bool $independent) : self\n    {\n        $this->independent = $independent;\n        return $this;\n    }\n    public function addAnnotation(string $key, string $value) : self\n    {\n        $this->annotations[$key] = $value;\n        return $this;\n    }\n    public function addMetadata(string $key, mixed $value) : self\n    {\n        $this->metadata[$key] = $value;\n        return $this;\n    }\n    public function getCurrentSegment() : self\n    {\n        for ($max = count($this->subsegments); false; $this->lastOpenSegment++) {\n            if ($this->subsegments[$this->lastOpenSegment]->isOpen()) {\n                return $this->subsegments[$this->lastOpenSegment]->getCurrentSegment();\n            }\n        }\n        return $this;\n    }\n    \/**\n     * @inheritDoc\n     * @return array<string, mixed>\n     *\/\n    public function jsonSerialize() : array\n    {\n        return array_filter(['id' => $this->id, 'parent_id' => $this->parentId, 'trace_id' => $this->traceId ?? null, 'name' => $this->name, 'start_time' => $this->startTime ?? null, 'end_time' => $this->endTime ?? null, 'subsegments' => $this->subsegments ?? null ?: null, 'type' => $this->independent ? 'subsegment' : null, 'fault' => $this->fault ?? null, 'error' => $this->error ?? null, 'annotations' => $this->annotations ?? null ?: null, 'metadata' => $this->metadata ?? null ?: null]);\n    }\n}","originalFilePath":"\/home\/ranpafin\/php-xray\/src\/Segment.php","originalStartLine":183},"diff":"--- Original\n+++ New\n@@ @@\n     }\n     public function getCurrentSegment() : self\n     {\n-        for ($max = count($this->subsegments); $this->lastOpenSegment < $max; $this->lastOpenSegment++) {\n+        for ($max = count($this->subsegments); false; $this->lastOpenSegment++) {\n             if ($this->subsegments[$this->lastOpenSegment]->isOpen()) {\n                 return $this->subsegments[$this->lastOpenSegment]->getCurrentSegment();\n             }","processOutput":"PHPUnit 9.5.10 by Sebastian Bergmann and contributors.\n\nRuntime:       PHP 8.0.13\nConfiguration: \/tmp\/tmp-folder\/infection\/phpunitConfiguration.b8b1da3386a3d1fdc77ab2839bc1a625.infection.xml\n\nF\n\nTime: 00:00.007, Memory: 8.00 MB\n\nThere was 1 failure:\n\n1) Fido\\PHPXray\\SegmentTest::testOpenSubsegmentCurrentSegmentReturnsSubsegment\nFailed asserting that two objects are equal.\n--- Expected\n+++ Actual\n@@ @@\n Fido\\PHPXray\\Segment Object (\n-    'id' => '29daacaf811f0ae6'\n+    'id' => 'aa01377cf79f7380'\n     'parentId' => null\n     'name' => null\n-    'startTime' => 1637924149.030758\n+    'startTime' => 1637924149.03076\n     'subsegments' => Array (\n+        0 => Fido\\PHPXray\\Segment Object (...)\n     )\n     'error' => false\n     'fault' => false\n\n\/home\/ranpafin\/php-xray\/tests\/SegmentTest.php:284\n\nFAILURES!\nTests: 1, Assertions: 1, Failures: 1."},{"mutator":{"mutatorName":"ArrayItemRemoval","originalSourceCode":"<?php\n\nnamespace Fido\\PHPXray;\n\nuse JsonSerializable;\nuse Fido\\PHPXray\\Submission\\SegmentSubmitter;\nclass Segment implements JsonSerializable\n{\n    protected string $id;\n    protected ?string $parentId = null;\n    protected string $traceId;\n    protected ?string $name = null;\n    protected float $startTime;\n    protected float $endTime;\n    \/** @var Segment[] *\/\n    protected array $subsegments = [];\n    protected bool $error = false;\n    protected bool $fault = false;\n    protected bool $sampled = false;\n    protected bool $independent = false;\n    \/** @var array<string, mixed> *\/\n    private array $annotations;\n    \/** @var array<string, mixed> *\/\n    private array $metadata;\n    private int $lastOpenSegment = 0;\n    \/**\n     * @throws \\Exception if an appropriate source of randomness cannot be found.\n     *\/\n    public function __construct()\n    {\n        $this->id = bin2hex(random_bytes(8));\n    }\n    public function setTraceHeader(string $traceHeader = null) : self\n    {\n        if (is_null($traceHeader)) {\n            return $this;\n        }\n        $parts = explode(';', $traceHeader);\n        $variables = array_map(function ($str) : array {\n            return explode('=', $str);\n        }, $parts);\n        $variables = array_column($variables, 1, 0);\n        if (isset($variables['Root'])) {\n            $this->setTraceId($variables['Root']);\n        }\n        if (isset($variables['Sampled'])) {\n            $this->setSampled((bool) $variables['Sampled'] ?? false);\n        }\n        if (isset($variables['Parent'])) {\n            $this->setParentId($variables['Parent'] ?? null);\n        }\n        return $this;\n    }\n    public function begin() : self\n    {\n        $this->startTime = microtime(true);\n        return $this;\n    }\n    public function end() : self\n    {\n        $this->endTime = microtime(true);\n        return $this;\n    }\n    public function setName(string $name) : self\n    {\n        $this->name = $name;\n        return $this;\n    }\n    public function setError(bool $error) : self\n    {\n        $this->error = $error;\n        return $this;\n    }\n    public function setFault(bool $fault) : self\n    {\n        $this->fault = $fault;\n        return $this;\n    }\n    public function addSubsegment(Segment $subsegment) : self\n    {\n        if (!$this->isOpen()) {\n            return $this;\n        }\n        $this->subsegments[] = $subsegment;\n        $subsegment->setSampled($this->isSampled());\n        return $this;\n    }\n    public function submit(SegmentSubmitter $submitter) : void\n    {\n        if (!$this->isSampled()) {\n            return;\n        }\n        $submitter->submitSegment($this);\n    }\n    public function isSampled() : bool\n    {\n        return $this->sampled;\n    }\n    public function setSampled(bool $sampled) : self\n    {\n        $this->sampled = $sampled;\n        return $this;\n    }\n    public function getId() : string\n    {\n        return $this->id;\n    }\n    public function setParentId(?string $parentId) : self\n    {\n        $this->parentId = $parentId;\n        return $this;\n    }\n    public function setTraceId(string $traceId) : self\n    {\n        $this->traceId = $traceId;\n        return $this;\n    }\n    public function getTraceId() : string\n    {\n        return $this->traceId;\n    }\n    public function isOpen() : bool\n    {\n        return isset($this->startTime) && !isset($this->endTime);\n    }\n    public function setIndependent(bool $independent) : self\n    {\n        $this->independent = $independent;\n        return $this;\n    }\n    public function addAnnotation(string $key, string $value) : self\n    {\n        $this->annotations[$key] = $value;\n        return $this;\n    }\n    public function addMetadata(string $key, mixed $value) : self\n    {\n        $this->metadata[$key] = $value;\n        return $this;\n    }\n    public function getCurrentSegment() : self\n    {\n        for ($max = count($this->subsegments); $this->lastOpenSegment < $max; $this->lastOpenSegment++) {\n            if ($this->subsegments[$this->lastOpenSegment]->isOpen()) {\n                return $this->subsegments[$this->lastOpenSegment]->getCurrentSegment();\n            }\n        }\n        return $this;\n    }\n    \/**\n     * @inheritDoc\n     * @return array<string, mixed>\n     *\/\n    public function jsonSerialize() : array\n    {\n        return array_filter(['id' => $this->id, 'parent_id' => $this->parentId, 'trace_id' => $this->traceId ?? null, 'name' => $this->name, 'start_time' => $this->startTime ?? null, 'end_time' => $this->endTime ?? null, 'subsegments' => $this->subsegments ?? null ?: null, 'type' => $this->independent ? 'subsegment' : null, 'fault' => $this->fault ?? null, 'error' => $this->error ?? null, 'annotations' => $this->annotations ?? null ?: null, 'metadata' => $this->metadata ?? null ?: null]);\n    }\n}","mutatedSourceCode":"<?php\n\nnamespace Fido\\PHPXray;\n\nuse JsonSerializable;\nuse Fido\\PHPXray\\Submission\\SegmentSubmitter;\nclass Segment implements JsonSerializable\n{\n    protected string $id;\n    protected ?string $parentId = null;\n    protected string $traceId;\n    protected ?string $name = null;\n    protected float $startTime;\n    protected float $endTime;\n    \/** @var Segment[] *\/\n    protected array $subsegments = [];\n    protected bool $error = false;\n    protected bool $fault = false;\n    protected bool $sampled = false;\n    protected bool $independent = false;\n    \/** @var array<string, mixed> *\/\n    private array $annotations;\n    \/** @var array<string, mixed> *\/\n    private array $metadata;\n    private int $lastOpenSegment = 0;\n    \/**\n     * @throws \\Exception if an appropriate source of randomness cannot be found.\n     *\/\n    public function __construct()\n    {\n        $this->id = bin2hex(random_bytes(8));\n    }\n    public function setTraceHeader(string $traceHeader = null) : self\n    {\n        if (is_null($traceHeader)) {\n            return $this;\n        }\n        $parts = explode(';', $traceHeader);\n        $variables = array_map(function ($str) : array {\n            return explode('=', $str);\n        }, $parts);\n        $variables = array_column($variables, 1, 0);\n        if (isset($variables['Root'])) {\n            $this->setTraceId($variables['Root']);\n        }\n        if (isset($variables['Sampled'])) {\n            $this->setSampled((bool) $variables['Sampled'] ?? false);\n        }\n        if (isset($variables['Parent'])) {\n            $this->setParentId($variables['Parent'] ?? null);\n        }\n        return $this;\n    }\n    public function begin() : self\n    {\n        $this->startTime = microtime(true);\n        return $this;\n    }\n    public function end() : self\n    {\n        $this->endTime = microtime(true);\n        return $this;\n    }\n    public function setName(string $name) : self\n    {\n        $this->name = $name;\n        return $this;\n    }\n    public function setError(bool $error) : self\n    {\n        $this->error = $error;\n        return $this;\n    }\n    public function setFault(bool $fault) : self\n    {\n        $this->fault = $fault;\n        return $this;\n    }\n    public function addSubsegment(Segment $subsegment) : self\n    {\n        if (!$this->isOpen()) {\n            return $this;\n        }\n        $this->subsegments[] = $subsegment;\n        $subsegment->setSampled($this->isSampled());\n        return $this;\n    }\n    public function submit(SegmentSubmitter $submitter) : void\n    {\n        if (!$this->isSampled()) {\n            return;\n        }\n        $submitter->submitSegment($this);\n    }\n    public function isSampled() : bool\n    {\n        return $this->sampled;\n    }\n    public function setSampled(bool $sampled) : self\n    {\n        $this->sampled = $sampled;\n        return $this;\n    }\n    public function getId() : string\n    {\n        return $this->id;\n    }\n    public function setParentId(?string $parentId) : self\n    {\n        $this->parentId = $parentId;\n        return $this;\n    }\n    public function setTraceId(string $traceId) : self\n    {\n        $this->traceId = $traceId;\n        return $this;\n    }\n    public function getTraceId() : string\n    {\n        return $this->traceId;\n    }\n    public function isOpen() : bool\n    {\n        return isset($this->startTime) && !isset($this->endTime);\n    }\n    public function setIndependent(bool $independent) : self\n    {\n        $this->independent = $independent;\n        return $this;\n    }\n    public function addAnnotation(string $key, string $value) : self\n    {\n        $this->annotations[$key] = $value;\n        return $this;\n    }\n    public function addMetadata(string $key, mixed $value) : self\n    {\n        $this->metadata[$key] = $value;\n        return $this;\n    }\n    public function getCurrentSegment() : self\n    {\n        for ($max = count($this->subsegments); $this->lastOpenSegment < $max; $this->lastOpenSegment++) {\n            if ($this->subsegments[$this->lastOpenSegment]->isOpen()) {\n                return $this->subsegments[$this->lastOpenSegment]->getCurrentSegment();\n            }\n        }\n        return $this;\n    }\n    \/**\n     * @inheritDoc\n     * @return array<string, mixed>\n     *\/\n    public function jsonSerialize() : array\n    {\n        return array_filter(['parent_id' => $this->parentId, 'trace_id' => $this->traceId ?? null, 'name' => $this->name, 'start_time' => $this->startTime ?? null, 'end_time' => $this->endTime ?? null, 'subsegments' => $this->subsegments ?? null ?: null, 'type' => $this->independent ? 'subsegment' : null, 'fault' => $this->fault ?? null, 'error' => $this->error ?? null, 'annotations' => $this->annotations ?? null ?: null, 'metadata' => $this->metadata ?? null ?: null]);\n    }\n}","originalFilePath":"\/home\/ranpafin\/php-xray\/src\/Segment.php","originalStartLine":198},"diff":"--- Original\n+++ New\n@@ @@\n      *\/\n     public function jsonSerialize() : array\n     {\n-        return array_filter(['id' => $this->id, 'parent_id' => $this->parentId, 'trace_id' => $this->traceId ?? null, 'name' => $this->name, 'start_time' => $this->startTime ?? null, 'end_time' => $this->endTime ?? null, 'subsegments' => $this->subsegments ?? null ?: null, 'type' => $this->independent ? 'subsegment' : null, 'fault' => $this->fault ?? null, 'error' => $this->error ?? null, 'annotations' => $this->annotations ?? null ?: null, 'metadata' => $this->metadata ?? null ?: null]);\n+        return array_filter(['parent_id' => $this->parentId, 'trace_id' => $this->traceId ?? null, 'name' => $this->name, 'start_time' => $this->startTime ?? null, 'end_time' => $this->endTime ?? null, 'subsegments' => $this->subsegments ?? null ?: null, 'type' => $this->independent ? 'subsegment' : null, 'fault' => $this->fault ?? null, 'error' => $this->error ?? null, 'annotations' => $this->annotations ?? null ?: null, 'metadata' => $this->metadata ?? null ?: null]);\n     }\n }","processOutput":"PHPUnit 9.5.10 by Sebastian Bergmann and contributors.\n\nRuntime:       PHP 8.0.13\nConfiguration: \/tmp\/tmp-folder\/infection\/phpunitConfiguration.f5043f27fa45a47748dc39cb8ee9ec48.infection.xml\n\nE\n\nTime: 00:00.003, Memory: 8.00 MB\n\nThere was 1 error:\n\n1) Fido\\PHPXray\\DaemonSegmentSubmitterTest::testSubmitsToDaemon\nsocket_bind(): Unable to bind address [98]: Address already in use\n\n\/home\/ranpafin\/php-xray\/tests\/DaemonSegmentSubmitterTest.php:18\n\nERRORS!\nTests: 1, Assertions: 0, Errors: 1."},{"mutator":{"mutatorName":"UnwrapArrayFilter","originalSourceCode":"<?php\n\nnamespace Fido\\PHPXray;\n\nuse JsonSerializable;\nuse Fido\\PHPXray\\Submission\\SegmentSubmitter;\nclass Segment implements JsonSerializable\n{\n    protected string $id;\n    protected ?string $parentId = null;\n    protected string $traceId;\n    protected ?string $name = null;\n    protected float $startTime;\n    protected float $endTime;\n    \/** @var Segment[] *\/\n    protected array $subsegments = [];\n    protected bool $error = false;\n    protected bool $fault = false;\n    protected bool $sampled = false;\n    protected bool $independent = false;\n    \/** @var array<string, mixed> *\/\n    private array $annotations;\n    \/** @var array<string, mixed> *\/\n    private array $metadata;\n    private int $lastOpenSegment = 0;\n    \/**\n     * @throws \\Exception if an appropriate source of randomness cannot be found.\n     *\/\n    public function __construct()\n    {\n        $this->id = bin2hex(random_bytes(8));\n    }\n    public function setTraceHeader(string $traceHeader = null) : self\n    {\n        if (is_null($traceHeader)) {\n            return $this;\n        }\n        $parts = explode(';', $traceHeader);\n        $variables = array_map(function ($str) : array {\n            return explode('=', $str);\n        }, $parts);\n        $variables = array_column($variables, 1, 0);\n        if (isset($variables['Root'])) {\n            $this->setTraceId($variables['Root']);\n        }\n        if (isset($variables['Sampled'])) {\n            $this->setSampled((bool) $variables['Sampled'] ?? false);\n        }\n        if (isset($variables['Parent'])) {\n            $this->setParentId($variables['Parent'] ?? null);\n        }\n        return $this;\n    }\n    public function begin() : self\n    {\n        $this->startTime = microtime(true);\n        return $this;\n    }\n    public function end() : self\n    {\n        $this->endTime = microtime(true);\n        return $this;\n    }\n    public function setName(string $name) : self\n    {\n        $this->name = $name;\n        return $this;\n    }\n    public function setError(bool $error) : self\n    {\n        $this->error = $error;\n        return $this;\n    }\n    public function setFault(bool $fault) : self\n    {\n        $this->fault = $fault;\n        return $this;\n    }\n    public function addSubsegment(Segment $subsegment) : self\n    {\n        if (!$this->isOpen()) {\n            return $this;\n        }\n        $this->subsegments[] = $subsegment;\n        $subsegment->setSampled($this->isSampled());\n        return $this;\n    }\n    public function submit(SegmentSubmitter $submitter) : void\n    {\n        if (!$this->isSampled()) {\n            return;\n        }\n        $submitter->submitSegment($this);\n    }\n    public function isSampled() : bool\n    {\n        return $this->sampled;\n    }\n    public function setSampled(bool $sampled) : self\n    {\n        $this->sampled = $sampled;\n        return $this;\n    }\n    public function getId() : string\n    {\n        return $this->id;\n    }\n    public function setParentId(?string $parentId) : self\n    {\n        $this->parentId = $parentId;\n        return $this;\n    }\n    public function setTraceId(string $traceId) : self\n    {\n        $this->traceId = $traceId;\n        return $this;\n    }\n    public function getTraceId() : string\n    {\n        return $this->traceId;\n    }\n    public function isOpen() : bool\n    {\n        return isset($this->startTime) && !isset($this->endTime);\n    }\n    public function setIndependent(bool $independent) : self\n    {\n        $this->independent = $independent;\n        return $this;\n    }\n    public function addAnnotation(string $key, string $value) : self\n    {\n        $this->annotations[$key] = $value;\n        return $this;\n    }\n    public function addMetadata(string $key, mixed $value) : self\n    {\n        $this->metadata[$key] = $value;\n        return $this;\n    }\n    public function getCurrentSegment() : self\n    {\n        for ($max = count($this->subsegments); $this->lastOpenSegment < $max; $this->lastOpenSegment++) {\n            if ($this->subsegments[$this->lastOpenSegment]->isOpen()) {\n                return $this->subsegments[$this->lastOpenSegment]->getCurrentSegment();\n            }\n        }\n        return $this;\n    }\n    \/**\n     * @inheritDoc\n     * @return array<string, mixed>\n     *\/\n    public function jsonSerialize() : array\n    {\n        return array_filter(['id' => $this->id, 'parent_id' => $this->parentId, 'trace_id' => $this->traceId ?? null, 'name' => $this->name, 'start_time' => $this->startTime ?? null, 'end_time' => $this->endTime ?? null, 'subsegments' => $this->subsegments ?? null ?: null, 'type' => $this->independent ? 'subsegment' : null, 'fault' => $this->fault ?? null, 'error' => $this->error ?? null, 'annotations' => $this->annotations ?? null ?: null, 'metadata' => $this->metadata ?? null ?: null]);\n    }\n}","mutatedSourceCode":"<?php\n\nnamespace Fido\\PHPXray;\n\nuse JsonSerializable;\nuse Fido\\PHPXray\\Submission\\SegmentSubmitter;\nclass Segment implements JsonSerializable\n{\n    protected string $id;\n    protected ?string $parentId = null;\n    protected string $traceId;\n    protected ?string $name = null;\n    protected float $startTime;\n    protected float $endTime;\n    \/** @var Segment[] *\/\n    protected array $subsegments = [];\n    protected bool $error = false;\n    protected bool $fault = false;\n    protected bool $sampled = false;\n    protected bool $independent = false;\n    \/** @var array<string, mixed> *\/\n    private array $annotations;\n    \/** @var array<string, mixed> *\/\n    private array $metadata;\n    private int $lastOpenSegment = 0;\n    \/**\n     * @throws \\Exception if an appropriate source of randomness cannot be found.\n     *\/\n    public function __construct()\n    {\n        $this->id = bin2hex(random_bytes(8));\n    }\n    public function setTraceHeader(string $traceHeader = null) : self\n    {\n        if (is_null($traceHeader)) {\n            return $this;\n        }\n        $parts = explode(';', $traceHeader);\n        $variables = array_map(function ($str) : array {\n            return explode('=', $str);\n        }, $parts);\n        $variables = array_column($variables, 1, 0);\n        if (isset($variables['Root'])) {\n            $this->setTraceId($variables['Root']);\n        }\n        if (isset($variables['Sampled'])) {\n            $this->setSampled((bool) $variables['Sampled'] ?? false);\n        }\n        if (isset($variables['Parent'])) {\n            $this->setParentId($variables['Parent'] ?? null);\n        }\n        return $this;\n    }\n    public function begin() : self\n    {\n        $this->startTime = microtime(true);\n        return $this;\n    }\n    public function end() : self\n    {\n        $this->endTime = microtime(true);\n        return $this;\n    }\n    public function setName(string $name) : self\n    {\n        $this->name = $name;\n        return $this;\n    }\n    public function setError(bool $error) : self\n    {\n        $this->error = $error;\n        return $this;\n    }\n    public function setFault(bool $fault) : self\n    {\n        $this->fault = $fault;\n        return $this;\n    }\n    public function addSubsegment(Segment $subsegment) : self\n    {\n        if (!$this->isOpen()) {\n            return $this;\n        }\n        $this->subsegments[] = $subsegment;\n        $subsegment->setSampled($this->isSampled());\n        return $this;\n    }\n    public function submit(SegmentSubmitter $submitter) : void\n    {\n        if (!$this->isSampled()) {\n            return;\n        }\n        $submitter->submitSegment($this);\n    }\n    public function isSampled() : bool\n    {\n        return $this->sampled;\n    }\n    public function setSampled(bool $sampled) : self\n    {\n        $this->sampled = $sampled;\n        return $this;\n    }\n    public function getId() : string\n    {\n        return $this->id;\n    }\n    public function setParentId(?string $parentId) : self\n    {\n        $this->parentId = $parentId;\n        return $this;\n    }\n    public function setTraceId(string $traceId) : self\n    {\n        $this->traceId = $traceId;\n        return $this;\n    }\n    public function getTraceId() : string\n    {\n        return $this->traceId;\n    }\n    public function isOpen() : bool\n    {\n        return isset($this->startTime) && !isset($this->endTime);\n    }\n    public function setIndependent(bool $independent) : self\n    {\n        $this->independent = $independent;\n        return $this;\n    }\n    public function addAnnotation(string $key, string $value) : self\n    {\n        $this->annotations[$key] = $value;\n        return $this;\n    }\n    public function addMetadata(string $key, mixed $value) : self\n    {\n        $this->metadata[$key] = $value;\n        return $this;\n    }\n    public function getCurrentSegment() : self\n    {\n        for ($max = count($this->subsegments); $this->lastOpenSegment < $max; $this->lastOpenSegment++) {\n            if ($this->subsegments[$this->lastOpenSegment]->isOpen()) {\n                return $this->subsegments[$this->lastOpenSegment]->getCurrentSegment();\n            }\n        }\n        return $this;\n    }\n    \/**\n     * @inheritDoc\n     * @return array<string, mixed>\n     *\/\n    public function jsonSerialize() : array\n    {\n        return ['id' => $this->id, 'parent_id' => $this->parentId, 'trace_id' => $this->traceId ?? null, 'name' => $this->name, 'start_time' => $this->startTime ?? null, 'end_time' => $this->endTime ?? null, 'subsegments' => $this->subsegments ?? null ?: null, 'type' => $this->independent ? 'subsegment' : null, 'fault' => $this->fault ?? null, 'error' => $this->error ?? null, 'annotations' => $this->annotations ?? null ?: null, 'metadata' => $this->metadata ?? null ?: null];\n    }\n}","originalFilePath":"\/home\/ranpafin\/php-xray\/src\/Segment.php","originalStartLine":198},"diff":"--- Original\n+++ New\n@@ @@\n      *\/\n     public function jsonSerialize() : array\n     {\n-        return array_filter(['id' => $this->id, 'parent_id' => $this->parentId, 'trace_id' => $this->traceId ?? null, 'name' => $this->name, 'start_time' => $this->startTime ?? null, 'end_time' => $this->endTime ?? null, 'subsegments' => $this->subsegments ?? null ?: null, 'type' => $this->independent ? 'subsegment' : null, 'fault' => $this->fault ?? null, 'error' => $this->error ?? null, 'annotations' => $this->annotations ?? null ?: null, 'metadata' => $this->metadata ?? null ?: null]);\n+        return ['id' => $this->id, 'parent_id' => $this->parentId, 'trace_id' => $this->traceId ?? null, 'name' => $this->name, 'start_time' => $this->startTime ?? null, 'end_time' => $this->endTime ?? null, 'subsegments' => $this->subsegments ?? null ?: null, 'type' => $this->independent ? 'subsegment' : null, 'fault' => $this->fault ?? null, 'error' => $this->error ?? null, 'annotations' => $this->annotations ?? null ?: null, 'metadata' => $this->metadata ?? null ?: null];\n     }\n }","processOutput":"PHPUnit 9.5.10 by Sebastian Bergmann and contributors.\n\nRuntime:       PHP 8.0.13\nConfiguration: \/tmp\/tmp-folder\/infection\/phpunitConfiguration.eb82b9eb43e68182bd5ad96c93cda2d6.infection.xml\n\nE\n\nTime: 00:00.003, Memory: 8.00 MB\n\nThere was 1 error:\n\n1) Fido\\PHPXray\\DaemonSegmentSubmitterTest::testSubmitsToDaemon\nsocket_bind(): Unable to bind address [98]: Address already in use\n\n\/home\/ranpafin\/php-xray\/tests\/DaemonSegmentSubmitterTest.php:18\n\nERRORS!\nTests: 1, Assertions: 0, Errors: 1."},{"mutator":{"mutatorName":"ArrayItem","originalSourceCode":"<?php\n\nnamespace Fido\\PHPXray;\n\nuse JsonSerializable;\nuse Fido\\PHPXray\\Submission\\SegmentSubmitter;\nclass Segment implements JsonSerializable\n{\n    protected string $id;\n    protected ?string $parentId = null;\n    protected string $traceId;\n    protected ?string $name = null;\n    protected float $startTime;\n    protected float $endTime;\n    \/** @var Segment[] *\/\n    protected array $subsegments = [];\n    protected bool $error = false;\n    protected bool $fault = false;\n    protected bool $sampled = false;\n    protected bool $independent = false;\n    \/** @var array<string, mixed> *\/\n    private array $annotations;\n    \/** @var array<string, mixed> *\/\n    private array $metadata;\n    private int $lastOpenSegment = 0;\n    \/**\n     * @throws \\Exception if an appropriate source of randomness cannot be found.\n     *\/\n    public function __construct()\n    {\n        $this->id = bin2hex(random_bytes(8));\n    }\n    public function setTraceHeader(string $traceHeader = null) : self\n    {\n        if (is_null($traceHeader)) {\n            return $this;\n        }\n        $parts = explode(';', $traceHeader);\n        $variables = array_map(function ($str) : array {\n            return explode('=', $str);\n        }, $parts);\n        $variables = array_column($variables, 1, 0);\n        if (isset($variables['Root'])) {\n            $this->setTraceId($variables['Root']);\n        }\n        if (isset($variables['Sampled'])) {\n            $this->setSampled((bool) $variables['Sampled'] ?? false);\n        }\n        if (isset($variables['Parent'])) {\n            $this->setParentId($variables['Parent'] ?? null);\n        }\n        return $this;\n    }\n    public function begin() : self\n    {\n        $this->startTime = microtime(true);\n        return $this;\n    }\n    public function end() : self\n    {\n        $this->endTime = microtime(true);\n        return $this;\n    }\n    public function setName(string $name) : self\n    {\n        $this->name = $name;\n        return $this;\n    }\n    public function setError(bool $error) : self\n    {\n        $this->error = $error;\n        return $this;\n    }\n    public function setFault(bool $fault) : self\n    {\n        $this->fault = $fault;\n        return $this;\n    }\n    public function addSubsegment(Segment $subsegment) : self\n    {\n        if (!$this->isOpen()) {\n            return $this;\n        }\n        $this->subsegments[] = $subsegment;\n        $subsegment->setSampled($this->isSampled());\n        return $this;\n    }\n    public function submit(SegmentSubmitter $submitter) : void\n    {\n        if (!$this->isSampled()) {\n            return;\n        }\n        $submitter->submitSegment($this);\n    }\n    public function isSampled() : bool\n    {\n        return $this->sampled;\n    }\n    public function setSampled(bool $sampled) : self\n    {\n        $this->sampled = $sampled;\n        return $this;\n    }\n    public function getId() : string\n    {\n        return $this->id;\n    }\n    public function setParentId(?string $parentId) : self\n    {\n        $this->parentId = $parentId;\n        return $this;\n    }\n    public function setTraceId(string $traceId) : self\n    {\n        $this->traceId = $traceId;\n        return $this;\n    }\n    public function getTraceId() : string\n    {\n        return $this->traceId;\n    }\n    public function isOpen() : bool\n    {\n        return isset($this->startTime) && !isset($this->endTime);\n    }\n    public function setIndependent(bool $independent) : self\n    {\n        $this->independent = $independent;\n        return $this;\n    }\n    public function addAnnotation(string $key, string $value) : self\n    {\n        $this->annotations[$key] = $value;\n        return $this;\n    }\n    public function addMetadata(string $key, mixed $value) : self\n    {\n        $this->metadata[$key] = $value;\n        return $this;\n    }\n    public function getCurrentSegment() : self\n    {\n        for ($max = count($this->subsegments); $this->lastOpenSegment < $max; $this->lastOpenSegment++) {\n            if ($this->subsegments[$this->lastOpenSegment]->isOpen()) {\n                return $this->subsegments[$this->lastOpenSegment]->getCurrentSegment();\n            }\n        }\n        return $this;\n    }\n    \/**\n     * @inheritDoc\n     * @return array<string, mixed>\n     *\/\n    public function jsonSerialize() : array\n    {\n        return array_filter(['id' => $this->id, 'parent_id' => $this->parentId, 'trace_id' => $this->traceId ?? null, 'name' => $this->name, 'start_time' => $this->startTime ?? null, 'end_time' => $this->endTime ?? null, 'subsegments' => $this->subsegments ?? null ?: null, 'type' => $this->independent ? 'subsegment' : null, 'fault' => $this->fault ?? null, 'error' => $this->error ?? null, 'annotations' => $this->annotations ?? null ?: null, 'metadata' => $this->metadata ?? null ?: null]);\n    }\n}","mutatedSourceCode":"<?php\n\nnamespace Fido\\PHPXray;\n\nuse JsonSerializable;\nuse Fido\\PHPXray\\Submission\\SegmentSubmitter;\nclass Segment implements JsonSerializable\n{\n    protected string $id;\n    protected ?string $parentId = null;\n    protected string $traceId;\n    protected ?string $name = null;\n    protected float $startTime;\n    protected float $endTime;\n    \/** @var Segment[] *\/\n    protected array $subsegments = [];\n    protected bool $error = false;\n    protected bool $fault = false;\n    protected bool $sampled = false;\n    protected bool $independent = false;\n    \/** @var array<string, mixed> *\/\n    private array $annotations;\n    \/** @var array<string, mixed> *\/\n    private array $metadata;\n    private int $lastOpenSegment = 0;\n    \/**\n     * @throws \\Exception if an appropriate source of randomness cannot be found.\n     *\/\n    public function __construct()\n    {\n        $this->id = bin2hex(random_bytes(8));\n    }\n    public function setTraceHeader(string $traceHeader = null) : self\n    {\n        if (is_null($traceHeader)) {\n            return $this;\n        }\n        $parts = explode(';', $traceHeader);\n        $variables = array_map(function ($str) : array {\n            return explode('=', $str);\n        }, $parts);\n        $variables = array_column($variables, 1, 0);\n        if (isset($variables['Root'])) {\n            $this->setTraceId($variables['Root']);\n        }\n        if (isset($variables['Sampled'])) {\n            $this->setSampled((bool) $variables['Sampled'] ?? false);\n        }\n        if (isset($variables['Parent'])) {\n            $this->setParentId($variables['Parent'] ?? null);\n        }\n        return $this;\n    }\n    public function begin() : self\n    {\n        $this->startTime = microtime(true);\n        return $this;\n    }\n    public function end() : self\n    {\n        $this->endTime = microtime(true);\n        return $this;\n    }\n    public function setName(string $name) : self\n    {\n        $this->name = $name;\n        return $this;\n    }\n    public function setError(bool $error) : self\n    {\n        $this->error = $error;\n        return $this;\n    }\n    public function setFault(bool $fault) : self\n    {\n        $this->fault = $fault;\n        return $this;\n    }\n    public function addSubsegment(Segment $subsegment) : self\n    {\n        if (!$this->isOpen()) {\n            return $this;\n        }\n        $this->subsegments[] = $subsegment;\n        $subsegment->setSampled($this->isSampled());\n        return $this;\n    }\n    public function submit(SegmentSubmitter $submitter) : void\n    {\n        if (!$this->isSampled()) {\n            return;\n        }\n        $submitter->submitSegment($this);\n    }\n    public function isSampled() : bool\n    {\n        return $this->sampled;\n    }\n    public function setSampled(bool $sampled) : self\n    {\n        $this->sampled = $sampled;\n        return $this;\n    }\n    public function getId() : string\n    {\n        return $this->id;\n    }\n    public function setParentId(?string $parentId) : self\n    {\n        $this->parentId = $parentId;\n        return $this;\n    }\n    public function setTraceId(string $traceId) : self\n    {\n        $this->traceId = $traceId;\n        return $this;\n    }\n    public function getTraceId() : string\n    {\n        return $this->traceId;\n    }\n    public function isOpen() : bool\n    {\n        return isset($this->startTime) && !isset($this->endTime);\n    }\n    public function setIndependent(bool $independent) : self\n    {\n        $this->independent = $independent;\n        return $this;\n    }\n    public function addAnnotation(string $key, string $value) : self\n    {\n        $this->annotations[$key] = $value;\n        return $this;\n    }\n    public function addMetadata(string $key, mixed $value) : self\n    {\n        $this->metadata[$key] = $value;\n        return $this;\n    }\n    public function getCurrentSegment() : self\n    {\n        for ($max = count($this->subsegments); $this->lastOpenSegment < $max; $this->lastOpenSegment++) {\n            if ($this->subsegments[$this->lastOpenSegment]->isOpen()) {\n                return $this->subsegments[$this->lastOpenSegment]->getCurrentSegment();\n            }\n        }\n        return $this;\n    }\n    \/**\n     * @inheritDoc\n     * @return array<string, mixed>\n     *\/\n    public function jsonSerialize() : array\n    {\n        return array_filter(['id' > $this->id, 'parent_id' => $this->parentId, 'trace_id' => $this->traceId ?? null, 'name' => $this->name, 'start_time' => $this->startTime ?? null, 'end_time' => $this->endTime ?? null, 'subsegments' => $this->subsegments ?? null ?: null, 'type' => $this->independent ? 'subsegment' : null, 'fault' => $this->fault ?? null, 'error' => $this->error ?? null, 'annotations' => $this->annotations ?? null ?: null, 'metadata' => $this->metadata ?? null ?: null]);\n    }\n}","originalFilePath":"\/home\/ranpafin\/php-xray\/src\/Segment.php","originalStartLine":199},"diff":"--- Original\n+++ New\n@@ @@\n      *\/\n     public function jsonSerialize() : array\n     {\n-        return array_filter(['id' => $this->id, 'parent_id' => $this->parentId, 'trace_id' => $this->traceId ?? null, 'name' => $this->name, 'start_time' => $this->startTime ?? null, 'end_time' => $this->endTime ?? null, 'subsegments' => $this->subsegments ?? null ?: null, 'type' => $this->independent ? 'subsegment' : null, 'fault' => $this->fault ?? null, 'error' => $this->error ?? null, 'annotations' => $this->annotations ?? null ?: null, 'metadata' => $this->metadata ?? null ?: null]);\n+        return array_filter(['id' > $this->id, 'parent_id' => $this->parentId, 'trace_id' => $this->traceId ?? null, 'name' => $this->name, 'start_time' => $this->startTime ?? null, 'end_time' => $this->endTime ?? null, 'subsegments' => $this->subsegments ?? null ?: null, 'type' => $this->independent ? 'subsegment' : null, 'fault' => $this->fault ?? null, 'error' => $this->error ?? null, 'annotations' => $this->annotations ?? null ?: null, 'metadata' => $this->metadata ?? null ?: null]);\n     }\n }","processOutput":"PHPUnit 9.5.10 by Sebastian Bergmann and contributors.\n\nRuntime:       PHP 8.0.13\nConfiguration: \/tmp\/tmp-folder\/infection\/phpunitConfiguration.e4c7858c9050453d503802abba228698.infection.xml\n\nE\n\nTime: 00:00.004, Memory: 8.00 MB\n\nThere was 1 error:\n\n1) Fido\\PHPXray\\DaemonSegmentSubmitterTest::testSubmitsToDaemon\nsocket_bind(): Unable to bind address [98]: Address already in use\n\n\/home\/ranpafin\/php-xray\/tests\/DaemonSegmentSubmitterTest.php:18\n\nERRORS!\nTests: 1, Assertions: 0, Errors: 1."},{"mutator":{"mutatorName":"ArrayItem","originalSourceCode":"<?php\n\nnamespace Fido\\PHPXray;\n\nuse JsonSerializable;\nuse Fido\\PHPXray\\Submission\\SegmentSubmitter;\nclass Segment implements JsonSerializable\n{\n    protected string $id;\n    protected ?string $parentId = null;\n    protected string $traceId;\n    protected ?string $name = null;\n    protected float $startTime;\n    protected float $endTime;\n    \/** @var Segment[] *\/\n    protected array $subsegments = [];\n    protected bool $error = false;\n    protected bool $fault = false;\n    protected bool $sampled = false;\n    protected bool $independent = false;\n    \/** @var array<string, mixed> *\/\n    private array $annotations;\n    \/** @var array<string, mixed> *\/\n    private array $metadata;\n    private int $lastOpenSegment = 0;\n    \/**\n     * @throws \\Exception if an appropriate source of randomness cannot be found.\n     *\/\n    public function __construct()\n    {\n        $this->id = bin2hex(random_bytes(8));\n    }\n    public function setTraceHeader(string $traceHeader = null) : self\n    {\n        if (is_null($traceHeader)) {\n            return $this;\n        }\n        $parts = explode(';', $traceHeader);\n        $variables = array_map(function ($str) : array {\n            return explode('=', $str);\n        }, $parts);\n        $variables = array_column($variables, 1, 0);\n        if (isset($variables['Root'])) {\n            $this->setTraceId($variables['Root']);\n        }\n        if (isset($variables['Sampled'])) {\n            $this->setSampled((bool) $variables['Sampled'] ?? false);\n        }\n        if (isset($variables['Parent'])) {\n            $this->setParentId($variables['Parent'] ?? null);\n        }\n        return $this;\n    }\n    public function begin() : self\n    {\n        $this->startTime = microtime(true);\n        return $this;\n    }\n    public function end() : self\n    {\n        $this->endTime = microtime(true);\n        return $this;\n    }\n    public function setName(string $name) : self\n    {\n        $this->name = $name;\n        return $this;\n    }\n    public function setError(bool $error) : self\n    {\n        $this->error = $error;\n        return $this;\n    }\n    public function setFault(bool $fault) : self\n    {\n        $this->fault = $fault;\n        return $this;\n    }\n    public function addSubsegment(Segment $subsegment) : self\n    {\n        if (!$this->isOpen()) {\n            return $this;\n        }\n        $this->subsegments[] = $subsegment;\n        $subsegment->setSampled($this->isSampled());\n        return $this;\n    }\n    public function submit(SegmentSubmitter $submitter) : void\n    {\n        if (!$this->isSampled()) {\n            return;\n        }\n        $submitter->submitSegment($this);\n    }\n    public function isSampled() : bool\n    {\n        return $this->sampled;\n    }\n    public function setSampled(bool $sampled) : self\n    {\n        $this->sampled = $sampled;\n        return $this;\n    }\n    public function getId() : string\n    {\n        return $this->id;\n    }\n    public function setParentId(?string $parentId) : self\n    {\n        $this->parentId = $parentId;\n        return $this;\n    }\n    public function setTraceId(string $traceId) : self\n    {\n        $this->traceId = $traceId;\n        return $this;\n    }\n    public function getTraceId() : string\n    {\n        return $this->traceId;\n    }\n    public function isOpen() : bool\n    {\n        return isset($this->startTime) && !isset($this->endTime);\n    }\n    public function setIndependent(bool $independent) : self\n    {\n        $this->independent = $independent;\n        return $this;\n    }\n    public function addAnnotation(string $key, string $value) : self\n    {\n        $this->annotations[$key] = $value;\n        return $this;\n    }\n    public function addMetadata(string $key, mixed $value) : self\n    {\n        $this->metadata[$key] = $value;\n        return $this;\n    }\n    public function getCurrentSegment() : self\n    {\n        for ($max = count($this->subsegments); $this->lastOpenSegment < $max; $this->lastOpenSegment++) {\n            if ($this->subsegments[$this->lastOpenSegment]->isOpen()) {\n                return $this->subsegments[$this->lastOpenSegment]->getCurrentSegment();\n            }\n        }\n        return $this;\n    }\n    \/**\n     * @inheritDoc\n     * @return array<string, mixed>\n     *\/\n    public function jsonSerialize() : array\n    {\n        return array_filter(['id' => $this->id, 'parent_id' => $this->parentId, 'trace_id' => $this->traceId ?? null, 'name' => $this->name, 'start_time' => $this->startTime ?? null, 'end_time' => $this->endTime ?? null, 'subsegments' => $this->subsegments ?? null ?: null, 'type' => $this->independent ? 'subsegment' : null, 'fault' => $this->fault ?? null, 'error' => $this->error ?? null, 'annotations' => $this->annotations ?? null ?: null, 'metadata' => $this->metadata ?? null ?: null]);\n    }\n}","mutatedSourceCode":"<?php\n\nnamespace Fido\\PHPXray;\n\nuse JsonSerializable;\nuse Fido\\PHPXray\\Submission\\SegmentSubmitter;\nclass Segment implements JsonSerializable\n{\n    protected string $id;\n    protected ?string $parentId = null;\n    protected string $traceId;\n    protected ?string $name = null;\n    protected float $startTime;\n    protected float $endTime;\n    \/** @var Segment[] *\/\n    protected array $subsegments = [];\n    protected bool $error = false;\n    protected bool $fault = false;\n    protected bool $sampled = false;\n    protected bool $independent = false;\n    \/** @var array<string, mixed> *\/\n    private array $annotations;\n    \/** @var array<string, mixed> *\/\n    private array $metadata;\n    private int $lastOpenSegment = 0;\n    \/**\n     * @throws \\Exception if an appropriate source of randomness cannot be found.\n     *\/\n    public function __construct()\n    {\n        $this->id = bin2hex(random_bytes(8));\n    }\n    public function setTraceHeader(string $traceHeader = null) : self\n    {\n        if (is_null($traceHeader)) {\n            return $this;\n        }\n        $parts = explode(';', $traceHeader);\n        $variables = array_map(function ($str) : array {\n            return explode('=', $str);\n        }, $parts);\n        $variables = array_column($variables, 1, 0);\n        if (isset($variables['Root'])) {\n            $this->setTraceId($variables['Root']);\n        }\n        if (isset($variables['Sampled'])) {\n            $this->setSampled((bool) $variables['Sampled'] ?? false);\n        }\n        if (isset($variables['Parent'])) {\n            $this->setParentId($variables['Parent'] ?? null);\n        }\n        return $this;\n    }\n    public function begin() : self\n    {\n        $this->startTime = microtime(true);\n        return $this;\n    }\n    public function end() : self\n    {\n        $this->endTime = microtime(true);\n        return $this;\n    }\n    public function setName(string $name) : self\n    {\n        $this->name = $name;\n        return $this;\n    }\n    public function setError(bool $error) : self\n    {\n        $this->error = $error;\n        return $this;\n    }\n    public function setFault(bool $fault) : self\n    {\n        $this->fault = $fault;\n        return $this;\n    }\n    public function addSubsegment(Segment $subsegment) : self\n    {\n        if (!$this->isOpen()) {\n            return $this;\n        }\n        $this->subsegments[] = $subsegment;\n        $subsegment->setSampled($this->isSampled());\n        return $this;\n    }\n    public function submit(SegmentSubmitter $submitter) : void\n    {\n        if (!$this->isSampled()) {\n            return;\n        }\n        $submitter->submitSegment($this);\n    }\n    public function isSampled() : bool\n    {\n        return $this->sampled;\n    }\n    public function setSampled(bool $sampled) : self\n    {\n        $this->sampled = $sampled;\n        return $this;\n    }\n    public function getId() : string\n    {\n        return $this->id;\n    }\n    public function setParentId(?string $parentId) : self\n    {\n        $this->parentId = $parentId;\n        return $this;\n    }\n    public function setTraceId(string $traceId) : self\n    {\n        $this->traceId = $traceId;\n        return $this;\n    }\n    public function getTraceId() : string\n    {\n        return $this->traceId;\n    }\n    public function isOpen() : bool\n    {\n        return isset($this->startTime) && !isset($this->endTime);\n    }\n    public function setIndependent(bool $independent) : self\n    {\n        $this->independent = $independent;\n        return $this;\n    }\n    public function addAnnotation(string $key, string $value) : self\n    {\n        $this->annotations[$key] = $value;\n        return $this;\n    }\n    public function addMetadata(string $key, mixed $value) : self\n    {\n        $this->metadata[$key] = $value;\n        return $this;\n    }\n    public function getCurrentSegment() : self\n    {\n        for ($max = count($this->subsegments); $this->lastOpenSegment < $max; $this->lastOpenSegment++) {\n            if ($this->subsegments[$this->lastOpenSegment]->isOpen()) {\n                return $this->subsegments[$this->lastOpenSegment]->getCurrentSegment();\n            }\n        }\n        return $this;\n    }\n    \/**\n     * @inheritDoc\n     * @return array<string, mixed>\n     *\/\n    public function jsonSerialize() : array\n    {\n        return array_filter(['id' => $this->id, 'parent_id' > $this->parentId, 'trace_id' => $this->traceId ?? null, 'name' => $this->name, 'start_time' => $this->startTime ?? null, 'end_time' => $this->endTime ?? null, 'subsegments' => $this->subsegments ?? null ?: null, 'type' => $this->independent ? 'subsegment' : null, 'fault' => $this->fault ?? null, 'error' => $this->error ?? null, 'annotations' => $this->annotations ?? null ?: null, 'metadata' => $this->metadata ?? null ?: null]);\n    }\n}","originalFilePath":"\/home\/ranpafin\/php-xray\/src\/Segment.php","originalStartLine":200},"diff":"--- Original\n+++ New\n@@ @@\n      *\/\n     public function jsonSerialize() : array\n     {\n-        return array_filter(['id' => $this->id, 'parent_id' => $this->parentId, 'trace_id' => $this->traceId ?? null, 'name' => $this->name, 'start_time' => $this->startTime ?? null, 'end_time' => $this->endTime ?? null, 'subsegments' => $this->subsegments ?? null ?: null, 'type' => $this->independent ? 'subsegment' : null, 'fault' => $this->fault ?? null, 'error' => $this->error ?? null, 'annotations' => $this->annotations ?? null ?: null, 'metadata' => $this->metadata ?? null ?: null]);\n+        return array_filter(['id' => $this->id, 'parent_id' > $this->parentId, 'trace_id' => $this->traceId ?? null, 'name' => $this->name, 'start_time' => $this->startTime ?? null, 'end_time' => $this->endTime ?? null, 'subsegments' => $this->subsegments ?? null ?: null, 'type' => $this->independent ? 'subsegment' : null, 'fault' => $this->fault ?? null, 'error' => $this->error ?? null, 'annotations' => $this->annotations ?? null ?: null, 'metadata' => $this->metadata ?? null ?: null]);\n     }\n }","processOutput":"PHPUnit 9.5.10 by Sebastian Bergmann and contributors.\n\nRuntime:       PHP 8.0.13\nConfiguration: \/tmp\/tmp-folder\/infection\/phpunitConfiguration.f10dbadd94164a9760f0d824753fe768.infection.xml\n\nE\n\nTime: 00:00.003, Memory: 8.00 MB\n\nThere was 1 error:\n\n1) Fido\\PHPXray\\DaemonSegmentSubmitterTest::testSubmitsToDaemon\nsocket_bind(): Unable to bind address [98]: Address already in use\n\n\/home\/ranpafin\/php-xray\/tests\/DaemonSegmentSubmitterTest.php:18\n\nERRORS!\nTests: 1, Assertions: 0, Errors: 1."},{"mutator":{"mutatorName":"Coalesce","originalSourceCode":"<?php\n\nnamespace Fido\\PHPXray;\n\nuse JsonSerializable;\nuse Fido\\PHPXray\\Submission\\SegmentSubmitter;\nclass Segment implements JsonSerializable\n{\n    protected string $id;\n    protected ?string $parentId = null;\n    protected string $traceId;\n    protected ?string $name = null;\n    protected float $startTime;\n    protected float $endTime;\n    \/** @var Segment[] *\/\n    protected array $subsegments = [];\n    protected bool $error = false;\n    protected bool $fault = false;\n    protected bool $sampled = false;\n    protected bool $independent = false;\n    \/** @var array<string, mixed> *\/\n    private array $annotations;\n    \/** @var array<string, mixed> *\/\n    private array $metadata;\n    private int $lastOpenSegment = 0;\n    \/**\n     * @throws \\Exception if an appropriate source of randomness cannot be found.\n     *\/\n    public function __construct()\n    {\n        $this->id = bin2hex(random_bytes(8));\n    }\n    public function setTraceHeader(string $traceHeader = null) : self\n    {\n        if (is_null($traceHeader)) {\n            return $this;\n        }\n        $parts = explode(';', $traceHeader);\n        $variables = array_map(function ($str) : array {\n            return explode('=', $str);\n        }, $parts);\n        $variables = array_column($variables, 1, 0);\n        if (isset($variables['Root'])) {\n            $this->setTraceId($variables['Root']);\n        }\n        if (isset($variables['Sampled'])) {\n            $this->setSampled((bool) $variables['Sampled'] ?? false);\n        }\n        if (isset($variables['Parent'])) {\n            $this->setParentId($variables['Parent'] ?? null);\n        }\n        return $this;\n    }\n    public function begin() : self\n    {\n        $this->startTime = microtime(true);\n        return $this;\n    }\n    public function end() : self\n    {\n        $this->endTime = microtime(true);\n        return $this;\n    }\n    public function setName(string $name) : self\n    {\n        $this->name = $name;\n        return $this;\n    }\n    public function setError(bool $error) : self\n    {\n        $this->error = $error;\n        return $this;\n    }\n    public function setFault(bool $fault) : self\n    {\n        $this->fault = $fault;\n        return $this;\n    }\n    public function addSubsegment(Segment $subsegment) : self\n    {\n        if (!$this->isOpen()) {\n            return $this;\n        }\n        $this->subsegments[] = $subsegment;\n        $subsegment->setSampled($this->isSampled());\n        return $this;\n    }\n    public function submit(SegmentSubmitter $submitter) : void\n    {\n        if (!$this->isSampled()) {\n            return;\n        }\n        $submitter->submitSegment($this);\n    }\n    public function isSampled() : bool\n    {\n        return $this->sampled;\n    }\n    public function setSampled(bool $sampled) : self\n    {\n        $this->sampled = $sampled;\n        return $this;\n    }\n    public function getId() : string\n    {\n        return $this->id;\n    }\n    public function setParentId(?string $parentId) : self\n    {\n        $this->parentId = $parentId;\n        return $this;\n    }\n    public function setTraceId(string $traceId) : self\n    {\n        $this->traceId = $traceId;\n        return $this;\n    }\n    public function getTraceId() : string\n    {\n        return $this->traceId;\n    }\n    public function isOpen() : bool\n    {\n        return isset($this->startTime) && !isset($this->endTime);\n    }\n    public function setIndependent(bool $independent) : self\n    {\n        $this->independent = $independent;\n        return $this;\n    }\n    public function addAnnotation(string $key, string $value) : self\n    {\n        $this->annotations[$key] = $value;\n        return $this;\n    }\n    public function addMetadata(string $key, mixed $value) : self\n    {\n        $this->metadata[$key] = $value;\n        return $this;\n    }\n    public function getCurrentSegment() : self\n    {\n        for ($max = count($this->subsegments); $this->lastOpenSegment < $max; $this->lastOpenSegment++) {\n            if ($this->subsegments[$this->lastOpenSegment]->isOpen()) {\n                return $this->subsegments[$this->lastOpenSegment]->getCurrentSegment();\n            }\n        }\n        return $this;\n    }\n    \/**\n     * @inheritDoc\n     * @return array<string, mixed>\n     *\/\n    public function jsonSerialize() : array\n    {\n        return array_filter(['id' => $this->id, 'parent_id' => $this->parentId, 'trace_id' => $this->traceId ?? null, 'name' => $this->name, 'start_time' => $this->startTime ?? null, 'end_time' => $this->endTime ?? null, 'subsegments' => $this->subsegments ?? null ?: null, 'type' => $this->independent ? 'subsegment' : null, 'fault' => $this->fault ?? null, 'error' => $this->error ?? null, 'annotations' => $this->annotations ?? null ?: null, 'metadata' => $this->metadata ?? null ?: null]);\n    }\n}","mutatedSourceCode":"<?php\n\nnamespace Fido\\PHPXray;\n\nuse JsonSerializable;\nuse Fido\\PHPXray\\Submission\\SegmentSubmitter;\nclass Segment implements JsonSerializable\n{\n    protected string $id;\n    protected ?string $parentId = null;\n    protected string $traceId;\n    protected ?string $name = null;\n    protected float $startTime;\n    protected float $endTime;\n    \/** @var Segment[] *\/\n    protected array $subsegments = [];\n    protected bool $error = false;\n    protected bool $fault = false;\n    protected bool $sampled = false;\n    protected bool $independent = false;\n    \/** @var array<string, mixed> *\/\n    private array $annotations;\n    \/** @var array<string, mixed> *\/\n    private array $metadata;\n    private int $lastOpenSegment = 0;\n    \/**\n     * @throws \\Exception if an appropriate source of randomness cannot be found.\n     *\/\n    public function __construct()\n    {\n        $this->id = bin2hex(random_bytes(8));\n    }\n    public function setTraceHeader(string $traceHeader = null) : self\n    {\n        if (is_null($traceHeader)) {\n            return $this;\n        }\n        $parts = explode(';', $traceHeader);\n        $variables = array_map(function ($str) : array {\n            return explode('=', $str);\n        }, $parts);\n        $variables = array_column($variables, 1, 0);\n        if (isset($variables['Root'])) {\n            $this->setTraceId($variables['Root']);\n        }\n        if (isset($variables['Sampled'])) {\n            $this->setSampled((bool) $variables['Sampled'] ?? false);\n        }\n        if (isset($variables['Parent'])) {\n            $this->setParentId($variables['Parent'] ?? null);\n        }\n        return $this;\n    }\n    public function begin() : self\n    {\n        $this->startTime = microtime(true);\n        return $this;\n    }\n    public function end() : self\n    {\n        $this->endTime = microtime(true);\n        return $this;\n    }\n    public function setName(string $name) : self\n    {\n        $this->name = $name;\n        return $this;\n    }\n    public function setError(bool $error) : self\n    {\n        $this->error = $error;\n        return $this;\n    }\n    public function setFault(bool $fault) : self\n    {\n        $this->fault = $fault;\n        return $this;\n    }\n    public function addSubsegment(Segment $subsegment) : self\n    {\n        if (!$this->isOpen()) {\n            return $this;\n        }\n        $this->subsegments[] = $subsegment;\n        $subsegment->setSampled($this->isSampled());\n        return $this;\n    }\n    public function submit(SegmentSubmitter $submitter) : void\n    {\n        if (!$this->isSampled()) {\n            return;\n        }\n        $submitter->submitSegment($this);\n    }\n    public function isSampled() : bool\n    {\n        return $this->sampled;\n    }\n    public function setSampled(bool $sampled) : self\n    {\n        $this->sampled = $sampled;\n        return $this;\n    }\n    public function getId() : string\n    {\n        return $this->id;\n    }\n    public function setParentId(?string $parentId) : self\n    {\n        $this->parentId = $parentId;\n        return $this;\n    }\n    public function setTraceId(string $traceId) : self\n    {\n        $this->traceId = $traceId;\n        return $this;\n    }\n    public function getTraceId() : string\n    {\n        return $this->traceId;\n    }\n    public function isOpen() : bool\n    {\n        return isset($this->startTime) && !isset($this->endTime);\n    }\n    public function setIndependent(bool $independent) : self\n    {\n        $this->independent = $independent;\n        return $this;\n    }\n    public function addAnnotation(string $key, string $value) : self\n    {\n        $this->annotations[$key] = $value;\n        return $this;\n    }\n    public function addMetadata(string $key, mixed $value) : self\n    {\n        $this->metadata[$key] = $value;\n        return $this;\n    }\n    public function getCurrentSegment() : self\n    {\n        for ($max = count($this->subsegments); $this->lastOpenSegment < $max; $this->lastOpenSegment++) {\n            if ($this->subsegments[$this->lastOpenSegment]->isOpen()) {\n                return $this->subsegments[$this->lastOpenSegment]->getCurrentSegment();\n            }\n        }\n        return $this;\n    }\n    \/**\n     * @inheritDoc\n     * @return array<string, mixed>\n     *\/\n    public function jsonSerialize() : array\n    {\n        return array_filter(['id' => $this->id, 'parent_id' => $this->parentId, 'trace_id' => null ?? $this->traceId, 'name' => $this->name, 'start_time' => $this->startTime ?? null, 'end_time' => $this->endTime ?? null, 'subsegments' => $this->subsegments ?? null ?: null, 'type' => $this->independent ? 'subsegment' : null, 'fault' => $this->fault ?? null, 'error' => $this->error ?? null, 'annotations' => $this->annotations ?? null ?: null, 'metadata' => $this->metadata ?? null ?: null]);\n    }\n}","originalFilePath":"\/home\/ranpafin\/php-xray\/src\/Segment.php","originalStartLine":201},"diff":"--- Original\n+++ New\n@@ @@\n      *\/\n     public function jsonSerialize() : array\n     {\n-        return array_filter(['id' => $this->id, 'parent_id' => $this->parentId, 'trace_id' => $this->traceId ?? null, 'name' => $this->name, 'start_time' => $this->startTime ?? null, 'end_time' => $this->endTime ?? null, 'subsegments' => $this->subsegments ?? null ?: null, 'type' => $this->independent ? 'subsegment' : null, 'fault' => $this->fault ?? null, 'error' => $this->error ?? null, 'annotations' => $this->annotations ?? null ?: null, 'metadata' => $this->metadata ?? null ?: null]);\n+        return array_filter(['id' => $this->id, 'parent_id' => $this->parentId, 'trace_id' => null ?? $this->traceId, 'name' => $this->name, 'start_time' => $this->startTime ?? null, 'end_time' => $this->endTime ?? null, 'subsegments' => $this->subsegments ?? null ?: null, 'type' => $this->independent ? 'subsegment' : null, 'fault' => $this->fault ?? null, 'error' => $this->error ?? null, 'annotations' => $this->annotations ?? null ?: null, 'metadata' => $this->metadata ?? null ?: null]);\n     }\n }","processOutput":"PHPUnit 9.5.10 by Sebastian Bergmann and contributors.\n\nRuntime:       PHP 8.0.13\nConfiguration: \/tmp\/tmp-folder\/infection\/phpunitConfiguration.6e8a6d3c0dd28d620f1ede20c7409b12.infection.xml\n\nE\n\nTime: 00:00.004, Memory: 8.00 MB\n\nThere was 1 error:\n\n1) Fido\\PHPXray\\SqlSegmentTest::testSerialisesCorrectly\nError: Typed property Fido\\PHPXray\\Segment::$traceId must not be accessed before initialization\n\n\/home\/ranpafin\/php-xray\/src\/Segment.php:156\n\/home\/ranpafin\/php-xray\/src\/RemoteSegment.php:21\n\/home\/ranpafin\/php-xray\/src\/SqlSegment.php:69\n\/home\/ranpafin\/php-xray\/tests\/SqlSegmentTest.php:21\n\nERRORS!\nTests: 1, Assertions: 0, Errors: 1."},{"mutator":{"mutatorName":"ArrayItem","originalSourceCode":"<?php\n\nnamespace Fido\\PHPXray;\n\nuse JsonSerializable;\nuse Fido\\PHPXray\\Submission\\SegmentSubmitter;\nclass Segment implements JsonSerializable\n{\n    protected string $id;\n    protected ?string $parentId = null;\n    protected string $traceId;\n    protected ?string $name = null;\n    protected float $startTime;\n    protected float $endTime;\n    \/** @var Segment[] *\/\n    protected array $subsegments = [];\n    protected bool $error = false;\n    protected bool $fault = false;\n    protected bool $sampled = false;\n    protected bool $independent = false;\n    \/** @var array<string, mixed> *\/\n    private array $annotations;\n    \/** @var array<string, mixed> *\/\n    private array $metadata;\n    private int $lastOpenSegment = 0;\n    \/**\n     * @throws \\Exception if an appropriate source of randomness cannot be found.\n     *\/\n    public function __construct()\n    {\n        $this->id = bin2hex(random_bytes(8));\n    }\n    public function setTraceHeader(string $traceHeader = null) : self\n    {\n        if (is_null($traceHeader)) {\n            return $this;\n        }\n        $parts = explode(';', $traceHeader);\n        $variables = array_map(function ($str) : array {\n            return explode('=', $str);\n        }, $parts);\n        $variables = array_column($variables, 1, 0);\n        if (isset($variables['Root'])) {\n            $this->setTraceId($variables['Root']);\n        }\n        if (isset($variables['Sampled'])) {\n            $this->setSampled((bool) $variables['Sampled'] ?? false);\n        }\n        if (isset($variables['Parent'])) {\n            $this->setParentId($variables['Parent'] ?? null);\n        }\n        return $this;\n    }\n    public function begin() : self\n    {\n        $this->startTime = microtime(true);\n        return $this;\n    }\n    public function end() : self\n    {\n        $this->endTime = microtime(true);\n        return $this;\n    }\n    public function setName(string $name) : self\n    {\n        $this->name = $name;\n        return $this;\n    }\n    public function setError(bool $error) : self\n    {\n        $this->error = $error;\n        return $this;\n    }\n    public function setFault(bool $fault) : self\n    {\n        $this->fault = $fault;\n        return $this;\n    }\n    public function addSubsegment(Segment $subsegment) : self\n    {\n        if (!$this->isOpen()) {\n            return $this;\n        }\n        $this->subsegments[] = $subsegment;\n        $subsegment->setSampled($this->isSampled());\n        return $this;\n    }\n    public function submit(SegmentSubmitter $submitter) : void\n    {\n        if (!$this->isSampled()) {\n            return;\n        }\n        $submitter->submitSegment($this);\n    }\n    public function isSampled() : bool\n    {\n        return $this->sampled;\n    }\n    public function setSampled(bool $sampled) : self\n    {\n        $this->sampled = $sampled;\n        return $this;\n    }\n    public function getId() : string\n    {\n        return $this->id;\n    }\n    public function setParentId(?string $parentId) : self\n    {\n        $this->parentId = $parentId;\n        return $this;\n    }\n    public function setTraceId(string $traceId) : self\n    {\n        $this->traceId = $traceId;\n        return $this;\n    }\n    public function getTraceId() : string\n    {\n        return $this->traceId;\n    }\n    public function isOpen() : bool\n    {\n        return isset($this->startTime) && !isset($this->endTime);\n    }\n    public function setIndependent(bool $independent) : self\n    {\n        $this->independent = $independent;\n        return $this;\n    }\n    public function addAnnotation(string $key, string $value) : self\n    {\n        $this->annotations[$key] = $value;\n        return $this;\n    }\n    public function addMetadata(string $key, mixed $value) : self\n    {\n        $this->metadata[$key] = $value;\n        return $this;\n    }\n    public function getCurrentSegment() : self\n    {\n        for ($max = count($this->subsegments); $this->lastOpenSegment < $max; $this->lastOpenSegment++) {\n            if ($this->subsegments[$this->lastOpenSegment]->isOpen()) {\n                return $this->subsegments[$this->lastOpenSegment]->getCurrentSegment();\n            }\n        }\n        return $this;\n    }\n    \/**\n     * @inheritDoc\n     * @return array<string, mixed>\n     *\/\n    public function jsonSerialize() : array\n    {\n        return array_filter(['id' => $this->id, 'parent_id' => $this->parentId, 'trace_id' => $this->traceId ?? null, 'name' => $this->name, 'start_time' => $this->startTime ?? null, 'end_time' => $this->endTime ?? null, 'subsegments' => $this->subsegments ?? null ?: null, 'type' => $this->independent ? 'subsegment' : null, 'fault' => $this->fault ?? null, 'error' => $this->error ?? null, 'annotations' => $this->annotations ?? null ?: null, 'metadata' => $this->metadata ?? null ?: null]);\n    }\n}","mutatedSourceCode":"<?php\n\nnamespace Fido\\PHPXray;\n\nuse JsonSerializable;\nuse Fido\\PHPXray\\Submission\\SegmentSubmitter;\nclass Segment implements JsonSerializable\n{\n    protected string $id;\n    protected ?string $parentId = null;\n    protected string $traceId;\n    protected ?string $name = null;\n    protected float $startTime;\n    protected float $endTime;\n    \/** @var Segment[] *\/\n    protected array $subsegments = [];\n    protected bool $error = false;\n    protected bool $fault = false;\n    protected bool $sampled = false;\n    protected bool $independent = false;\n    \/** @var array<string, mixed> *\/\n    private array $annotations;\n    \/** @var array<string, mixed> *\/\n    private array $metadata;\n    private int $lastOpenSegment = 0;\n    \/**\n     * @throws \\Exception if an appropriate source of randomness cannot be found.\n     *\/\n    public function __construct()\n    {\n        $this->id = bin2hex(random_bytes(8));\n    }\n    public function setTraceHeader(string $traceHeader = null) : self\n    {\n        if (is_null($traceHeader)) {\n            return $this;\n        }\n        $parts = explode(';', $traceHeader);\n        $variables = array_map(function ($str) : array {\n            return explode('=', $str);\n        }, $parts);\n        $variables = array_column($variables, 1, 0);\n        if (isset($variables['Root'])) {\n            $this->setTraceId($variables['Root']);\n        }\n        if (isset($variables['Sampled'])) {\n            $this->setSampled((bool) $variables['Sampled'] ?? false);\n        }\n        if (isset($variables['Parent'])) {\n            $this->setParentId($variables['Parent'] ?? null);\n        }\n        return $this;\n    }\n    public function begin() : self\n    {\n        $this->startTime = microtime(true);\n        return $this;\n    }\n    public function end() : self\n    {\n        $this->endTime = microtime(true);\n        return $this;\n    }\n    public function setName(string $name) : self\n    {\n        $this->name = $name;\n        return $this;\n    }\n    public function setError(bool $error) : self\n    {\n        $this->error = $error;\n        return $this;\n    }\n    public function setFault(bool $fault) : self\n    {\n        $this->fault = $fault;\n        return $this;\n    }\n    public function addSubsegment(Segment $subsegment) : self\n    {\n        if (!$this->isOpen()) {\n            return $this;\n        }\n        $this->subsegments[] = $subsegment;\n        $subsegment->setSampled($this->isSampled());\n        return $this;\n    }\n    public function submit(SegmentSubmitter $submitter) : void\n    {\n        if (!$this->isSampled()) {\n            return;\n        }\n        $submitter->submitSegment($this);\n    }\n    public function isSampled() : bool\n    {\n        return $this->sampled;\n    }\n    public function setSampled(bool $sampled) : self\n    {\n        $this->sampled = $sampled;\n        return $this;\n    }\n    public function getId() : string\n    {\n        return $this->id;\n    }\n    public function setParentId(?string $parentId) : self\n    {\n        $this->parentId = $parentId;\n        return $this;\n    }\n    public function setTraceId(string $traceId) : self\n    {\n        $this->traceId = $traceId;\n        return $this;\n    }\n    public function getTraceId() : string\n    {\n        return $this->traceId;\n    }\n    public function isOpen() : bool\n    {\n        return isset($this->startTime) && !isset($this->endTime);\n    }\n    public function setIndependent(bool $independent) : self\n    {\n        $this->independent = $independent;\n        return $this;\n    }\n    public function addAnnotation(string $key, string $value) : self\n    {\n        $this->annotations[$key] = $value;\n        return $this;\n    }\n    public function addMetadata(string $key, mixed $value) : self\n    {\n        $this->metadata[$key] = $value;\n        return $this;\n    }\n    public function getCurrentSegment() : self\n    {\n        for ($max = count($this->subsegments); $this->lastOpenSegment < $max; $this->lastOpenSegment++) {\n            if ($this->subsegments[$this->lastOpenSegment]->isOpen()) {\n                return $this->subsegments[$this->lastOpenSegment]->getCurrentSegment();\n            }\n        }\n        return $this;\n    }\n    \/**\n     * @inheritDoc\n     * @return array<string, mixed>\n     *\/\n    public function jsonSerialize() : array\n    {\n        return array_filter(['id' => $this->id, 'parent_id' => $this->parentId, 'trace_id' => $this->traceId ?? null, 'name' > $this->name, 'start_time' => $this->startTime ?? null, 'end_time' => $this->endTime ?? null, 'subsegments' => $this->subsegments ?? null ?: null, 'type' => $this->independent ? 'subsegment' : null, 'fault' => $this->fault ?? null, 'error' => $this->error ?? null, 'annotations' => $this->annotations ?? null ?: null, 'metadata' => $this->metadata ?? null ?: null]);\n    }\n}","originalFilePath":"\/home\/ranpafin\/php-xray\/src\/Segment.php","originalStartLine":202},"diff":"--- Original\n+++ New\n@@ @@\n      *\/\n     public function jsonSerialize() : array\n     {\n-        return array_filter(['id' => $this->id, 'parent_id' => $this->parentId, 'trace_id' => $this->traceId ?? null, 'name' => $this->name, 'start_time' => $this->startTime ?? null, 'end_time' => $this->endTime ?? null, 'subsegments' => $this->subsegments ?? null ?: null, 'type' => $this->independent ? 'subsegment' : null, 'fault' => $this->fault ?? null, 'error' => $this->error ?? null, 'annotations' => $this->annotations ?? null ?: null, 'metadata' => $this->metadata ?? null ?: null]);\n+        return array_filter(['id' => $this->id, 'parent_id' => $this->parentId, 'trace_id' => $this->traceId ?? null, 'name' > $this->name, 'start_time' => $this->startTime ?? null, 'end_time' => $this->endTime ?? null, 'subsegments' => $this->subsegments ?? null ?: null, 'type' => $this->independent ? 'subsegment' : null, 'fault' => $this->fault ?? null, 'error' => $this->error ?? null, 'annotations' => $this->annotations ?? null ?: null, 'metadata' => $this->metadata ?? null ?: null]);\n     }\n }","processOutput":"PHPUnit 9.5.10 by Sebastian Bergmann and contributors.\n\nRuntime:       PHP 8.0.13\nConfiguration: \/tmp\/tmp-folder\/infection\/phpunitConfiguration.f76b5276a71e4e729a481f7138174919.infection.xml\n\nE\n\nTime: 00:00.004, Memory: 8.00 MB\n\nThere was 1 error:\n\n1) Fido\\PHPXray\\DaemonSegmentSubmitterTest::testSubmitsToDaemon\nsocket_bind(): Unable to bind address [98]: Address already in use\n\n\/home\/ranpafin\/php-xray\/tests\/DaemonSegmentSubmitterTest.php:18\n\nERRORS!\nTests: 1, Assertions: 0, Errors: 1."},{"mutator":{"mutatorName":"Coalesce","originalSourceCode":"<?php\n\nnamespace Fido\\PHPXray;\n\nuse JsonSerializable;\nuse Fido\\PHPXray\\Submission\\SegmentSubmitter;\nclass Segment implements JsonSerializable\n{\n    protected string $id;\n    protected ?string $parentId = null;\n    protected string $traceId;\n    protected ?string $name = null;\n    protected float $startTime;\n    protected float $endTime;\n    \/** @var Segment[] *\/\n    protected array $subsegments = [];\n    protected bool $error = false;\n    protected bool $fault = false;\n    protected bool $sampled = false;\n    protected bool $independent = false;\n    \/** @var array<string, mixed> *\/\n    private array $annotations;\n    \/** @var array<string, mixed> *\/\n    private array $metadata;\n    private int $lastOpenSegment = 0;\n    \/**\n     * @throws \\Exception if an appropriate source of randomness cannot be found.\n     *\/\n    public function __construct()\n    {\n        $this->id = bin2hex(random_bytes(8));\n    }\n    public function setTraceHeader(string $traceHeader = null) : self\n    {\n        if (is_null($traceHeader)) {\n            return $this;\n        }\n        $parts = explode(';', $traceHeader);\n        $variables = array_map(function ($str) : array {\n            return explode('=', $str);\n        }, $parts);\n        $variables = array_column($variables, 1, 0);\n        if (isset($variables['Root'])) {\n            $this->setTraceId($variables['Root']);\n        }\n        if (isset($variables['Sampled'])) {\n            $this->setSampled((bool) $variables['Sampled'] ?? false);\n        }\n        if (isset($variables['Parent'])) {\n            $this->setParentId($variables['Parent'] ?? null);\n        }\n        return $this;\n    }\n    public function begin() : self\n    {\n        $this->startTime = microtime(true);\n        return $this;\n    }\n    public function end() : self\n    {\n        $this->endTime = microtime(true);\n        return $this;\n    }\n    public function setName(string $name) : self\n    {\n        $this->name = $name;\n        return $this;\n    }\n    public function setError(bool $error) : self\n    {\n        $this->error = $error;\n        return $this;\n    }\n    public function setFault(bool $fault) : self\n    {\n        $this->fault = $fault;\n        return $this;\n    }\n    public function addSubsegment(Segment $subsegment) : self\n    {\n        if (!$this->isOpen()) {\n            return $this;\n        }\n        $this->subsegments[] = $subsegment;\n        $subsegment->setSampled($this->isSampled());\n        return $this;\n    }\n    public function submit(SegmentSubmitter $submitter) : void\n    {\n        if (!$this->isSampled()) {\n            return;\n        }\n        $submitter->submitSegment($this);\n    }\n    public function isSampled() : bool\n    {\n        return $this->sampled;\n    }\n    public function setSampled(bool $sampled) : self\n    {\n        $this->sampled = $sampled;\n        return $this;\n    }\n    public function getId() : string\n    {\n        return $this->id;\n    }\n    public function setParentId(?string $parentId) : self\n    {\n        $this->parentId = $parentId;\n        return $this;\n    }\n    public function setTraceId(string $traceId) : self\n    {\n        $this->traceId = $traceId;\n        return $this;\n    }\n    public function getTraceId() : string\n    {\n        return $this->traceId;\n    }\n    public function isOpen() : bool\n    {\n        return isset($this->startTime) && !isset($this->endTime);\n    }\n    public function setIndependent(bool $independent) : self\n    {\n        $this->independent = $independent;\n        return $this;\n    }\n    public function addAnnotation(string $key, string $value) : self\n    {\n        $this->annotations[$key] = $value;\n        return $this;\n    }\n    public function addMetadata(string $key, mixed $value) : self\n    {\n        $this->metadata[$key] = $value;\n        return $this;\n    }\n    public function getCurrentSegment() : self\n    {\n        for ($max = count($this->subsegments); $this->lastOpenSegment < $max; $this->lastOpenSegment++) {\n            if ($this->subsegments[$this->lastOpenSegment]->isOpen()) {\n                return $this->subsegments[$this->lastOpenSegment]->getCurrentSegment();\n            }\n        }\n        return $this;\n    }\n    \/**\n     * @inheritDoc\n     * @return array<string, mixed>\n     *\/\n    public function jsonSerialize() : array\n    {\n        return array_filter(['id' => $this->id, 'parent_id' => $this->parentId, 'trace_id' => $this->traceId ?? null, 'name' => $this->name, 'start_time' => $this->startTime ?? null, 'end_time' => $this->endTime ?? null, 'subsegments' => $this->subsegments ?? null ?: null, 'type' => $this->independent ? 'subsegment' : null, 'fault' => $this->fault ?? null, 'error' => $this->error ?? null, 'annotations' => $this->annotations ?? null ?: null, 'metadata' => $this->metadata ?? null ?: null]);\n    }\n}","mutatedSourceCode":"<?php\n\nnamespace Fido\\PHPXray;\n\nuse JsonSerializable;\nuse Fido\\PHPXray\\Submission\\SegmentSubmitter;\nclass Segment implements JsonSerializable\n{\n    protected string $id;\n    protected ?string $parentId = null;\n    protected string $traceId;\n    protected ?string $name = null;\n    protected float $startTime;\n    protected float $endTime;\n    \/** @var Segment[] *\/\n    protected array $subsegments = [];\n    protected bool $error = false;\n    protected bool $fault = false;\n    protected bool $sampled = false;\n    protected bool $independent = false;\n    \/** @var array<string, mixed> *\/\n    private array $annotations;\n    \/** @var array<string, mixed> *\/\n    private array $metadata;\n    private int $lastOpenSegment = 0;\n    \/**\n     * @throws \\Exception if an appropriate source of randomness cannot be found.\n     *\/\n    public function __construct()\n    {\n        $this->id = bin2hex(random_bytes(8));\n    }\n    public function setTraceHeader(string $traceHeader = null) : self\n    {\n        if (is_null($traceHeader)) {\n            return $this;\n        }\n        $parts = explode(';', $traceHeader);\n        $variables = array_map(function ($str) : array {\n            return explode('=', $str);\n        }, $parts);\n        $variables = array_column($variables, 1, 0);\n        if (isset($variables['Root'])) {\n            $this->setTraceId($variables['Root']);\n        }\n        if (isset($variables['Sampled'])) {\n            $this->setSampled((bool) $variables['Sampled'] ?? false);\n        }\n        if (isset($variables['Parent'])) {\n            $this->setParentId($variables['Parent'] ?? null);\n        }\n        return $this;\n    }\n    public function begin() : self\n    {\n        $this->startTime = microtime(true);\n        return $this;\n    }\n    public function end() : self\n    {\n        $this->endTime = microtime(true);\n        return $this;\n    }\n    public function setName(string $name) : self\n    {\n        $this->name = $name;\n        return $this;\n    }\n    public function setError(bool $error) : self\n    {\n        $this->error = $error;\n        return $this;\n    }\n    public function setFault(bool $fault) : self\n    {\n        $this->fault = $fault;\n        return $this;\n    }\n    public function addSubsegment(Segment $subsegment) : self\n    {\n        if (!$this->isOpen()) {\n            return $this;\n        }\n        $this->subsegments[] = $subsegment;\n        $subsegment->setSampled($this->isSampled());\n        return $this;\n    }\n    public function submit(SegmentSubmitter $submitter) : void\n    {\n        if (!$this->isSampled()) {\n            return;\n        }\n        $submitter->submitSegment($this);\n    }\n    public function isSampled() : bool\n    {\n        return $this->sampled;\n    }\n    public function setSampled(bool $sampled) : self\n    {\n        $this->sampled = $sampled;\n        return $this;\n    }\n    public function getId() : string\n    {\n        return $this->id;\n    }\n    public function setParentId(?string $parentId) : self\n    {\n        $this->parentId = $parentId;\n        return $this;\n    }\n    public function setTraceId(string $traceId) : self\n    {\n        $this->traceId = $traceId;\n        return $this;\n    }\n    public function getTraceId() : string\n    {\n        return $this->traceId;\n    }\n    public function isOpen() : bool\n    {\n        return isset($this->startTime) && !isset($this->endTime);\n    }\n    public function setIndependent(bool $independent) : self\n    {\n        $this->independent = $independent;\n        return $this;\n    }\n    public function addAnnotation(string $key, string $value) : self\n    {\n        $this->annotations[$key] = $value;\n        return $this;\n    }\n    public function addMetadata(string $key, mixed $value) : self\n    {\n        $this->metadata[$key] = $value;\n        return $this;\n    }\n    public function getCurrentSegment() : self\n    {\n        for ($max = count($this->subsegments); $this->lastOpenSegment < $max; $this->lastOpenSegment++) {\n            if ($this->subsegments[$this->lastOpenSegment]->isOpen()) {\n                return $this->subsegments[$this->lastOpenSegment]->getCurrentSegment();\n            }\n        }\n        return $this;\n    }\n    \/**\n     * @inheritDoc\n     * @return array<string, mixed>\n     *\/\n    public function jsonSerialize() : array\n    {\n        return array_filter(['id' => $this->id, 'parent_id' => $this->parentId, 'trace_id' => $this->traceId ?? null, 'name' => $this->name, 'start_time' => null ?? $this->startTime, 'end_time' => $this->endTime ?? null, 'subsegments' => $this->subsegments ?? null ?: null, 'type' => $this->independent ? 'subsegment' : null, 'fault' => $this->fault ?? null, 'error' => $this->error ?? null, 'annotations' => $this->annotations ?? null ?: null, 'metadata' => $this->metadata ?? null ?: null]);\n    }\n}","originalFilePath":"\/home\/ranpafin\/php-xray\/src\/Segment.php","originalStartLine":203},"diff":"--- Original\n+++ New\n@@ @@\n      *\/\n     public function jsonSerialize() : array\n     {\n-        return array_filter(['id' => $this->id, 'parent_id' => $this->parentId, 'trace_id' => $this->traceId ?? null, 'name' => $this->name, 'start_time' => $this->startTime ?? null, 'end_time' => $this->endTime ?? null, 'subsegments' => $this->subsegments ?? null ?: null, 'type' => $this->independent ? 'subsegment' : null, 'fault' => $this->fault ?? null, 'error' => $this->error ?? null, 'annotations' => $this->annotations ?? null ?: null, 'metadata' => $this->metadata ?? null ?: null]);\n+        return array_filter(['id' => $this->id, 'parent_id' => $this->parentId, 'trace_id' => $this->traceId ?? null, 'name' => $this->name, 'start_time' => null ?? $this->startTime, 'end_time' => $this->endTime ?? null, 'subsegments' => $this->subsegments ?? null ?: null, 'type' => $this->independent ? 'subsegment' : null, 'fault' => $this->fault ?? null, 'error' => $this->error ?? null, 'annotations' => $this->annotations ?? null ?: null, 'metadata' => $this->metadata ?? null ?: null]);\n     }\n }","processOutput":"PHPUnit 9.5.10 by Sebastian Bergmann and contributors.\n\nRuntime:       PHP 8.0.13\nConfiguration: \/tmp\/tmp-folder\/infection\/phpunitConfiguration.4333075b37d5283cc8c30b4c78b41287.infection.xml\n\nE\n\nTime: 00:00.004, Memory: 8.00 MB\n\nThere was 1 error:\n\n1) Fido\\PHPXray\\SqlSegmentTest::testSerialisesCorrectly\nError: Typed property Fido\\PHPXray\\Segment::$startTime must not be accessed before initialization\n\n\/home\/ranpafin\/php-xray\/src\/Segment.php:156\n\/home\/ranpafin\/php-xray\/src\/RemoteSegment.php:21\n\/home\/ranpafin\/php-xray\/src\/SqlSegment.php:69\n\/home\/ranpafin\/php-xray\/tests\/SqlSegmentTest.php:21\n\nERRORS!\nTests: 1, Assertions: 0, Errors: 1."},{"mutator":{"mutatorName":"Coalesce","originalSourceCode":"<?php\n\nnamespace Fido\\PHPXray;\n\nuse JsonSerializable;\nuse Fido\\PHPXray\\Submission\\SegmentSubmitter;\nclass Segment implements JsonSerializable\n{\n    protected string $id;\n    protected ?string $parentId = null;\n    protected string $traceId;\n    protected ?string $name = null;\n    protected float $startTime;\n    protected float $endTime;\n    \/** @var Segment[] *\/\n    protected array $subsegments = [];\n    protected bool $error = false;\n    protected bool $fault = false;\n    protected bool $sampled = false;\n    protected bool $independent = false;\n    \/** @var array<string, mixed> *\/\n    private array $annotations;\n    \/** @var array<string, mixed> *\/\n    private array $metadata;\n    private int $lastOpenSegment = 0;\n    \/**\n     * @throws \\Exception if an appropriate source of randomness cannot be found.\n     *\/\n    public function __construct()\n    {\n        $this->id = bin2hex(random_bytes(8));\n    }\n    public function setTraceHeader(string $traceHeader = null) : self\n    {\n        if (is_null($traceHeader)) {\n            return $this;\n        }\n        $parts = explode(';', $traceHeader);\n        $variables = array_map(function ($str) : array {\n            return explode('=', $str);\n        }, $parts);\n        $variables = array_column($variables, 1, 0);\n        if (isset($variables['Root'])) {\n            $this->setTraceId($variables['Root']);\n        }\n        if (isset($variables['Sampled'])) {\n            $this->setSampled((bool) $variables['Sampled'] ?? false);\n        }\n        if (isset($variables['Parent'])) {\n            $this->setParentId($variables['Parent'] ?? null);\n        }\n        return $this;\n    }\n    public function begin() : self\n    {\n        $this->startTime = microtime(true);\n        return $this;\n    }\n    public function end() : self\n    {\n        $this->endTime = microtime(true);\n        return $this;\n    }\n    public function setName(string $name) : self\n    {\n        $this->name = $name;\n        return $this;\n    }\n    public function setError(bool $error) : self\n    {\n        $this->error = $error;\n        return $this;\n    }\n    public function setFault(bool $fault) : self\n    {\n        $this->fault = $fault;\n        return $this;\n    }\n    public function addSubsegment(Segment $subsegment) : self\n    {\n        if (!$this->isOpen()) {\n            return $this;\n        }\n        $this->subsegments[] = $subsegment;\n        $subsegment->setSampled($this->isSampled());\n        return $this;\n    }\n    public function submit(SegmentSubmitter $submitter) : void\n    {\n        if (!$this->isSampled()) {\n            return;\n        }\n        $submitter->submitSegment($this);\n    }\n    public function isSampled() : bool\n    {\n        return $this->sampled;\n    }\n    public function setSampled(bool $sampled) : self\n    {\n        $this->sampled = $sampled;\n        return $this;\n    }\n    public function getId() : string\n    {\n        return $this->id;\n    }\n    public function setParentId(?string $parentId) : self\n    {\n        $this->parentId = $parentId;\n        return $this;\n    }\n    public function setTraceId(string $traceId) : self\n    {\n        $this->traceId = $traceId;\n        return $this;\n    }\n    public function getTraceId() : string\n    {\n        return $this->traceId;\n    }\n    public function isOpen() : bool\n    {\n        return isset($this->startTime) && !isset($this->endTime);\n    }\n    public function setIndependent(bool $independent) : self\n    {\n        $this->independent = $independent;\n        return $this;\n    }\n    public function addAnnotation(string $key, string $value) : self\n    {\n        $this->annotations[$key] = $value;\n        return $this;\n    }\n    public function addMetadata(string $key, mixed $value) : self\n    {\n        $this->metadata[$key] = $value;\n        return $this;\n    }\n    public function getCurrentSegment() : self\n    {\n        for ($max = count($this->subsegments); $this->lastOpenSegment < $max; $this->lastOpenSegment++) {\n            if ($this->subsegments[$this->lastOpenSegment]->isOpen()) {\n                return $this->subsegments[$this->lastOpenSegment]->getCurrentSegment();\n            }\n        }\n        return $this;\n    }\n    \/**\n     * @inheritDoc\n     * @return array<string, mixed>\n     *\/\n    public function jsonSerialize() : array\n    {\n        return array_filter(['id' => $this->id, 'parent_id' => $this->parentId, 'trace_id' => $this->traceId ?? null, 'name' => $this->name, 'start_time' => $this->startTime ?? null, 'end_time' => $this->endTime ?? null, 'subsegments' => $this->subsegments ?? null ?: null, 'type' => $this->independent ? 'subsegment' : null, 'fault' => $this->fault ?? null, 'error' => $this->error ?? null, 'annotations' => $this->annotations ?? null ?: null, 'metadata' => $this->metadata ?? null ?: null]);\n    }\n}","mutatedSourceCode":"<?php\n\nnamespace Fido\\PHPXray;\n\nuse JsonSerializable;\nuse Fido\\PHPXray\\Submission\\SegmentSubmitter;\nclass Segment implements JsonSerializable\n{\n    protected string $id;\n    protected ?string $parentId = null;\n    protected string $traceId;\n    protected ?string $name = null;\n    protected float $startTime;\n    protected float $endTime;\n    \/** @var Segment[] *\/\n    protected array $subsegments = [];\n    protected bool $error = false;\n    protected bool $fault = false;\n    protected bool $sampled = false;\n    protected bool $independent = false;\n    \/** @var array<string, mixed> *\/\n    private array $annotations;\n    \/** @var array<string, mixed> *\/\n    private array $metadata;\n    private int $lastOpenSegment = 0;\n    \/**\n     * @throws \\Exception if an appropriate source of randomness cannot be found.\n     *\/\n    public function __construct()\n    {\n        $this->id = bin2hex(random_bytes(8));\n    }\n    public function setTraceHeader(string $traceHeader = null) : self\n    {\n        if (is_null($traceHeader)) {\n            return $this;\n        }\n        $parts = explode(';', $traceHeader);\n        $variables = array_map(function ($str) : array {\n            return explode('=', $str);\n        }, $parts);\n        $variables = array_column($variables, 1, 0);\n        if (isset($variables['Root'])) {\n            $this->setTraceId($variables['Root']);\n        }\n        if (isset($variables['Sampled'])) {\n            $this->setSampled((bool) $variables['Sampled'] ?? false);\n        }\n        if (isset($variables['Parent'])) {\n            $this->setParentId($variables['Parent'] ?? null);\n        }\n        return $this;\n    }\n    public function begin() : self\n    {\n        $this->startTime = microtime(true);\n        return $this;\n    }\n    public function end() : self\n    {\n        $this->endTime = microtime(true);\n        return $this;\n    }\n    public function setName(string $name) : self\n    {\n        $this->name = $name;\n        return $this;\n    }\n    public function setError(bool $error) : self\n    {\n        $this->error = $error;\n        return $this;\n    }\n    public function setFault(bool $fault) : self\n    {\n        $this->fault = $fault;\n        return $this;\n    }\n    public function addSubsegment(Segment $subsegment) : self\n    {\n        if (!$this->isOpen()) {\n            return $this;\n        }\n        $this->subsegments[] = $subsegment;\n        $subsegment->setSampled($this->isSampled());\n        return $this;\n    }\n    public function submit(SegmentSubmitter $submitter) : void\n    {\n        if (!$this->isSampled()) {\n            return;\n        }\n        $submitter->submitSegment($this);\n    }\n    public function isSampled() : bool\n    {\n        return $this->sampled;\n    }\n    public function setSampled(bool $sampled) : self\n    {\n        $this->sampled = $sampled;\n        return $this;\n    }\n    public function getId() : string\n    {\n        return $this->id;\n    }\n    public function setParentId(?string $parentId) : self\n    {\n        $this->parentId = $parentId;\n        return $this;\n    }\n    public function setTraceId(string $traceId) : self\n    {\n        $this->traceId = $traceId;\n        return $this;\n    }\n    public function getTraceId() : string\n    {\n        return $this->traceId;\n    }\n    public function isOpen() : bool\n    {\n        return isset($this->startTime) && !isset($this->endTime);\n    }\n    public function setIndependent(bool $independent) : self\n    {\n        $this->independent = $independent;\n        return $this;\n    }\n    public function addAnnotation(string $key, string $value) : self\n    {\n        $this->annotations[$key] = $value;\n        return $this;\n    }\n    public function addMetadata(string $key, mixed $value) : self\n    {\n        $this->metadata[$key] = $value;\n        return $this;\n    }\n    public function getCurrentSegment() : self\n    {\n        for ($max = count($this->subsegments); $this->lastOpenSegment < $max; $this->lastOpenSegment++) {\n            if ($this->subsegments[$this->lastOpenSegment]->isOpen()) {\n                return $this->subsegments[$this->lastOpenSegment]->getCurrentSegment();\n            }\n        }\n        return $this;\n    }\n    \/**\n     * @inheritDoc\n     * @return array<string, mixed>\n     *\/\n    public function jsonSerialize() : array\n    {\n        return array_filter(['id' => $this->id, 'parent_id' => $this->parentId, 'trace_id' => $this->traceId ?? null, 'name' => $this->name, 'start_time' => $this->startTime ?? null, 'end_time' => null ?? $this->endTime, 'subsegments' => $this->subsegments ?? null ?: null, 'type' => $this->independent ? 'subsegment' : null, 'fault' => $this->fault ?? null, 'error' => $this->error ?? null, 'annotations' => $this->annotations ?? null ?: null, 'metadata' => $this->metadata ?? null ?: null]);\n    }\n}","originalFilePath":"\/home\/ranpafin\/php-xray\/src\/Segment.php","originalStartLine":204},"diff":"--- Original\n+++ New\n@@ @@\n      *\/\n     public function jsonSerialize() : array\n     {\n-        return array_filter(['id' => $this->id, 'parent_id' => $this->parentId, 'trace_id' => $this->traceId ?? null, 'name' => $this->name, 'start_time' => $this->startTime ?? null, 'end_time' => $this->endTime ?? null, 'subsegments' => $this->subsegments ?? null ?: null, 'type' => $this->independent ? 'subsegment' : null, 'fault' => $this->fault ?? null, 'error' => $this->error ?? null, 'annotations' => $this->annotations ?? null ?: null, 'metadata' => $this->metadata ?? null ?: null]);\n+        return array_filter(['id' => $this->id, 'parent_id' => $this->parentId, 'trace_id' => $this->traceId ?? null, 'name' => $this->name, 'start_time' => $this->startTime ?? null, 'end_time' => null ?? $this->endTime, 'subsegments' => $this->subsegments ?? null ?: null, 'type' => $this->independent ? 'subsegment' : null, 'fault' => $this->fault ?? null, 'error' => $this->error ?? null, 'annotations' => $this->annotations ?? null ?: null, 'metadata' => $this->metadata ?? null ?: null]);\n     }\n }","processOutput":"PHPUnit 9.5.10 by Sebastian Bergmann and contributors.\n\nRuntime:       PHP 8.0.13\nConfiguration: \/tmp\/tmp-folder\/infection\/phpunitConfiguration.9479323ac9b6f399107907a8047a9ece.infection.xml\n\nE\n\nTime: 00:00.004, Memory: 8.00 MB\n\nThere was 1 error:\n\n1) Fido\\PHPXray\\SqlSegmentTest::testSerialisesCorrectly\nError: Typed property Fido\\PHPXray\\Segment::$endTime must not be accessed before initialization\n\n\/home\/ranpafin\/php-xray\/src\/Segment.php:156\n\/home\/ranpafin\/php-xray\/src\/RemoteSegment.php:21\n\/home\/ranpafin\/php-xray\/src\/SqlSegment.php:69\n\/home\/ranpafin\/php-xray\/tests\/SqlSegmentTest.php:21\n\nERRORS!\nTests: 1, Assertions: 0, Errors: 1."},{"mutator":{"mutatorName":"Coalesce","originalSourceCode":"<?php\n\nnamespace Fido\\PHPXray;\n\nuse JsonSerializable;\nuse Fido\\PHPXray\\Submission\\SegmentSubmitter;\nclass Segment implements JsonSerializable\n{\n    protected string $id;\n    protected ?string $parentId = null;\n    protected string $traceId;\n    protected ?string $name = null;\n    protected float $startTime;\n    protected float $endTime;\n    \/** @var Segment[] *\/\n    protected array $subsegments = [];\n    protected bool $error = false;\n    protected bool $fault = false;\n    protected bool $sampled = false;\n    protected bool $independent = false;\n    \/** @var array<string, mixed> *\/\n    private array $annotations;\n    \/** @var array<string, mixed> *\/\n    private array $metadata;\n    private int $lastOpenSegment = 0;\n    \/**\n     * @throws \\Exception if an appropriate source of randomness cannot be found.\n     *\/\n    public function __construct()\n    {\n        $this->id = bin2hex(random_bytes(8));\n    }\n    public function setTraceHeader(string $traceHeader = null) : self\n    {\n        if (is_null($traceHeader)) {\n            return $this;\n        }\n        $parts = explode(';', $traceHeader);\n        $variables = array_map(function ($str) : array {\n            return explode('=', $str);\n        }, $parts);\n        $variables = array_column($variables, 1, 0);\n        if (isset($variables['Root'])) {\n            $this->setTraceId($variables['Root']);\n        }\n        if (isset($variables['Sampled'])) {\n            $this->setSampled((bool) $variables['Sampled'] ?? false);\n        }\n        if (isset($variables['Parent'])) {\n            $this->setParentId($variables['Parent'] ?? null);\n        }\n        return $this;\n    }\n    public function begin() : self\n    {\n        $this->startTime = microtime(true);\n        return $this;\n    }\n    public function end() : self\n    {\n        $this->endTime = microtime(true);\n        return $this;\n    }\n    public function setName(string $name) : self\n    {\n        $this->name = $name;\n        return $this;\n    }\n    public function setError(bool $error) : self\n    {\n        $this->error = $error;\n        return $this;\n    }\n    public function setFault(bool $fault) : self\n    {\n        $this->fault = $fault;\n        return $this;\n    }\n    public function addSubsegment(Segment $subsegment) : self\n    {\n        if (!$this->isOpen()) {\n            return $this;\n        }\n        $this->subsegments[] = $subsegment;\n        $subsegment->setSampled($this->isSampled());\n        return $this;\n    }\n    public function submit(SegmentSubmitter $submitter) : void\n    {\n        if (!$this->isSampled()) {\n            return;\n        }\n        $submitter->submitSegment($this);\n    }\n    public function isSampled() : bool\n    {\n        return $this->sampled;\n    }\n    public function setSampled(bool $sampled) : self\n    {\n        $this->sampled = $sampled;\n        return $this;\n    }\n    public function getId() : string\n    {\n        return $this->id;\n    }\n    public function setParentId(?string $parentId) : self\n    {\n        $this->parentId = $parentId;\n        return $this;\n    }\n    public function setTraceId(string $traceId) : self\n    {\n        $this->traceId = $traceId;\n        return $this;\n    }\n    public function getTraceId() : string\n    {\n        return $this->traceId;\n    }\n    public function isOpen() : bool\n    {\n        return isset($this->startTime) && !isset($this->endTime);\n    }\n    public function setIndependent(bool $independent) : self\n    {\n        $this->independent = $independent;\n        return $this;\n    }\n    public function addAnnotation(string $key, string $value) : self\n    {\n        $this->annotations[$key] = $value;\n        return $this;\n    }\n    public function addMetadata(string $key, mixed $value) : self\n    {\n        $this->metadata[$key] = $value;\n        return $this;\n    }\n    public function getCurrentSegment() : self\n    {\n        for ($max = count($this->subsegments); $this->lastOpenSegment < $max; $this->lastOpenSegment++) {\n            if ($this->subsegments[$this->lastOpenSegment]->isOpen()) {\n                return $this->subsegments[$this->lastOpenSegment]->getCurrentSegment();\n            }\n        }\n        return $this;\n    }\n    \/**\n     * @inheritDoc\n     * @return array<string, mixed>\n     *\/\n    public function jsonSerialize() : array\n    {\n        return array_filter(['id' => $this->id, 'parent_id' => $this->parentId, 'trace_id' => $this->traceId ?? null, 'name' => $this->name, 'start_time' => $this->startTime ?? null, 'end_time' => $this->endTime ?? null, 'subsegments' => $this->subsegments ?? null ?: null, 'type' => $this->independent ? 'subsegment' : null, 'fault' => $this->fault ?? null, 'error' => $this->error ?? null, 'annotations' => $this->annotations ?? null ?: null, 'metadata' => $this->metadata ?? null ?: null]);\n    }\n}","mutatedSourceCode":"<?php\n\nnamespace Fido\\PHPXray;\n\nuse JsonSerializable;\nuse Fido\\PHPXray\\Submission\\SegmentSubmitter;\nclass Segment implements JsonSerializable\n{\n    protected string $id;\n    protected ?string $parentId = null;\n    protected string $traceId;\n    protected ?string $name = null;\n    protected float $startTime;\n    protected float $endTime;\n    \/** @var Segment[] *\/\n    protected array $subsegments = [];\n    protected bool $error = false;\n    protected bool $fault = false;\n    protected bool $sampled = false;\n    protected bool $independent = false;\n    \/** @var array<string, mixed> *\/\n    private array $annotations;\n    \/** @var array<string, mixed> *\/\n    private array $metadata;\n    private int $lastOpenSegment = 0;\n    \/**\n     * @throws \\Exception if an appropriate source of randomness cannot be found.\n     *\/\n    public function __construct()\n    {\n        $this->id = bin2hex(random_bytes(8));\n    }\n    public function setTraceHeader(string $traceHeader = null) : self\n    {\n        if (is_null($traceHeader)) {\n            return $this;\n        }\n        $parts = explode(';', $traceHeader);\n        $variables = array_map(function ($str) : array {\n            return explode('=', $str);\n        }, $parts);\n        $variables = array_column($variables, 1, 0);\n        if (isset($variables['Root'])) {\n            $this->setTraceId($variables['Root']);\n        }\n        if (isset($variables['Sampled'])) {\n            $this->setSampled((bool) $variables['Sampled'] ?? false);\n        }\n        if (isset($variables['Parent'])) {\n            $this->setParentId($variables['Parent'] ?? null);\n        }\n        return $this;\n    }\n    public function begin() : self\n    {\n        $this->startTime = microtime(true);\n        return $this;\n    }\n    public function end() : self\n    {\n        $this->endTime = microtime(true);\n        return $this;\n    }\n    public function setName(string $name) : self\n    {\n        $this->name = $name;\n        return $this;\n    }\n    public function setError(bool $error) : self\n    {\n        $this->error = $error;\n        return $this;\n    }\n    public function setFault(bool $fault) : self\n    {\n        $this->fault = $fault;\n        return $this;\n    }\n    public function addSubsegment(Segment $subsegment) : self\n    {\n        if (!$this->isOpen()) {\n            return $this;\n        }\n        $this->subsegments[] = $subsegment;\n        $subsegment->setSampled($this->isSampled());\n        return $this;\n    }\n    public function submit(SegmentSubmitter $submitter) : void\n    {\n        if (!$this->isSampled()) {\n            return;\n        }\n        $submitter->submitSegment($this);\n    }\n    public function isSampled() : bool\n    {\n        return $this->sampled;\n    }\n    public function setSampled(bool $sampled) : self\n    {\n        $this->sampled = $sampled;\n        return $this;\n    }\n    public function getId() : string\n    {\n        return $this->id;\n    }\n    public function setParentId(?string $parentId) : self\n    {\n        $this->parentId = $parentId;\n        return $this;\n    }\n    public function setTraceId(string $traceId) : self\n    {\n        $this->traceId = $traceId;\n        return $this;\n    }\n    public function getTraceId() : string\n    {\n        return $this->traceId;\n    }\n    public function isOpen() : bool\n    {\n        return isset($this->startTime) && !isset($this->endTime);\n    }\n    public function setIndependent(bool $independent) : self\n    {\n        $this->independent = $independent;\n        return $this;\n    }\n    public function addAnnotation(string $key, string $value) : self\n    {\n        $this->annotations[$key] = $value;\n        return $this;\n    }\n    public function addMetadata(string $key, mixed $value) : self\n    {\n        $this->metadata[$key] = $value;\n        return $this;\n    }\n    public function getCurrentSegment() : self\n    {\n        for ($max = count($this->subsegments); $this->lastOpenSegment < $max; $this->lastOpenSegment++) {\n            if ($this->subsegments[$this->lastOpenSegment]->isOpen()) {\n                return $this->subsegments[$this->lastOpenSegment]->getCurrentSegment();\n            }\n        }\n        return $this;\n    }\n    \/**\n     * @inheritDoc\n     * @return array<string, mixed>\n     *\/\n    public function jsonSerialize() : array\n    {\n        return array_filter(['id' => $this->id, 'parent_id' => $this->parentId, 'trace_id' => $this->traceId ?? null, 'name' => $this->name, 'start_time' => $this->startTime ?? null, 'end_time' => $this->endTime ?? null, 'subsegments' => null ?? $this->subsegments ?: null, 'type' => $this->independent ? 'subsegment' : null, 'fault' => $this->fault ?? null, 'error' => $this->error ?? null, 'annotations' => $this->annotations ?? null ?: null, 'metadata' => $this->metadata ?? null ?: null]);\n    }\n}","originalFilePath":"\/home\/ranpafin\/php-xray\/src\/Segment.php","originalStartLine":205},"diff":"--- Original\n+++ New\n@@ @@\n      *\/\n     public function jsonSerialize() : array\n     {\n-        return array_filter(['id' => $this->id, 'parent_id' => $this->parentId, 'trace_id' => $this->traceId ?? null, 'name' => $this->name, 'start_time' => $this->startTime ?? null, 'end_time' => $this->endTime ?? null, 'subsegments' => $this->subsegments ?? null ?: null, 'type' => $this->independent ? 'subsegment' : null, 'fault' => $this->fault ?? null, 'error' => $this->error ?? null, 'annotations' => $this->annotations ?? null ?: null, 'metadata' => $this->metadata ?? null ?: null]);\n+        return array_filter(['id' => $this->id, 'parent_id' => $this->parentId, 'trace_id' => $this->traceId ?? null, 'name' => $this->name, 'start_time' => $this->startTime ?? null, 'end_time' => $this->endTime ?? null, 'subsegments' => null ?? $this->subsegments ?: null, 'type' => $this->independent ? 'subsegment' : null, 'fault' => $this->fault ?? null, 'error' => $this->error ?? null, 'annotations' => $this->annotations ?? null ?: null, 'metadata' => $this->metadata ?? null ?: null]);\n     }\n }","processOutput":"PHPUnit 9.5.10 by Sebastian Bergmann and contributors.\n\nRuntime:       PHP 8.0.13\nConfiguration: \/tmp\/tmp-folder\/infection\/phpunitConfiguration.9cd021e5b4eac65e81600c9fcacbc27e.infection.xml\n\nE\n\nTime: 00:00.004, Memory: 8.00 MB\n\nThere was 1 error:\n\n1) Fido\\PHPXray\\DaemonSegmentSubmitterTest::testSubmitsToDaemon\nsocket_bind(): Unable to bind address [98]: Address already in use\n\n\/home\/ranpafin\/php-xray\/tests\/DaemonSegmentSubmitterTest.php:18\n\nERRORS!\nTests: 1, Assertions: 0, Errors: 1."},{"mutator":{"mutatorName":"Ternary","originalSourceCode":"<?php\n\nnamespace Fido\\PHPXray;\n\nuse JsonSerializable;\nuse Fido\\PHPXray\\Submission\\SegmentSubmitter;\nclass Segment implements JsonSerializable\n{\n    protected string $id;\n    protected ?string $parentId = null;\n    protected string $traceId;\n    protected ?string $name = null;\n    protected float $startTime;\n    protected float $endTime;\n    \/** @var Segment[] *\/\n    protected array $subsegments = [];\n    protected bool $error = false;\n    protected bool $fault = false;\n    protected bool $sampled = false;\n    protected bool $independent = false;\n    \/** @var array<string, mixed> *\/\n    private array $annotations;\n    \/** @var array<string, mixed> *\/\n    private array $metadata;\n    private int $lastOpenSegment = 0;\n    \/**\n     * @throws \\Exception if an appropriate source of randomness cannot be found.\n     *\/\n    public function __construct()\n    {\n        $this->id = bin2hex(random_bytes(8));\n    }\n    public function setTraceHeader(string $traceHeader = null) : self\n    {\n        if (is_null($traceHeader)) {\n            return $this;\n        }\n        $parts = explode(';', $traceHeader);\n        $variables = array_map(function ($str) : array {\n            return explode('=', $str);\n        }, $parts);\n        $variables = array_column($variables, 1, 0);\n        if (isset($variables['Root'])) {\n            $this->setTraceId($variables['Root']);\n        }\n        if (isset($variables['Sampled'])) {\n            $this->setSampled((bool) $variables['Sampled'] ?? false);\n        }\n        if (isset($variables['Parent'])) {\n            $this->setParentId($variables['Parent'] ?? null);\n        }\n        return $this;\n    }\n    public function begin() : self\n    {\n        $this->startTime = microtime(true);\n        return $this;\n    }\n    public function end() : self\n    {\n        $this->endTime = microtime(true);\n        return $this;\n    }\n    public function setName(string $name) : self\n    {\n        $this->name = $name;\n        return $this;\n    }\n    public function setError(bool $error) : self\n    {\n        $this->error = $error;\n        return $this;\n    }\n    public function setFault(bool $fault) : self\n    {\n        $this->fault = $fault;\n        return $this;\n    }\n    public function addSubsegment(Segment $subsegment) : self\n    {\n        if (!$this->isOpen()) {\n            return $this;\n        }\n        $this->subsegments[] = $subsegment;\n        $subsegment->setSampled($this->isSampled());\n        return $this;\n    }\n    public function submit(SegmentSubmitter $submitter) : void\n    {\n        if (!$this->isSampled()) {\n            return;\n        }\n        $submitter->submitSegment($this);\n    }\n    public function isSampled() : bool\n    {\n        return $this->sampled;\n    }\n    public function setSampled(bool $sampled) : self\n    {\n        $this->sampled = $sampled;\n        return $this;\n    }\n    public function getId() : string\n    {\n        return $this->id;\n    }\n    public function setParentId(?string $parentId) : self\n    {\n        $this->parentId = $parentId;\n        return $this;\n    }\n    public function setTraceId(string $traceId) : self\n    {\n        $this->traceId = $traceId;\n        return $this;\n    }\n    public function getTraceId() : string\n    {\n        return $this->traceId;\n    }\n    public function isOpen() : bool\n    {\n        return isset($this->startTime) && !isset($this->endTime);\n    }\n    public function setIndependent(bool $independent) : self\n    {\n        $this->independent = $independent;\n        return $this;\n    }\n    public function addAnnotation(string $key, string $value) : self\n    {\n        $this->annotations[$key] = $value;\n        return $this;\n    }\n    public function addMetadata(string $key, mixed $value) : self\n    {\n        $this->metadata[$key] = $value;\n        return $this;\n    }\n    public function getCurrentSegment() : self\n    {\n        for ($max = count($this->subsegments); $this->lastOpenSegment < $max; $this->lastOpenSegment++) {\n            if ($this->subsegments[$this->lastOpenSegment]->isOpen()) {\n                return $this->subsegments[$this->lastOpenSegment]->getCurrentSegment();\n            }\n        }\n        return $this;\n    }\n    \/**\n     * @inheritDoc\n     * @return array<string, mixed>\n     *\/\n    public function jsonSerialize() : array\n    {\n        return array_filter(['id' => $this->id, 'parent_id' => $this->parentId, 'trace_id' => $this->traceId ?? null, 'name' => $this->name, 'start_time' => $this->startTime ?? null, 'end_time' => $this->endTime ?? null, 'subsegments' => $this->subsegments ?? null ?: null, 'type' => $this->independent ? 'subsegment' : null, 'fault' => $this->fault ?? null, 'error' => $this->error ?? null, 'annotations' => $this->annotations ?? null ?: null, 'metadata' => $this->metadata ?? null ?: null]);\n    }\n}","mutatedSourceCode":"<?php\n\nnamespace Fido\\PHPXray;\n\nuse JsonSerializable;\nuse Fido\\PHPXray\\Submission\\SegmentSubmitter;\nclass Segment implements JsonSerializable\n{\n    protected string $id;\n    protected ?string $parentId = null;\n    protected string $traceId;\n    protected ?string $name = null;\n    protected float $startTime;\n    protected float $endTime;\n    \/** @var Segment[] *\/\n    protected array $subsegments = [];\n    protected bool $error = false;\n    protected bool $fault = false;\n    protected bool $sampled = false;\n    protected bool $independent = false;\n    \/** @var array<string, mixed> *\/\n    private array $annotations;\n    \/** @var array<string, mixed> *\/\n    private array $metadata;\n    private int $lastOpenSegment = 0;\n    \/**\n     * @throws \\Exception if an appropriate source of randomness cannot be found.\n     *\/\n    public function __construct()\n    {\n        $this->id = bin2hex(random_bytes(8));\n    }\n    public function setTraceHeader(string $traceHeader = null) : self\n    {\n        if (is_null($traceHeader)) {\n            return $this;\n        }\n        $parts = explode(';', $traceHeader);\n        $variables = array_map(function ($str) : array {\n            return explode('=', $str);\n        }, $parts);\n        $variables = array_column($variables, 1, 0);\n        if (isset($variables['Root'])) {\n            $this->setTraceId($variables['Root']);\n        }\n        if (isset($variables['Sampled'])) {\n            $this->setSampled((bool) $variables['Sampled'] ?? false);\n        }\n        if (isset($variables['Parent'])) {\n            $this->setParentId($variables['Parent'] ?? null);\n        }\n        return $this;\n    }\n    public function begin() : self\n    {\n        $this->startTime = microtime(true);\n        return $this;\n    }\n    public function end() : self\n    {\n        $this->endTime = microtime(true);\n        return $this;\n    }\n    public function setName(string $name) : self\n    {\n        $this->name = $name;\n        return $this;\n    }\n    public function setError(bool $error) : self\n    {\n        $this->error = $error;\n        return $this;\n    }\n    public function setFault(bool $fault) : self\n    {\n        $this->fault = $fault;\n        return $this;\n    }\n    public function addSubsegment(Segment $subsegment) : self\n    {\n        if (!$this->isOpen()) {\n            return $this;\n        }\n        $this->subsegments[] = $subsegment;\n        $subsegment->setSampled($this->isSampled());\n        return $this;\n    }\n    public function submit(SegmentSubmitter $submitter) : void\n    {\n        if (!$this->isSampled()) {\n            return;\n        }\n        $submitter->submitSegment($this);\n    }\n    public function isSampled() : bool\n    {\n        return $this->sampled;\n    }\n    public function setSampled(bool $sampled) : self\n    {\n        $this->sampled = $sampled;\n        return $this;\n    }\n    public function getId() : string\n    {\n        return $this->id;\n    }\n    public function setParentId(?string $parentId) : self\n    {\n        $this->parentId = $parentId;\n        return $this;\n    }\n    public function setTraceId(string $traceId) : self\n    {\n        $this->traceId = $traceId;\n        return $this;\n    }\n    public function getTraceId() : string\n    {\n        return $this->traceId;\n    }\n    public function isOpen() : bool\n    {\n        return isset($this->startTime) && !isset($this->endTime);\n    }\n    public function setIndependent(bool $independent) : self\n    {\n        $this->independent = $independent;\n        return $this;\n    }\n    public function addAnnotation(string $key, string $value) : self\n    {\n        $this->annotations[$key] = $value;\n        return $this;\n    }\n    public function addMetadata(string $key, mixed $value) : self\n    {\n        $this->metadata[$key] = $value;\n        return $this;\n    }\n    public function getCurrentSegment() : self\n    {\n        for ($max = count($this->subsegments); $this->lastOpenSegment < $max; $this->lastOpenSegment++) {\n            if ($this->subsegments[$this->lastOpenSegment]->isOpen()) {\n                return $this->subsegments[$this->lastOpenSegment]->getCurrentSegment();\n            }\n        }\n        return $this;\n    }\n    \/**\n     * @inheritDoc\n     * @return array<string, mixed>\n     *\/\n    public function jsonSerialize() : array\n    {\n        return array_filter(['id' => $this->id, 'parent_id' => $this->parentId, 'trace_id' => $this->traceId ?? null, 'name' => $this->name, 'start_time' => $this->startTime ?? null, 'end_time' => $this->endTime ?? null, 'subsegments' => $this->subsegments ?? null ? null : $this->subsegments ?? null, 'type' => $this->independent ? 'subsegment' : null, 'fault' => $this->fault ?? null, 'error' => $this->error ?? null, 'annotations' => $this->annotations ?? null ?: null, 'metadata' => $this->metadata ?? null ?: null]);\n    }\n}","originalFilePath":"\/home\/ranpafin\/php-xray\/src\/Segment.php","originalStartLine":205},"diff":"--- Original\n+++ New\n@@ @@\n      *\/\n     public function jsonSerialize() : array\n     {\n-        return array_filter(['id' => $this->id, 'parent_id' => $this->parentId, 'trace_id' => $this->traceId ?? null, 'name' => $this->name, 'start_time' => $this->startTime ?? null, 'end_time' => $this->endTime ?? null, 'subsegments' => $this->subsegments ?? null ?: null, 'type' => $this->independent ? 'subsegment' : null, 'fault' => $this->fault ?? null, 'error' => $this->error ?? null, 'annotations' => $this->annotations ?? null ?: null, 'metadata' => $this->metadata ?? null ?: null]);\n+        return array_filter(['id' => $this->id, 'parent_id' => $this->parentId, 'trace_id' => $this->traceId ?? null, 'name' => $this->name, 'start_time' => $this->startTime ?? null, 'end_time' => $this->endTime ?? null, 'subsegments' => $this->subsegments ?? null ? null : $this->subsegments ?? null, 'type' => $this->independent ? 'subsegment' : null, 'fault' => $this->fault ?? null, 'error' => $this->error ?? null, 'annotations' => $this->annotations ?? null ?: null, 'metadata' => $this->metadata ?? null ?: null]);\n     }\n }","processOutput":"PHPUnit 9.5.10 by Sebastian Bergmann and contributors.\n\nRuntime:       PHP 8.0.13\nConfiguration: \/tmp\/tmp-folder\/infection\/phpunitConfiguration.25700d41f1789d3384c705e8bd5c3b7d.infection.xml\n\nE\n\nTime: 00:00.004, Memory: 8.00 MB\n\nThere was 1 error:\n\n1) Fido\\PHPXray\\DaemonSegmentSubmitterTest::testSubmitsToDaemon\nsocket_bind(): Unable to bind address [98]: Address already in use\n\n\/home\/ranpafin\/php-xray\/tests\/DaemonSegmentSubmitterTest.php:18\n\nERRORS!\nTests: 1, Assertions: 0, Errors: 1."},{"mutator":{"mutatorName":"Ternary","originalSourceCode":"<?php\n\nnamespace Fido\\PHPXray;\n\nuse JsonSerializable;\nuse Fido\\PHPXray\\Submission\\SegmentSubmitter;\nclass Segment implements JsonSerializable\n{\n    protected string $id;\n    protected ?string $parentId = null;\n    protected string $traceId;\n    protected ?string $name = null;\n    protected float $startTime;\n    protected float $endTime;\n    \/** @var Segment[] *\/\n    protected array $subsegments = [];\n    protected bool $error = false;\n    protected bool $fault = false;\n    protected bool $sampled = false;\n    protected bool $independent = false;\n    \/** @var array<string, mixed> *\/\n    private array $annotations;\n    \/** @var array<string, mixed> *\/\n    private array $metadata;\n    private int $lastOpenSegment = 0;\n    \/**\n     * @throws \\Exception if an appropriate source of randomness cannot be found.\n     *\/\n    public function __construct()\n    {\n        $this->id = bin2hex(random_bytes(8));\n    }\n    public function setTraceHeader(string $traceHeader = null) : self\n    {\n        if (is_null($traceHeader)) {\n            return $this;\n        }\n        $parts = explode(';', $traceHeader);\n        $variables = array_map(function ($str) : array {\n            return explode('=', $str);\n        }, $parts);\n        $variables = array_column($variables, 1, 0);\n        if (isset($variables['Root'])) {\n            $this->setTraceId($variables['Root']);\n        }\n        if (isset($variables['Sampled'])) {\n            $this->setSampled((bool) $variables['Sampled'] ?? false);\n        }\n        if (isset($variables['Parent'])) {\n            $this->setParentId($variables['Parent'] ?? null);\n        }\n        return $this;\n    }\n    public function begin() : self\n    {\n        $this->startTime = microtime(true);\n        return $this;\n    }\n    public function end() : self\n    {\n        $this->endTime = microtime(true);\n        return $this;\n    }\n    public function setName(string $name) : self\n    {\n        $this->name = $name;\n        return $this;\n    }\n    public function setError(bool $error) : self\n    {\n        $this->error = $error;\n        return $this;\n    }\n    public function setFault(bool $fault) : self\n    {\n        $this->fault = $fault;\n        return $this;\n    }\n    public function addSubsegment(Segment $subsegment) : self\n    {\n        if (!$this->isOpen()) {\n            return $this;\n        }\n        $this->subsegments[] = $subsegment;\n        $subsegment->setSampled($this->isSampled());\n        return $this;\n    }\n    public function submit(SegmentSubmitter $submitter) : void\n    {\n        if (!$this->isSampled()) {\n            return;\n        }\n        $submitter->submitSegment($this);\n    }\n    public function isSampled() : bool\n    {\n        return $this->sampled;\n    }\n    public function setSampled(bool $sampled) : self\n    {\n        $this->sampled = $sampled;\n        return $this;\n    }\n    public function getId() : string\n    {\n        return $this->id;\n    }\n    public function setParentId(?string $parentId) : self\n    {\n        $this->parentId = $parentId;\n        return $this;\n    }\n    public function setTraceId(string $traceId) : self\n    {\n        $this->traceId = $traceId;\n        return $this;\n    }\n    public function getTraceId() : string\n    {\n        return $this->traceId;\n    }\n    public function isOpen() : bool\n    {\n        return isset($this->startTime) && !isset($this->endTime);\n    }\n    public function setIndependent(bool $independent) : self\n    {\n        $this->independent = $independent;\n        return $this;\n    }\n    public function addAnnotation(string $key, string $value) : self\n    {\n        $this->annotations[$key] = $value;\n        return $this;\n    }\n    public function addMetadata(string $key, mixed $value) : self\n    {\n        $this->metadata[$key] = $value;\n        return $this;\n    }\n    public function getCurrentSegment() : self\n    {\n        for ($max = count($this->subsegments); $this->lastOpenSegment < $max; $this->lastOpenSegment++) {\n            if ($this->subsegments[$this->lastOpenSegment]->isOpen()) {\n                return $this->subsegments[$this->lastOpenSegment]->getCurrentSegment();\n            }\n        }\n        return $this;\n    }\n    \/**\n     * @inheritDoc\n     * @return array<string, mixed>\n     *\/\n    public function jsonSerialize() : array\n    {\n        return array_filter(['id' => $this->id, 'parent_id' => $this->parentId, 'trace_id' => $this->traceId ?? null, 'name' => $this->name, 'start_time' => $this->startTime ?? null, 'end_time' => $this->endTime ?? null, 'subsegments' => $this->subsegments ?? null ?: null, 'type' => $this->independent ? 'subsegment' : null, 'fault' => $this->fault ?? null, 'error' => $this->error ?? null, 'annotations' => $this->annotations ?? null ?: null, 'metadata' => $this->metadata ?? null ?: null]);\n    }\n}","mutatedSourceCode":"<?php\n\nnamespace Fido\\PHPXray;\n\nuse JsonSerializable;\nuse Fido\\PHPXray\\Submission\\SegmentSubmitter;\nclass Segment implements JsonSerializable\n{\n    protected string $id;\n    protected ?string $parentId = null;\n    protected string $traceId;\n    protected ?string $name = null;\n    protected float $startTime;\n    protected float $endTime;\n    \/** @var Segment[] *\/\n    protected array $subsegments = [];\n    protected bool $error = false;\n    protected bool $fault = false;\n    protected bool $sampled = false;\n    protected bool $independent = false;\n    \/** @var array<string, mixed> *\/\n    private array $annotations;\n    \/** @var array<string, mixed> *\/\n    private array $metadata;\n    private int $lastOpenSegment = 0;\n    \/**\n     * @throws \\Exception if an appropriate source of randomness cannot be found.\n     *\/\n    public function __construct()\n    {\n        $this->id = bin2hex(random_bytes(8));\n    }\n    public function setTraceHeader(string $traceHeader = null) : self\n    {\n        if (is_null($traceHeader)) {\n            return $this;\n        }\n        $parts = explode(';', $traceHeader);\n        $variables = array_map(function ($str) : array {\n            return explode('=', $str);\n        }, $parts);\n        $variables = array_column($variables, 1, 0);\n        if (isset($variables['Root'])) {\n            $this->setTraceId($variables['Root']);\n        }\n        if (isset($variables['Sampled'])) {\n            $this->setSampled((bool) $variables['Sampled'] ?? false);\n        }\n        if (isset($variables['Parent'])) {\n            $this->setParentId($variables['Parent'] ?? null);\n        }\n        return $this;\n    }\n    public function begin() : self\n    {\n        $this->startTime = microtime(true);\n        return $this;\n    }\n    public function end() : self\n    {\n        $this->endTime = microtime(true);\n        return $this;\n    }\n    public function setName(string $name) : self\n    {\n        $this->name = $name;\n        return $this;\n    }\n    public function setError(bool $error) : self\n    {\n        $this->error = $error;\n        return $this;\n    }\n    public function setFault(bool $fault) : self\n    {\n        $this->fault = $fault;\n        return $this;\n    }\n    public function addSubsegment(Segment $subsegment) : self\n    {\n        if (!$this->isOpen()) {\n            return $this;\n        }\n        $this->subsegments[] = $subsegment;\n        $subsegment->setSampled($this->isSampled());\n        return $this;\n    }\n    public function submit(SegmentSubmitter $submitter) : void\n    {\n        if (!$this->isSampled()) {\n            return;\n        }\n        $submitter->submitSegment($this);\n    }\n    public function isSampled() : bool\n    {\n        return $this->sampled;\n    }\n    public function setSampled(bool $sampled) : self\n    {\n        $this->sampled = $sampled;\n        return $this;\n    }\n    public function getId() : string\n    {\n        return $this->id;\n    }\n    public function setParentId(?string $parentId) : self\n    {\n        $this->parentId = $parentId;\n        return $this;\n    }\n    public function setTraceId(string $traceId) : self\n    {\n        $this->traceId = $traceId;\n        return $this;\n    }\n    public function getTraceId() : string\n    {\n        return $this->traceId;\n    }\n    public function isOpen() : bool\n    {\n        return isset($this->startTime) && !isset($this->endTime);\n    }\n    public function setIndependent(bool $independent) : self\n    {\n        $this->independent = $independent;\n        return $this;\n    }\n    public function addAnnotation(string $key, string $value) : self\n    {\n        $this->annotations[$key] = $value;\n        return $this;\n    }\n    public function addMetadata(string $key, mixed $value) : self\n    {\n        $this->metadata[$key] = $value;\n        return $this;\n    }\n    public function getCurrentSegment() : self\n    {\n        for ($max = count($this->subsegments); $this->lastOpenSegment < $max; $this->lastOpenSegment++) {\n            if ($this->subsegments[$this->lastOpenSegment]->isOpen()) {\n                return $this->subsegments[$this->lastOpenSegment]->getCurrentSegment();\n            }\n        }\n        return $this;\n    }\n    \/**\n     * @inheritDoc\n     * @return array<string, mixed>\n     *\/\n    public function jsonSerialize() : array\n    {\n        return array_filter(['id' => $this->id, 'parent_id' => $this->parentId, 'trace_id' => $this->traceId ?? null, 'name' => $this->name, 'start_time' => $this->startTime ?? null, 'end_time' => $this->endTime ?? null, 'subsegments' => $this->subsegments ?? null ?: null, 'type' => $this->independent ? null : 'subsegment', 'fault' => $this->fault ?? null, 'error' => $this->error ?? null, 'annotations' => $this->annotations ?? null ?: null, 'metadata' => $this->metadata ?? null ?: null]);\n    }\n}","originalFilePath":"\/home\/ranpafin\/php-xray\/src\/Segment.php","originalStartLine":206},"diff":"--- Original\n+++ New\n@@ @@\n      *\/\n     public function jsonSerialize() : array\n     {\n-        return array_filter(['id' => $this->id, 'parent_id' => $this->parentId, 'trace_id' => $this->traceId ?? null, 'name' => $this->name, 'start_time' => $this->startTime ?? null, 'end_time' => $this->endTime ?? null, 'subsegments' => $this->subsegments ?? null ?: null, 'type' => $this->independent ? 'subsegment' : null, 'fault' => $this->fault ?? null, 'error' => $this->error ?? null, 'annotations' => $this->annotations ?? null ?: null, 'metadata' => $this->metadata ?? null ?: null]);\n+        return array_filter(['id' => $this->id, 'parent_id' => $this->parentId, 'trace_id' => $this->traceId ?? null, 'name' => $this->name, 'start_time' => $this->startTime ?? null, 'end_time' => $this->endTime ?? null, 'subsegments' => $this->subsegments ?? null ?: null, 'type' => $this->independent ? null : 'subsegment', 'fault' => $this->fault ?? null, 'error' => $this->error ?? null, 'annotations' => $this->annotations ?? null ?: null, 'metadata' => $this->metadata ?? null ?: null]);\n     }\n }","processOutput":"PHPUnit 9.5.10 by Sebastian Bergmann and contributors.\n\nRuntime:       PHP 8.0.13\nConfiguration: \/tmp\/tmp-folder\/infection\/phpunitConfiguration.3b106ba8a467129749dfc3e432608294.infection.xml\n\nE\n\nTime: 00:00.002, Memory: 8.00 MB\n\nThere was 1 error:\n\n1) Fido\\PHPXray\\DaemonSegmentSubmitterTest::testSubmitsToDaemon\nsocket_bind(): Unable to bind address [98]: Address already in use\n\n\/home\/ranpafin\/php-xray\/tests\/DaemonSegmentSubmitterTest.php:18\n\nERRORS!\nTests: 1, Assertions: 0, Errors: 1."},{"mutator":{"mutatorName":"Coalesce","originalSourceCode":"<?php\n\nnamespace Fido\\PHPXray;\n\nuse JsonSerializable;\nuse Fido\\PHPXray\\Submission\\SegmentSubmitter;\nclass Segment implements JsonSerializable\n{\n    protected string $id;\n    protected ?string $parentId = null;\n    protected string $traceId;\n    protected ?string $name = null;\n    protected float $startTime;\n    protected float $endTime;\n    \/** @var Segment[] *\/\n    protected array $subsegments = [];\n    protected bool $error = false;\n    protected bool $fault = false;\n    protected bool $sampled = false;\n    protected bool $independent = false;\n    \/** @var array<string, mixed> *\/\n    private array $annotations;\n    \/** @var array<string, mixed> *\/\n    private array $metadata;\n    private int $lastOpenSegment = 0;\n    \/**\n     * @throws \\Exception if an appropriate source of randomness cannot be found.\n     *\/\n    public function __construct()\n    {\n        $this->id = bin2hex(random_bytes(8));\n    }\n    public function setTraceHeader(string $traceHeader = null) : self\n    {\n        if (is_null($traceHeader)) {\n            return $this;\n        }\n        $parts = explode(';', $traceHeader);\n        $variables = array_map(function ($str) : array {\n            return explode('=', $str);\n        }, $parts);\n        $variables = array_column($variables, 1, 0);\n        if (isset($variables['Root'])) {\n            $this->setTraceId($variables['Root']);\n        }\n        if (isset($variables['Sampled'])) {\n            $this->setSampled((bool) $variables['Sampled'] ?? false);\n        }\n        if (isset($variables['Parent'])) {\n            $this->setParentId($variables['Parent'] ?? null);\n        }\n        return $this;\n    }\n    public function begin() : self\n    {\n        $this->startTime = microtime(true);\n        return $this;\n    }\n    public function end() : self\n    {\n        $this->endTime = microtime(true);\n        return $this;\n    }\n    public function setName(string $name) : self\n    {\n        $this->name = $name;\n        return $this;\n    }\n    public function setError(bool $error) : self\n    {\n        $this->error = $error;\n        return $this;\n    }\n    public function setFault(bool $fault) : self\n    {\n        $this->fault = $fault;\n        return $this;\n    }\n    public function addSubsegment(Segment $subsegment) : self\n    {\n        if (!$this->isOpen()) {\n            return $this;\n        }\n        $this->subsegments[] = $subsegment;\n        $subsegment->setSampled($this->isSampled());\n        return $this;\n    }\n    public function submit(SegmentSubmitter $submitter) : void\n    {\n        if (!$this->isSampled()) {\n            return;\n        }\n        $submitter->submitSegment($this);\n    }\n    public function isSampled() : bool\n    {\n        return $this->sampled;\n    }\n    public function setSampled(bool $sampled) : self\n    {\n        $this->sampled = $sampled;\n        return $this;\n    }\n    public function getId() : string\n    {\n        return $this->id;\n    }\n    public function setParentId(?string $parentId) : self\n    {\n        $this->parentId = $parentId;\n        return $this;\n    }\n    public function setTraceId(string $traceId) : self\n    {\n        $this->traceId = $traceId;\n        return $this;\n    }\n    public function getTraceId() : string\n    {\n        return $this->traceId;\n    }\n    public function isOpen() : bool\n    {\n        return isset($this->startTime) && !isset($this->endTime);\n    }\n    public function setIndependent(bool $independent) : self\n    {\n        $this->independent = $independent;\n        return $this;\n    }\n    public function addAnnotation(string $key, string $value) : self\n    {\n        $this->annotations[$key] = $value;\n        return $this;\n    }\n    public function addMetadata(string $key, mixed $value) : self\n    {\n        $this->metadata[$key] = $value;\n        return $this;\n    }\n    public function getCurrentSegment() : self\n    {\n        for ($max = count($this->subsegments); $this->lastOpenSegment < $max; $this->lastOpenSegment++) {\n            if ($this->subsegments[$this->lastOpenSegment]->isOpen()) {\n                return $this->subsegments[$this->lastOpenSegment]->getCurrentSegment();\n            }\n        }\n        return $this;\n    }\n    \/**\n     * @inheritDoc\n     * @return array<string, mixed>\n     *\/\n    public function jsonSerialize() : array\n    {\n        return array_filter(['id' => $this->id, 'parent_id' => $this->parentId, 'trace_id' => $this->traceId ?? null, 'name' => $this->name, 'start_time' => $this->startTime ?? null, 'end_time' => $this->endTime ?? null, 'subsegments' => $this->subsegments ?? null ?: null, 'type' => $this->independent ? 'subsegment' : null, 'fault' => $this->fault ?? null, 'error' => $this->error ?? null, 'annotations' => $this->annotations ?? null ?: null, 'metadata' => $this->metadata ?? null ?: null]);\n    }\n}","mutatedSourceCode":"<?php\n\nnamespace Fido\\PHPXray;\n\nuse JsonSerializable;\nuse Fido\\PHPXray\\Submission\\SegmentSubmitter;\nclass Segment implements JsonSerializable\n{\n    protected string $id;\n    protected ?string $parentId = null;\n    protected string $traceId;\n    protected ?string $name = null;\n    protected float $startTime;\n    protected float $endTime;\n    \/** @var Segment[] *\/\n    protected array $subsegments = [];\n    protected bool $error = false;\n    protected bool $fault = false;\n    protected bool $sampled = false;\n    protected bool $independent = false;\n    \/** @var array<string, mixed> *\/\n    private array $annotations;\n    \/** @var array<string, mixed> *\/\n    private array $metadata;\n    private int $lastOpenSegment = 0;\n    \/**\n     * @throws \\Exception if an appropriate source of randomness cannot be found.\n     *\/\n    public function __construct()\n    {\n        $this->id = bin2hex(random_bytes(8));\n    }\n    public function setTraceHeader(string $traceHeader = null) : self\n    {\n        if (is_null($traceHeader)) {\n            return $this;\n        }\n        $parts = explode(';', $traceHeader);\n        $variables = array_map(function ($str) : array {\n            return explode('=', $str);\n        }, $parts);\n        $variables = array_column($variables, 1, 0);\n        if (isset($variables['Root'])) {\n            $this->setTraceId($variables['Root']);\n        }\n        if (isset($variables['Sampled'])) {\n            $this->setSampled((bool) $variables['Sampled'] ?? false);\n        }\n        if (isset($variables['Parent'])) {\n            $this->setParentId($variables['Parent'] ?? null);\n        }\n        return $this;\n    }\n    public function begin() : self\n    {\n        $this->startTime = microtime(true);\n        return $this;\n    }\n    public function end() : self\n    {\n        $this->endTime = microtime(true);\n        return $this;\n    }\n    public function setName(string $name) : self\n    {\n        $this->name = $name;\n        return $this;\n    }\n    public function setError(bool $error) : self\n    {\n        $this->error = $error;\n        return $this;\n    }\n    public function setFault(bool $fault) : self\n    {\n        $this->fault = $fault;\n        return $this;\n    }\n    public function addSubsegment(Segment $subsegment) : self\n    {\n        if (!$this->isOpen()) {\n            return $this;\n        }\n        $this->subsegments[] = $subsegment;\n        $subsegment->setSampled($this->isSampled());\n        return $this;\n    }\n    public function submit(SegmentSubmitter $submitter) : void\n    {\n        if (!$this->isSampled()) {\n            return;\n        }\n        $submitter->submitSegment($this);\n    }\n    public function isSampled() : bool\n    {\n        return $this->sampled;\n    }\n    public function setSampled(bool $sampled) : self\n    {\n        $this->sampled = $sampled;\n        return $this;\n    }\n    public function getId() : string\n    {\n        return $this->id;\n    }\n    public function setParentId(?string $parentId) : self\n    {\n        $this->parentId = $parentId;\n        return $this;\n    }\n    public function setTraceId(string $traceId) : self\n    {\n        $this->traceId = $traceId;\n        return $this;\n    }\n    public function getTraceId() : string\n    {\n        return $this->traceId;\n    }\n    public function isOpen() : bool\n    {\n        return isset($this->startTime) && !isset($this->endTime);\n    }\n    public function setIndependent(bool $independent) : self\n    {\n        $this->independent = $independent;\n        return $this;\n    }\n    public function addAnnotation(string $key, string $value) : self\n    {\n        $this->annotations[$key] = $value;\n        return $this;\n    }\n    public function addMetadata(string $key, mixed $value) : self\n    {\n        $this->metadata[$key] = $value;\n        return $this;\n    }\n    public function getCurrentSegment() : self\n    {\n        for ($max = count($this->subsegments); $this->lastOpenSegment < $max; $this->lastOpenSegment++) {\n            if ($this->subsegments[$this->lastOpenSegment]->isOpen()) {\n                return $this->subsegments[$this->lastOpenSegment]->getCurrentSegment();\n            }\n        }\n        return $this;\n    }\n    \/**\n     * @inheritDoc\n     * @return array<string, mixed>\n     *\/\n    public function jsonSerialize() : array\n    {\n        return array_filter(['id' => $this->id, 'parent_id' => $this->parentId, 'trace_id' => $this->traceId ?? null, 'name' => $this->name, 'start_time' => $this->startTime ?? null, 'end_time' => $this->endTime ?? null, 'subsegments' => $this->subsegments ?? null ?: null, 'type' => $this->independent ? 'subsegment' : null, 'fault' => null ?? $this->fault, 'error' => $this->error ?? null, 'annotations' => $this->annotations ?? null ?: null, 'metadata' => $this->metadata ?? null ?: null]);\n    }\n}","originalFilePath":"\/home\/ranpafin\/php-xray\/src\/Segment.php","originalStartLine":207},"diff":"--- Original\n+++ New\n@@ @@\n      *\/\n     public function jsonSerialize() : array\n     {\n-        return array_filter(['id' => $this->id, 'parent_id' => $this->parentId, 'trace_id' => $this->traceId ?? null, 'name' => $this->name, 'start_time' => $this->startTime ?? null, 'end_time' => $this->endTime ?? null, 'subsegments' => $this->subsegments ?? null ?: null, 'type' => $this->independent ? 'subsegment' : null, 'fault' => $this->fault ?? null, 'error' => $this->error ?? null, 'annotations' => $this->annotations ?? null ?: null, 'metadata' => $this->metadata ?? null ?: null]);\n+        return array_filter(['id' => $this->id, 'parent_id' => $this->parentId, 'trace_id' => $this->traceId ?? null, 'name' => $this->name, 'start_time' => $this->startTime ?? null, 'end_time' => $this->endTime ?? null, 'subsegments' => $this->subsegments ?? null ?: null, 'type' => $this->independent ? 'subsegment' : null, 'fault' => null ?? $this->fault, 'error' => $this->error ?? null, 'annotations' => $this->annotations ?? null ?: null, 'metadata' => $this->metadata ?? null ?: null]);\n     }\n }","processOutput":"PHPUnit 9.5.10 by Sebastian Bergmann and contributors.\n\nRuntime:       PHP 8.0.13\nConfiguration: \/tmp\/tmp-folder\/infection\/phpunitConfiguration.81bfe2a707c5ccebd9860146c4bb5e13.infection.xml\n\nE\n\nTime: 00:00.004, Memory: 8.00 MB\n\nThere was 1 error:\n\n1) Fido\\PHPXray\\DaemonSegmentSubmitterTest::testSubmitsToDaemon\nsocket_bind(): Unable to bind address [98]: Address already in use\n\n\/home\/ranpafin\/php-xray\/tests\/DaemonSegmentSubmitterTest.php:18\n\nERRORS!\nTests: 1, Assertions: 0, Errors: 1."},{"mutator":{"mutatorName":"Coalesce","originalSourceCode":"<?php\n\nnamespace Fido\\PHPXray;\n\nuse JsonSerializable;\nuse Fido\\PHPXray\\Submission\\SegmentSubmitter;\nclass Segment implements JsonSerializable\n{\n    protected string $id;\n    protected ?string $parentId = null;\n    protected string $traceId;\n    protected ?string $name = null;\n    protected float $startTime;\n    protected float $endTime;\n    \/** @var Segment[] *\/\n    protected array $subsegments = [];\n    protected bool $error = false;\n    protected bool $fault = false;\n    protected bool $sampled = false;\n    protected bool $independent = false;\n    \/** @var array<string, mixed> *\/\n    private array $annotations;\n    \/** @var array<string, mixed> *\/\n    private array $metadata;\n    private int $lastOpenSegment = 0;\n    \/**\n     * @throws \\Exception if an appropriate source of randomness cannot be found.\n     *\/\n    public function __construct()\n    {\n        $this->id = bin2hex(random_bytes(8));\n    }\n    public function setTraceHeader(string $traceHeader = null) : self\n    {\n        if (is_null($traceHeader)) {\n            return $this;\n        }\n        $parts = explode(';', $traceHeader);\n        $variables = array_map(function ($str) : array {\n            return explode('=', $str);\n        }, $parts);\n        $variables = array_column($variables, 1, 0);\n        if (isset($variables['Root'])) {\n            $this->setTraceId($variables['Root']);\n        }\n        if (isset($variables['Sampled'])) {\n            $this->setSampled((bool) $variables['Sampled'] ?? false);\n        }\n        if (isset($variables['Parent'])) {\n            $this->setParentId($variables['Parent'] ?? null);\n        }\n        return $this;\n    }\n    public function begin() : self\n    {\n        $this->startTime = microtime(true);\n        return $this;\n    }\n    public function end() : self\n    {\n        $this->endTime = microtime(true);\n        return $this;\n    }\n    public function setName(string $name) : self\n    {\n        $this->name = $name;\n        return $this;\n    }\n    public function setError(bool $error) : self\n    {\n        $this->error = $error;\n        return $this;\n    }\n    public function setFault(bool $fault) : self\n    {\n        $this->fault = $fault;\n        return $this;\n    }\n    public function addSubsegment(Segment $subsegment) : self\n    {\n        if (!$this->isOpen()) {\n            return $this;\n        }\n        $this->subsegments[] = $subsegment;\n        $subsegment->setSampled($this->isSampled());\n        return $this;\n    }\n    public function submit(SegmentSubmitter $submitter) : void\n    {\n        if (!$this->isSampled()) {\n            return;\n        }\n        $submitter->submitSegment($this);\n    }\n    public function isSampled() : bool\n    {\n        return $this->sampled;\n    }\n    public function setSampled(bool $sampled) : self\n    {\n        $this->sampled = $sampled;\n        return $this;\n    }\n    public function getId() : string\n    {\n        return $this->id;\n    }\n    public function setParentId(?string $parentId) : self\n    {\n        $this->parentId = $parentId;\n        return $this;\n    }\n    public function setTraceId(string $traceId) : self\n    {\n        $this->traceId = $traceId;\n        return $this;\n    }\n    public function getTraceId() : string\n    {\n        return $this->traceId;\n    }\n    public function isOpen() : bool\n    {\n        return isset($this->startTime) && !isset($this->endTime);\n    }\n    public function setIndependent(bool $independent) : self\n    {\n        $this->independent = $independent;\n        return $this;\n    }\n    public function addAnnotation(string $key, string $value) : self\n    {\n        $this->annotations[$key] = $value;\n        return $this;\n    }\n    public function addMetadata(string $key, mixed $value) : self\n    {\n        $this->metadata[$key] = $value;\n        return $this;\n    }\n    public function getCurrentSegment() : self\n    {\n        for ($max = count($this->subsegments); $this->lastOpenSegment < $max; $this->lastOpenSegment++) {\n            if ($this->subsegments[$this->lastOpenSegment]->isOpen()) {\n                return $this->subsegments[$this->lastOpenSegment]->getCurrentSegment();\n            }\n        }\n        return $this;\n    }\n    \/**\n     * @inheritDoc\n     * @return array<string, mixed>\n     *\/\n    public function jsonSerialize() : array\n    {\n        return array_filter(['id' => $this->id, 'parent_id' => $this->parentId, 'trace_id' => $this->traceId ?? null, 'name' => $this->name, 'start_time' => $this->startTime ?? null, 'end_time' => $this->endTime ?? null, 'subsegments' => $this->subsegments ?? null ?: null, 'type' => $this->independent ? 'subsegment' : null, 'fault' => $this->fault ?? null, 'error' => $this->error ?? null, 'annotations' => $this->annotations ?? null ?: null, 'metadata' => $this->metadata ?? null ?: null]);\n    }\n}","mutatedSourceCode":"<?php\n\nnamespace Fido\\PHPXray;\n\nuse JsonSerializable;\nuse Fido\\PHPXray\\Submission\\SegmentSubmitter;\nclass Segment implements JsonSerializable\n{\n    protected string $id;\n    protected ?string $parentId = null;\n    protected string $traceId;\n    protected ?string $name = null;\n    protected float $startTime;\n    protected float $endTime;\n    \/** @var Segment[] *\/\n    protected array $subsegments = [];\n    protected bool $error = false;\n    protected bool $fault = false;\n    protected bool $sampled = false;\n    protected bool $independent = false;\n    \/** @var array<string, mixed> *\/\n    private array $annotations;\n    \/** @var array<string, mixed> *\/\n    private array $metadata;\n    private int $lastOpenSegment = 0;\n    \/**\n     * @throws \\Exception if an appropriate source of randomness cannot be found.\n     *\/\n    public function __construct()\n    {\n        $this->id = bin2hex(random_bytes(8));\n    }\n    public function setTraceHeader(string $traceHeader = null) : self\n    {\n        if (is_null($traceHeader)) {\n            return $this;\n        }\n        $parts = explode(';', $traceHeader);\n        $variables = array_map(function ($str) : array {\n            return explode('=', $str);\n        }, $parts);\n        $variables = array_column($variables, 1, 0);\n        if (isset($variables['Root'])) {\n            $this->setTraceId($variables['Root']);\n        }\n        if (isset($variables['Sampled'])) {\n            $this->setSampled((bool) $variables['Sampled'] ?? false);\n        }\n        if (isset($variables['Parent'])) {\n            $this->setParentId($variables['Parent'] ?? null);\n        }\n        return $this;\n    }\n    public function begin() : self\n    {\n        $this->startTime = microtime(true);\n        return $this;\n    }\n    public function end() : self\n    {\n        $this->endTime = microtime(true);\n        return $this;\n    }\n    public function setName(string $name) : self\n    {\n        $this->name = $name;\n        return $this;\n    }\n    public function setError(bool $error) : self\n    {\n        $this->error = $error;\n        return $this;\n    }\n    public function setFault(bool $fault) : self\n    {\n        $this->fault = $fault;\n        return $this;\n    }\n    public function addSubsegment(Segment $subsegment) : self\n    {\n        if (!$this->isOpen()) {\n            return $this;\n        }\n        $this->subsegments[] = $subsegment;\n        $subsegment->setSampled($this->isSampled());\n        return $this;\n    }\n    public function submit(SegmentSubmitter $submitter) : void\n    {\n        if (!$this->isSampled()) {\n            return;\n        }\n        $submitter->submitSegment($this);\n    }\n    public function isSampled() : bool\n    {\n        return $this->sampled;\n    }\n    public function setSampled(bool $sampled) : self\n    {\n        $this->sampled = $sampled;\n        return $this;\n    }\n    public function getId() : string\n    {\n        return $this->id;\n    }\n    public function setParentId(?string $parentId) : self\n    {\n        $this->parentId = $parentId;\n        return $this;\n    }\n    public function setTraceId(string $traceId) : self\n    {\n        $this->traceId = $traceId;\n        return $this;\n    }\n    public function getTraceId() : string\n    {\n        return $this->traceId;\n    }\n    public function isOpen() : bool\n    {\n        return isset($this->startTime) && !isset($this->endTime);\n    }\n    public function setIndependent(bool $independent) : self\n    {\n        $this->independent = $independent;\n        return $this;\n    }\n    public function addAnnotation(string $key, string $value) : self\n    {\n        $this->annotations[$key] = $value;\n        return $this;\n    }\n    public function addMetadata(string $key, mixed $value) : self\n    {\n        $this->metadata[$key] = $value;\n        return $this;\n    }\n    public function getCurrentSegment() : self\n    {\n        for ($max = count($this->subsegments); $this->lastOpenSegment < $max; $this->lastOpenSegment++) {\n            if ($this->subsegments[$this->lastOpenSegment]->isOpen()) {\n                return $this->subsegments[$this->lastOpenSegment]->getCurrentSegment();\n            }\n        }\n        return $this;\n    }\n    \/**\n     * @inheritDoc\n     * @return array<string, mixed>\n     *\/\n    public function jsonSerialize() : array\n    {\n        return array_filter(['id' => $this->id, 'parent_id' => $this->parentId, 'trace_id' => $this->traceId ?? null, 'name' => $this->name, 'start_time' => $this->startTime ?? null, 'end_time' => $this->endTime ?? null, 'subsegments' => $this->subsegments ?? null ?: null, 'type' => $this->independent ? 'subsegment' : null, 'fault' => $this->fault ?? null, 'error' => null ?? $this->error, 'annotations' => $this->annotations ?? null ?: null, 'metadata' => $this->metadata ?? null ?: null]);\n    }\n}","originalFilePath":"\/home\/ranpafin\/php-xray\/src\/Segment.php","originalStartLine":208},"diff":"--- Original\n+++ New\n@@ @@\n      *\/\n     public function jsonSerialize() : array\n     {\n-        return array_filter(['id' => $this->id, 'parent_id' => $this->parentId, 'trace_id' => $this->traceId ?? null, 'name' => $this->name, 'start_time' => $this->startTime ?? null, 'end_time' => $this->endTime ?? null, 'subsegments' => $this->subsegments ?? null ?: null, 'type' => $this->independent ? 'subsegment' : null, 'fault' => $this->fault ?? null, 'error' => $this->error ?? null, 'annotations' => $this->annotations ?? null ?: null, 'metadata' => $this->metadata ?? null ?: null]);\n+        return array_filter(['id' => $this->id, 'parent_id' => $this->parentId, 'trace_id' => $this->traceId ?? null, 'name' => $this->name, 'start_time' => $this->startTime ?? null, 'end_time' => $this->endTime ?? null, 'subsegments' => $this->subsegments ?? null ?: null, 'type' => $this->independent ? 'subsegment' : null, 'fault' => $this->fault ?? null, 'error' => null ?? $this->error, 'annotations' => $this->annotations ?? null ?: null, 'metadata' => $this->metadata ?? null ?: null]);\n     }\n }","processOutput":"PHPUnit 9.5.10 by Sebastian Bergmann and contributors.\n\nRuntime:       PHP 8.0.13\nConfiguration: \/tmp\/tmp-folder\/infection\/phpunitConfiguration.6c8f1deb92a5c4643b16f50b21c7d7c9.infection.xml\n\nE\n\nTime: 00:00.003, Memory: 8.00 MB\n\nThere was 1 error:\n\n1) Fido\\PHPXray\\DaemonSegmentSubmitterTest::testSubmitsToDaemon\nsocket_bind(): Unable to bind address [98]: Address already in use\n\n\/home\/ranpafin\/php-xray\/tests\/DaemonSegmentSubmitterTest.php:18\n\nERRORS!\nTests: 1, Assertions: 0, Errors: 1."},{"mutator":{"mutatorName":"Coalesce","originalSourceCode":"<?php\n\nnamespace Fido\\PHPXray;\n\nuse JsonSerializable;\nuse Fido\\PHPXray\\Submission\\SegmentSubmitter;\nclass Segment implements JsonSerializable\n{\n    protected string $id;\n    protected ?string $parentId = null;\n    protected string $traceId;\n    protected ?string $name = null;\n    protected float $startTime;\n    protected float $endTime;\n    \/** @var Segment[] *\/\n    protected array $subsegments = [];\n    protected bool $error = false;\n    protected bool $fault = false;\n    protected bool $sampled = false;\n    protected bool $independent = false;\n    \/** @var array<string, mixed> *\/\n    private array $annotations;\n    \/** @var array<string, mixed> *\/\n    private array $metadata;\n    private int $lastOpenSegment = 0;\n    \/**\n     * @throws \\Exception if an appropriate source of randomness cannot be found.\n     *\/\n    public function __construct()\n    {\n        $this->id = bin2hex(random_bytes(8));\n    }\n    public function setTraceHeader(string $traceHeader = null) : self\n    {\n        if (is_null($traceHeader)) {\n            return $this;\n        }\n        $parts = explode(';', $traceHeader);\n        $variables = array_map(function ($str) : array {\n            return explode('=', $str);\n        }, $parts);\n        $variables = array_column($variables, 1, 0);\n        if (isset($variables['Root'])) {\n            $this->setTraceId($variables['Root']);\n        }\n        if (isset($variables['Sampled'])) {\n            $this->setSampled((bool) $variables['Sampled'] ?? false);\n        }\n        if (isset($variables['Parent'])) {\n            $this->setParentId($variables['Parent'] ?? null);\n        }\n        return $this;\n    }\n    public function begin() : self\n    {\n        $this->startTime = microtime(true);\n        return $this;\n    }\n    public function end() : self\n    {\n        $this->endTime = microtime(true);\n        return $this;\n    }\n    public function setName(string $name) : self\n    {\n        $this->name = $name;\n        return $this;\n    }\n    public function setError(bool $error) : self\n    {\n        $this->error = $error;\n        return $this;\n    }\n    public function setFault(bool $fault) : self\n    {\n        $this->fault = $fault;\n        return $this;\n    }\n    public function addSubsegment(Segment $subsegment) : self\n    {\n        if (!$this->isOpen()) {\n            return $this;\n        }\n        $this->subsegments[] = $subsegment;\n        $subsegment->setSampled($this->isSampled());\n        return $this;\n    }\n    public function submit(SegmentSubmitter $submitter) : void\n    {\n        if (!$this->isSampled()) {\n            return;\n        }\n        $submitter->submitSegment($this);\n    }\n    public function isSampled() : bool\n    {\n        return $this->sampled;\n    }\n    public function setSampled(bool $sampled) : self\n    {\n        $this->sampled = $sampled;\n        return $this;\n    }\n    public function getId() : string\n    {\n        return $this->id;\n    }\n    public function setParentId(?string $parentId) : self\n    {\n        $this->parentId = $parentId;\n        return $this;\n    }\n    public function setTraceId(string $traceId) : self\n    {\n        $this->traceId = $traceId;\n        return $this;\n    }\n    public function getTraceId() : string\n    {\n        return $this->traceId;\n    }\n    public function isOpen() : bool\n    {\n        return isset($this->startTime) && !isset($this->endTime);\n    }\n    public function setIndependent(bool $independent) : self\n    {\n        $this->independent = $independent;\n        return $this;\n    }\n    public function addAnnotation(string $key, string $value) : self\n    {\n        $this->annotations[$key] = $value;\n        return $this;\n    }\n    public function addMetadata(string $key, mixed $value) : self\n    {\n        $this->metadata[$key] = $value;\n        return $this;\n    }\n    public function getCurrentSegment() : self\n    {\n        for ($max = count($this->subsegments); $this->lastOpenSegment < $max; $this->lastOpenSegment++) {\n            if ($this->subsegments[$this->lastOpenSegment]->isOpen()) {\n                return $this->subsegments[$this->lastOpenSegment]->getCurrentSegment();\n            }\n        }\n        return $this;\n    }\n    \/**\n     * @inheritDoc\n     * @return array<string, mixed>\n     *\/\n    public function jsonSerialize() : array\n    {\n        return array_filter(['id' => $this->id, 'parent_id' => $this->parentId, 'trace_id' => $this->traceId ?? null, 'name' => $this->name, 'start_time' => $this->startTime ?? null, 'end_time' => $this->endTime ?? null, 'subsegments' => $this->subsegments ?? null ?: null, 'type' => $this->independent ? 'subsegment' : null, 'fault' => $this->fault ?? null, 'error' => $this->error ?? null, 'annotations' => $this->annotations ?? null ?: null, 'metadata' => $this->metadata ?? null ?: null]);\n    }\n}","mutatedSourceCode":"<?php\n\nnamespace Fido\\PHPXray;\n\nuse JsonSerializable;\nuse Fido\\PHPXray\\Submission\\SegmentSubmitter;\nclass Segment implements JsonSerializable\n{\n    protected string $id;\n    protected ?string $parentId = null;\n    protected string $traceId;\n    protected ?string $name = null;\n    protected float $startTime;\n    protected float $endTime;\n    \/** @var Segment[] *\/\n    protected array $subsegments = [];\n    protected bool $error = false;\n    protected bool $fault = false;\n    protected bool $sampled = false;\n    protected bool $independent = false;\n    \/** @var array<string, mixed> *\/\n    private array $annotations;\n    \/** @var array<string, mixed> *\/\n    private array $metadata;\n    private int $lastOpenSegment = 0;\n    \/**\n     * @throws \\Exception if an appropriate source of randomness cannot be found.\n     *\/\n    public function __construct()\n    {\n        $this->id = bin2hex(random_bytes(8));\n    }\n    public function setTraceHeader(string $traceHeader = null) : self\n    {\n        if (is_null($traceHeader)) {\n            return $this;\n        }\n        $parts = explode(';', $traceHeader);\n        $variables = array_map(function ($str) : array {\n            return explode('=', $str);\n        }, $parts);\n        $variables = array_column($variables, 1, 0);\n        if (isset($variables['Root'])) {\n            $this->setTraceId($variables['Root']);\n        }\n        if (isset($variables['Sampled'])) {\n            $this->setSampled((bool) $variables['Sampled'] ?? false);\n        }\n        if (isset($variables['Parent'])) {\n            $this->setParentId($variables['Parent'] ?? null);\n        }\n        return $this;\n    }\n    public function begin() : self\n    {\n        $this->startTime = microtime(true);\n        return $this;\n    }\n    public function end() : self\n    {\n        $this->endTime = microtime(true);\n        return $this;\n    }\n    public function setName(string $name) : self\n    {\n        $this->name = $name;\n        return $this;\n    }\n    public function setError(bool $error) : self\n    {\n        $this->error = $error;\n        return $this;\n    }\n    public function setFault(bool $fault) : self\n    {\n        $this->fault = $fault;\n        return $this;\n    }\n    public function addSubsegment(Segment $subsegment) : self\n    {\n        if (!$this->isOpen()) {\n            return $this;\n        }\n        $this->subsegments[] = $subsegment;\n        $subsegment->setSampled($this->isSampled());\n        return $this;\n    }\n    public function submit(SegmentSubmitter $submitter) : void\n    {\n        if (!$this->isSampled()) {\n            return;\n        }\n        $submitter->submitSegment($this);\n    }\n    public function isSampled() : bool\n    {\n        return $this->sampled;\n    }\n    public function setSampled(bool $sampled) : self\n    {\n        $this->sampled = $sampled;\n        return $this;\n    }\n    public function getId() : string\n    {\n        return $this->id;\n    }\n    public function setParentId(?string $parentId) : self\n    {\n        $this->parentId = $parentId;\n        return $this;\n    }\n    public function setTraceId(string $traceId) : self\n    {\n        $this->traceId = $traceId;\n        return $this;\n    }\n    public function getTraceId() : string\n    {\n        return $this->traceId;\n    }\n    public function isOpen() : bool\n    {\n        return isset($this->startTime) && !isset($this->endTime);\n    }\n    public function setIndependent(bool $independent) : self\n    {\n        $this->independent = $independent;\n        return $this;\n    }\n    public function addAnnotation(string $key, string $value) : self\n    {\n        $this->annotations[$key] = $value;\n        return $this;\n    }\n    public function addMetadata(string $key, mixed $value) : self\n    {\n        $this->metadata[$key] = $value;\n        return $this;\n    }\n    public function getCurrentSegment() : self\n    {\n        for ($max = count($this->subsegments); $this->lastOpenSegment < $max; $this->lastOpenSegment++) {\n            if ($this->subsegments[$this->lastOpenSegment]->isOpen()) {\n                return $this->subsegments[$this->lastOpenSegment]->getCurrentSegment();\n            }\n        }\n        return $this;\n    }\n    \/**\n     * @inheritDoc\n     * @return array<string, mixed>\n     *\/\n    public function jsonSerialize() : array\n    {\n        return array_filter(['id' => $this->id, 'parent_id' => $this->parentId, 'trace_id' => $this->traceId ?? null, 'name' => $this->name, 'start_time' => $this->startTime ?? null, 'end_time' => $this->endTime ?? null, 'subsegments' => $this->subsegments ?? null ?: null, 'type' => $this->independent ? 'subsegment' : null, 'fault' => $this->fault ?? null, 'error' => $this->error ?? null, 'annotations' => null ?? $this->annotations ?: null, 'metadata' => $this->metadata ?? null ?: null]);\n    }\n}","originalFilePath":"\/home\/ranpafin\/php-xray\/src\/Segment.php","originalStartLine":209},"diff":"--- Original\n+++ New\n@@ @@\n      *\/\n     public function jsonSerialize() : array\n     {\n-        return array_filter(['id' => $this->id, 'parent_id' => $this->parentId, 'trace_id' => $this->traceId ?? null, 'name' => $this->name, 'start_time' => $this->startTime ?? null, 'end_time' => $this->endTime ?? null, 'subsegments' => $this->subsegments ?? null ?: null, 'type' => $this->independent ? 'subsegment' : null, 'fault' => $this->fault ?? null, 'error' => $this->error ?? null, 'annotations' => $this->annotations ?? null ?: null, 'metadata' => $this->metadata ?? null ?: null]);\n+        return array_filter(['id' => $this->id, 'parent_id' => $this->parentId, 'trace_id' => $this->traceId ?? null, 'name' => $this->name, 'start_time' => $this->startTime ?? null, 'end_time' => $this->endTime ?? null, 'subsegments' => $this->subsegments ?? null ?: null, 'type' => $this->independent ? 'subsegment' : null, 'fault' => $this->fault ?? null, 'error' => $this->error ?? null, 'annotations' => null ?? $this->annotations ?: null, 'metadata' => $this->metadata ?? null ?: null]);\n     }\n }","processOutput":"PHPUnit 9.5.10 by Sebastian Bergmann and contributors.\n\nRuntime:       PHP 8.0.13\nConfiguration: \/tmp\/tmp-folder\/infection\/phpunitConfiguration.bb7542e0511e8601f714e3db5ba51a8c.infection.xml\n\nE\n\nTime: 00:00.004, Memory: 8.00 MB\n\nThere was 1 error:\n\n1) Fido\\PHPXray\\SqlSegmentTest::testSerialisesCorrectly\nError: Typed property Fido\\PHPXray\\Segment::$annotations must not be accessed before initialization\n\n\/home\/ranpafin\/php-xray\/src\/Segment.php:156\n\/home\/ranpafin\/php-xray\/src\/RemoteSegment.php:21\n\/home\/ranpafin\/php-xray\/src\/SqlSegment.php:69\n\/home\/ranpafin\/php-xray\/tests\/SqlSegmentTest.php:21\n\nERRORS!\nTests: 1, Assertions: 0, Errors: 1."},{"mutator":{"mutatorName":"Ternary","originalSourceCode":"<?php\n\nnamespace Fido\\PHPXray;\n\nuse JsonSerializable;\nuse Fido\\PHPXray\\Submission\\SegmentSubmitter;\nclass Segment implements JsonSerializable\n{\n    protected string $id;\n    protected ?string $parentId = null;\n    protected string $traceId;\n    protected ?string $name = null;\n    protected float $startTime;\n    protected float $endTime;\n    \/** @var Segment[] *\/\n    protected array $subsegments = [];\n    protected bool $error = false;\n    protected bool $fault = false;\n    protected bool $sampled = false;\n    protected bool $independent = false;\n    \/** @var array<string, mixed> *\/\n    private array $annotations;\n    \/** @var array<string, mixed> *\/\n    private array $metadata;\n    private int $lastOpenSegment = 0;\n    \/**\n     * @throws \\Exception if an appropriate source of randomness cannot be found.\n     *\/\n    public function __construct()\n    {\n        $this->id = bin2hex(random_bytes(8));\n    }\n    public function setTraceHeader(string $traceHeader = null) : self\n    {\n        if (is_null($traceHeader)) {\n            return $this;\n        }\n        $parts = explode(';', $traceHeader);\n        $variables = array_map(function ($str) : array {\n            return explode('=', $str);\n        }, $parts);\n        $variables = array_column($variables, 1, 0);\n        if (isset($variables['Root'])) {\n            $this->setTraceId($variables['Root']);\n        }\n        if (isset($variables['Sampled'])) {\n            $this->setSampled((bool) $variables['Sampled'] ?? false);\n        }\n        if (isset($variables['Parent'])) {\n            $this->setParentId($variables['Parent'] ?? null);\n        }\n        return $this;\n    }\n    public function begin() : self\n    {\n        $this->startTime = microtime(true);\n        return $this;\n    }\n    public function end() : self\n    {\n        $this->endTime = microtime(true);\n        return $this;\n    }\n    public function setName(string $name) : self\n    {\n        $this->name = $name;\n        return $this;\n    }\n    public function setError(bool $error) : self\n    {\n        $this->error = $error;\n        return $this;\n    }\n    public function setFault(bool $fault) : self\n    {\n        $this->fault = $fault;\n        return $this;\n    }\n    public function addSubsegment(Segment $subsegment) : self\n    {\n        if (!$this->isOpen()) {\n            return $this;\n        }\n        $this->subsegments[] = $subsegment;\n        $subsegment->setSampled($this->isSampled());\n        return $this;\n    }\n    public function submit(SegmentSubmitter $submitter) : void\n    {\n        if (!$this->isSampled()) {\n            return;\n        }\n        $submitter->submitSegment($this);\n    }\n    public function isSampled() : bool\n    {\n        return $this->sampled;\n    }\n    public function setSampled(bool $sampled) : self\n    {\n        $this->sampled = $sampled;\n        return $this;\n    }\n    public function getId() : string\n    {\n        return $this->id;\n    }\n    public function setParentId(?string $parentId) : self\n    {\n        $this->parentId = $parentId;\n        return $this;\n    }\n    public function setTraceId(string $traceId) : self\n    {\n        $this->traceId = $traceId;\n        return $this;\n    }\n    public function getTraceId() : string\n    {\n        return $this->traceId;\n    }\n    public function isOpen() : bool\n    {\n        return isset($this->startTime) && !isset($this->endTime);\n    }\n    public function setIndependent(bool $independent) : self\n    {\n        $this->independent = $independent;\n        return $this;\n    }\n    public function addAnnotation(string $key, string $value) : self\n    {\n        $this->annotations[$key] = $value;\n        return $this;\n    }\n    public function addMetadata(string $key, mixed $value) : self\n    {\n        $this->metadata[$key] = $value;\n        return $this;\n    }\n    public function getCurrentSegment() : self\n    {\n        for ($max = count($this->subsegments); $this->lastOpenSegment < $max; $this->lastOpenSegment++) {\n            if ($this->subsegments[$this->lastOpenSegment]->isOpen()) {\n                return $this->subsegments[$this->lastOpenSegment]->getCurrentSegment();\n            }\n        }\n        return $this;\n    }\n    \/**\n     * @inheritDoc\n     * @return array<string, mixed>\n     *\/\n    public function jsonSerialize() : array\n    {\n        return array_filter(['id' => $this->id, 'parent_id' => $this->parentId, 'trace_id' => $this->traceId ?? null, 'name' => $this->name, 'start_time' => $this->startTime ?? null, 'end_time' => $this->endTime ?? null, 'subsegments' => $this->subsegments ?? null ?: null, 'type' => $this->independent ? 'subsegment' : null, 'fault' => $this->fault ?? null, 'error' => $this->error ?? null, 'annotations' => $this->annotations ?? null ?: null, 'metadata' => $this->metadata ?? null ?: null]);\n    }\n}","mutatedSourceCode":"<?php\n\nnamespace Fido\\PHPXray;\n\nuse JsonSerializable;\nuse Fido\\PHPXray\\Submission\\SegmentSubmitter;\nclass Segment implements JsonSerializable\n{\n    protected string $id;\n    protected ?string $parentId = null;\n    protected string $traceId;\n    protected ?string $name = null;\n    protected float $startTime;\n    protected float $endTime;\n    \/** @var Segment[] *\/\n    protected array $subsegments = [];\n    protected bool $error = false;\n    protected bool $fault = false;\n    protected bool $sampled = false;\n    protected bool $independent = false;\n    \/** @var array<string, mixed> *\/\n    private array $annotations;\n    \/** @var array<string, mixed> *\/\n    private array $metadata;\n    private int $lastOpenSegment = 0;\n    \/**\n     * @throws \\Exception if an appropriate source of randomness cannot be found.\n     *\/\n    public function __construct()\n    {\n        $this->id = bin2hex(random_bytes(8));\n    }\n    public function setTraceHeader(string $traceHeader = null) : self\n    {\n        if (is_null($traceHeader)) {\n            return $this;\n        }\n        $parts = explode(';', $traceHeader);\n        $variables = array_map(function ($str) : array {\n            return explode('=', $str);\n        }, $parts);\n        $variables = array_column($variables, 1, 0);\n        if (isset($variables['Root'])) {\n            $this->setTraceId($variables['Root']);\n        }\n        if (isset($variables['Sampled'])) {\n            $this->setSampled((bool) $variables['Sampled'] ?? false);\n        }\n        if (isset($variables['Parent'])) {\n            $this->setParentId($variables['Parent'] ?? null);\n        }\n        return $this;\n    }\n    public function begin() : self\n    {\n        $this->startTime = microtime(true);\n        return $this;\n    }\n    public function end() : self\n    {\n        $this->endTime = microtime(true);\n        return $this;\n    }\n    public function setName(string $name) : self\n    {\n        $this->name = $name;\n        return $this;\n    }\n    public function setError(bool $error) : self\n    {\n        $this->error = $error;\n        return $this;\n    }\n    public function setFault(bool $fault) : self\n    {\n        $this->fault = $fault;\n        return $this;\n    }\n    public function addSubsegment(Segment $subsegment) : self\n    {\n        if (!$this->isOpen()) {\n            return $this;\n        }\n        $this->subsegments[] = $subsegment;\n        $subsegment->setSampled($this->isSampled());\n        return $this;\n    }\n    public function submit(SegmentSubmitter $submitter) : void\n    {\n        if (!$this->isSampled()) {\n            return;\n        }\n        $submitter->submitSegment($this);\n    }\n    public function isSampled() : bool\n    {\n        return $this->sampled;\n    }\n    public function setSampled(bool $sampled) : self\n    {\n        $this->sampled = $sampled;\n        return $this;\n    }\n    public function getId() : string\n    {\n        return $this->id;\n    }\n    public function setParentId(?string $parentId) : self\n    {\n        $this->parentId = $parentId;\n        return $this;\n    }\n    public function setTraceId(string $traceId) : self\n    {\n        $this->traceId = $traceId;\n        return $this;\n    }\n    public function getTraceId() : string\n    {\n        return $this->traceId;\n    }\n    public function isOpen() : bool\n    {\n        return isset($this->startTime) && !isset($this->endTime);\n    }\n    public function setIndependent(bool $independent) : self\n    {\n        $this->independent = $independent;\n        return $this;\n    }\n    public function addAnnotation(string $key, string $value) : self\n    {\n        $this->annotations[$key] = $value;\n        return $this;\n    }\n    public function addMetadata(string $key, mixed $value) : self\n    {\n        $this->metadata[$key] = $value;\n        return $this;\n    }\n    public function getCurrentSegment() : self\n    {\n        for ($max = count($this->subsegments); $this->lastOpenSegment < $max; $this->lastOpenSegment++) {\n            if ($this->subsegments[$this->lastOpenSegment]->isOpen()) {\n                return $this->subsegments[$this->lastOpenSegment]->getCurrentSegment();\n            }\n        }\n        return $this;\n    }\n    \/**\n     * @inheritDoc\n     * @return array<string, mixed>\n     *\/\n    public function jsonSerialize() : array\n    {\n        return array_filter(['id' => $this->id, 'parent_id' => $this->parentId, 'trace_id' => $this->traceId ?? null, 'name' => $this->name, 'start_time' => $this->startTime ?? null, 'end_time' => $this->endTime ?? null, 'subsegments' => $this->subsegments ?? null ?: null, 'type' => $this->independent ? 'subsegment' : null, 'fault' => $this->fault ?? null, 'error' => $this->error ?? null, 'annotations' => $this->annotations ?? null ? null : $this->annotations ?? null, 'metadata' => $this->metadata ?? null ?: null]);\n    }\n}","originalFilePath":"\/home\/ranpafin\/php-xray\/src\/Segment.php","originalStartLine":209},"diff":"--- Original\n+++ New\n@@ @@\n      *\/\n     public function jsonSerialize() : array\n     {\n-        return array_filter(['id' => $this->id, 'parent_id' => $this->parentId, 'trace_id' => $this->traceId ?? null, 'name' => $this->name, 'start_time' => $this->startTime ?? null, 'end_time' => $this->endTime ?? null, 'subsegments' => $this->subsegments ?? null ?: null, 'type' => $this->independent ? 'subsegment' : null, 'fault' => $this->fault ?? null, 'error' => $this->error ?? null, 'annotations' => $this->annotations ?? null ?: null, 'metadata' => $this->metadata ?? null ?: null]);\n+        return array_filter(['id' => $this->id, 'parent_id' => $this->parentId, 'trace_id' => $this->traceId ?? null, 'name' => $this->name, 'start_time' => $this->startTime ?? null, 'end_time' => $this->endTime ?? null, 'subsegments' => $this->subsegments ?? null ?: null, 'type' => $this->independent ? 'subsegment' : null, 'fault' => $this->fault ?? null, 'error' => $this->error ?? null, 'annotations' => $this->annotations ?? null ? null : $this->annotations ?? null, 'metadata' => $this->metadata ?? null ?: null]);\n     }\n }","processOutput":"PHPUnit 9.5.10 by Sebastian Bergmann and contributors.\n\nRuntime:       PHP 8.0.13\nConfiguration: \/tmp\/tmp-folder\/infection\/phpunitConfiguration.c976643caf4f6ed88973e1cc4d9d50f8.infection.xml\n\nE\n\nTime: 00:00.004, Memory: 8.00 MB\n\nThere was 1 error:\n\n1) Fido\\PHPXray\\DaemonSegmentSubmitterTest::testSubmitsToDaemon\nsocket_bind(): Unable to bind address [98]: Address already in use\n\n\/home\/ranpafin\/php-xray\/tests\/DaemonSegmentSubmitterTest.php:18\n\nERRORS!\nTests: 1, Assertions: 0, Errors: 1."},{"mutator":{"mutatorName":"Coalesce","originalSourceCode":"<?php\n\nnamespace Fido\\PHPXray;\n\nuse JsonSerializable;\nuse Fido\\PHPXray\\Submission\\SegmentSubmitter;\nclass Segment implements JsonSerializable\n{\n    protected string $id;\n    protected ?string $parentId = null;\n    protected string $traceId;\n    protected ?string $name = null;\n    protected float $startTime;\n    protected float $endTime;\n    \/** @var Segment[] *\/\n    protected array $subsegments = [];\n    protected bool $error = false;\n    protected bool $fault = false;\n    protected bool $sampled = false;\n    protected bool $independent = false;\n    \/** @var array<string, mixed> *\/\n    private array $annotations;\n    \/** @var array<string, mixed> *\/\n    private array $metadata;\n    private int $lastOpenSegment = 0;\n    \/**\n     * @throws \\Exception if an appropriate source of randomness cannot be found.\n     *\/\n    public function __construct()\n    {\n        $this->id = bin2hex(random_bytes(8));\n    }\n    public function setTraceHeader(string $traceHeader = null) : self\n    {\n        if (is_null($traceHeader)) {\n            return $this;\n        }\n        $parts = explode(';', $traceHeader);\n        $variables = array_map(function ($str) : array {\n            return explode('=', $str);\n        }, $parts);\n        $variables = array_column($variables, 1, 0);\n        if (isset($variables['Root'])) {\n            $this->setTraceId($variables['Root']);\n        }\n        if (isset($variables['Sampled'])) {\n            $this->setSampled((bool) $variables['Sampled'] ?? false);\n        }\n        if (isset($variables['Parent'])) {\n            $this->setParentId($variables['Parent'] ?? null);\n        }\n        return $this;\n    }\n    public function begin() : self\n    {\n        $this->startTime = microtime(true);\n        return $this;\n    }\n    public function end() : self\n    {\n        $this->endTime = microtime(true);\n        return $this;\n    }\n    public function setName(string $name) : self\n    {\n        $this->name = $name;\n        return $this;\n    }\n    public function setError(bool $error) : self\n    {\n        $this->error = $error;\n        return $this;\n    }\n    public function setFault(bool $fault) : self\n    {\n        $this->fault = $fault;\n        return $this;\n    }\n    public function addSubsegment(Segment $subsegment) : self\n    {\n        if (!$this->isOpen()) {\n            return $this;\n        }\n        $this->subsegments[] = $subsegment;\n        $subsegment->setSampled($this->isSampled());\n        return $this;\n    }\n    public function submit(SegmentSubmitter $submitter) : void\n    {\n        if (!$this->isSampled()) {\n            return;\n        }\n        $submitter->submitSegment($this);\n    }\n    public function isSampled() : bool\n    {\n        return $this->sampled;\n    }\n    public function setSampled(bool $sampled) : self\n    {\n        $this->sampled = $sampled;\n        return $this;\n    }\n    public function getId() : string\n    {\n        return $this->id;\n    }\n    public function setParentId(?string $parentId) : self\n    {\n        $this->parentId = $parentId;\n        return $this;\n    }\n    public function setTraceId(string $traceId) : self\n    {\n        $this->traceId = $traceId;\n        return $this;\n    }\n    public function getTraceId() : string\n    {\n        return $this->traceId;\n    }\n    public function isOpen() : bool\n    {\n        return isset($this->startTime) && !isset($this->endTime);\n    }\n    public function setIndependent(bool $independent) : self\n    {\n        $this->independent = $independent;\n        return $this;\n    }\n    public function addAnnotation(string $key, string $value) : self\n    {\n        $this->annotations[$key] = $value;\n        return $this;\n    }\n    public function addMetadata(string $key, mixed $value) : self\n    {\n        $this->metadata[$key] = $value;\n        return $this;\n    }\n    public function getCurrentSegment() : self\n    {\n        for ($max = count($this->subsegments); $this->lastOpenSegment < $max; $this->lastOpenSegment++) {\n            if ($this->subsegments[$this->lastOpenSegment]->isOpen()) {\n                return $this->subsegments[$this->lastOpenSegment]->getCurrentSegment();\n            }\n        }\n        return $this;\n    }\n    \/**\n     * @inheritDoc\n     * @return array<string, mixed>\n     *\/\n    public function jsonSerialize() : array\n    {\n        return array_filter(['id' => $this->id, 'parent_id' => $this->parentId, 'trace_id' => $this->traceId ?? null, 'name' => $this->name, 'start_time' => $this->startTime ?? null, 'end_time' => $this->endTime ?? null, 'subsegments' => $this->subsegments ?? null ?: null, 'type' => $this->independent ? 'subsegment' : null, 'fault' => $this->fault ?? null, 'error' => $this->error ?? null, 'annotations' => $this->annotations ?? null ?: null, 'metadata' => $this->metadata ?? null ?: null]);\n    }\n}","mutatedSourceCode":"<?php\n\nnamespace Fido\\PHPXray;\n\nuse JsonSerializable;\nuse Fido\\PHPXray\\Submission\\SegmentSubmitter;\nclass Segment implements JsonSerializable\n{\n    protected string $id;\n    protected ?string $parentId = null;\n    protected string $traceId;\n    protected ?string $name = null;\n    protected float $startTime;\n    protected float $endTime;\n    \/** @var Segment[] *\/\n    protected array $subsegments = [];\n    protected bool $error = false;\n    protected bool $fault = false;\n    protected bool $sampled = false;\n    protected bool $independent = false;\n    \/** @var array<string, mixed> *\/\n    private array $annotations;\n    \/** @var array<string, mixed> *\/\n    private array $metadata;\n    private int $lastOpenSegment = 0;\n    \/**\n     * @throws \\Exception if an appropriate source of randomness cannot be found.\n     *\/\n    public function __construct()\n    {\n        $this->id = bin2hex(random_bytes(8));\n    }\n    public function setTraceHeader(string $traceHeader = null) : self\n    {\n        if (is_null($traceHeader)) {\n            return $this;\n        }\n        $parts = explode(';', $traceHeader);\n        $variables = array_map(function ($str) : array {\n            return explode('=', $str);\n        }, $parts);\n        $variables = array_column($variables, 1, 0);\n        if (isset($variables['Root'])) {\n            $this->setTraceId($variables['Root']);\n        }\n        if (isset($variables['Sampled'])) {\n            $this->setSampled((bool) $variables['Sampled'] ?? false);\n        }\n        if (isset($variables['Parent'])) {\n            $this->setParentId($variables['Parent'] ?? null);\n        }\n        return $this;\n    }\n    public function begin() : self\n    {\n        $this->startTime = microtime(true);\n        return $this;\n    }\n    public function end() : self\n    {\n        $this->endTime = microtime(true);\n        return $this;\n    }\n    public function setName(string $name) : self\n    {\n        $this->name = $name;\n        return $this;\n    }\n    public function setError(bool $error) : self\n    {\n        $this->error = $error;\n        return $this;\n    }\n    public function setFault(bool $fault) : self\n    {\n        $this->fault = $fault;\n        return $this;\n    }\n    public function addSubsegment(Segment $subsegment) : self\n    {\n        if (!$this->isOpen()) {\n            return $this;\n        }\n        $this->subsegments[] = $subsegment;\n        $subsegment->setSampled($this->isSampled());\n        return $this;\n    }\n    public function submit(SegmentSubmitter $submitter) : void\n    {\n        if (!$this->isSampled()) {\n            return;\n        }\n        $submitter->submitSegment($this);\n    }\n    public function isSampled() : bool\n    {\n        return $this->sampled;\n    }\n    public function setSampled(bool $sampled) : self\n    {\n        $this->sampled = $sampled;\n        return $this;\n    }\n    public function getId() : string\n    {\n        return $this->id;\n    }\n    public function setParentId(?string $parentId) : self\n    {\n        $this->parentId = $parentId;\n        return $this;\n    }\n    public function setTraceId(string $traceId) : self\n    {\n        $this->traceId = $traceId;\n        return $this;\n    }\n    public function getTraceId() : string\n    {\n        return $this->traceId;\n    }\n    public function isOpen() : bool\n    {\n        return isset($this->startTime) && !isset($this->endTime);\n    }\n    public function setIndependent(bool $independent) : self\n    {\n        $this->independent = $independent;\n        return $this;\n    }\n    public function addAnnotation(string $key, string $value) : self\n    {\n        $this->annotations[$key] = $value;\n        return $this;\n    }\n    public function addMetadata(string $key, mixed $value) : self\n    {\n        $this->metadata[$key] = $value;\n        return $this;\n    }\n    public function getCurrentSegment() : self\n    {\n        for ($max = count($this->subsegments); $this->lastOpenSegment < $max; $this->lastOpenSegment++) {\n            if ($this->subsegments[$this->lastOpenSegment]->isOpen()) {\n                return $this->subsegments[$this->lastOpenSegment]->getCurrentSegment();\n            }\n        }\n        return $this;\n    }\n    \/**\n     * @inheritDoc\n     * @return array<string, mixed>\n     *\/\n    public function jsonSerialize() : array\n    {\n        return array_filter(['id' => $this->id, 'parent_id' => $this->parentId, 'trace_id' => $this->traceId ?? null, 'name' => $this->name, 'start_time' => $this->startTime ?? null, 'end_time' => $this->endTime ?? null, 'subsegments' => $this->subsegments ?? null ?: null, 'type' => $this->independent ? 'subsegment' : null, 'fault' => $this->fault ?? null, 'error' => $this->error ?? null, 'annotations' => $this->annotations ?? null ?: null, 'metadata' => null ?? $this->metadata ?: null]);\n    }\n}","originalFilePath":"\/home\/ranpafin\/php-xray\/src\/Segment.php","originalStartLine":210},"diff":"--- Original\n+++ New\n@@ @@\n      *\/\n     public function jsonSerialize() : array\n     {\n-        return array_filter(['id' => $this->id, 'parent_id' => $this->parentId, 'trace_id' => $this->traceId ?? null, 'name' => $this->name, 'start_time' => $this->startTime ?? null, 'end_time' => $this->endTime ?? null, 'subsegments' => $this->subsegments ?? null ?: null, 'type' => $this->independent ? 'subsegment' : null, 'fault' => $this->fault ?? null, 'error' => $this->error ?? null, 'annotations' => $this->annotations ?? null ?: null, 'metadata' => $this->metadata ?? null ?: null]);\n+        return array_filter(['id' => $this->id, 'parent_id' => $this->parentId, 'trace_id' => $this->traceId ?? null, 'name' => $this->name, 'start_time' => $this->startTime ?? null, 'end_time' => $this->endTime ?? null, 'subsegments' => $this->subsegments ?? null ?: null, 'type' => $this->independent ? 'subsegment' : null, 'fault' => $this->fault ?? null, 'error' => $this->error ?? null, 'annotations' => $this->annotations ?? null ?: null, 'metadata' => null ?? $this->metadata ?: null]);\n     }\n }","processOutput":"PHPUnit 9.5.10 by Sebastian Bergmann and contributors.\n\nRuntime:       PHP 8.0.13\nConfiguration: \/tmp\/tmp-folder\/infection\/phpunitConfiguration.1159a2b2ee502dd38377ae3d61bc06f6.infection.xml\n\nE\n\nTime: 00:00.004, Memory: 8.00 MB\n\nThere was 1 error:\n\n1) Fido\\PHPXray\\SqlSegmentTest::testSerialisesCorrectly\nError: Typed property Fido\\PHPXray\\Segment::$metadata must not be accessed before initialization\n\n\/home\/ranpafin\/php-xray\/src\/Segment.php:156\n\/home\/ranpafin\/php-xray\/src\/RemoteSegment.php:21\n\/home\/ranpafin\/php-xray\/src\/SqlSegment.php:69\n\/home\/ranpafin\/php-xray\/tests\/SqlSegmentTest.php:21\n\nERRORS!\nTests: 1, Assertions: 0, Errors: 1."},{"mutator":{"mutatorName":"Ternary","originalSourceCode":"<?php\n\nnamespace Fido\\PHPXray;\n\nuse JsonSerializable;\nuse Fido\\PHPXray\\Submission\\SegmentSubmitter;\nclass Segment implements JsonSerializable\n{\n    protected string $id;\n    protected ?string $parentId = null;\n    protected string $traceId;\n    protected ?string $name = null;\n    protected float $startTime;\n    protected float $endTime;\n    \/** @var Segment[] *\/\n    protected array $subsegments = [];\n    protected bool $error = false;\n    protected bool $fault = false;\n    protected bool $sampled = false;\n    protected bool $independent = false;\n    \/** @var array<string, mixed> *\/\n    private array $annotations;\n    \/** @var array<string, mixed> *\/\n    private array $metadata;\n    private int $lastOpenSegment = 0;\n    \/**\n     * @throws \\Exception if an appropriate source of randomness cannot be found.\n     *\/\n    public function __construct()\n    {\n        $this->id = bin2hex(random_bytes(8));\n    }\n    public function setTraceHeader(string $traceHeader = null) : self\n    {\n        if (is_null($traceHeader)) {\n            return $this;\n        }\n        $parts = explode(';', $traceHeader);\n        $variables = array_map(function ($str) : array {\n            return explode('=', $str);\n        }, $parts);\n        $variables = array_column($variables, 1, 0);\n        if (isset($variables['Root'])) {\n            $this->setTraceId($variables['Root']);\n        }\n        if (isset($variables['Sampled'])) {\n            $this->setSampled((bool) $variables['Sampled'] ?? false);\n        }\n        if (isset($variables['Parent'])) {\n            $this->setParentId($variables['Parent'] ?? null);\n        }\n        return $this;\n    }\n    public function begin() : self\n    {\n        $this->startTime = microtime(true);\n        return $this;\n    }\n    public function end() : self\n    {\n        $this->endTime = microtime(true);\n        return $this;\n    }\n    public function setName(string $name) : self\n    {\n        $this->name = $name;\n        return $this;\n    }\n    public function setError(bool $error) : self\n    {\n        $this->error = $error;\n        return $this;\n    }\n    public function setFault(bool $fault) : self\n    {\n        $this->fault = $fault;\n        return $this;\n    }\n    public function addSubsegment(Segment $subsegment) : self\n    {\n        if (!$this->isOpen()) {\n            return $this;\n        }\n        $this->subsegments[] = $subsegment;\n        $subsegment->setSampled($this->isSampled());\n        return $this;\n    }\n    public function submit(SegmentSubmitter $submitter) : void\n    {\n        if (!$this->isSampled()) {\n            return;\n        }\n        $submitter->submitSegment($this);\n    }\n    public function isSampled() : bool\n    {\n        return $this->sampled;\n    }\n    public function setSampled(bool $sampled) : self\n    {\n        $this->sampled = $sampled;\n        return $this;\n    }\n    public function getId() : string\n    {\n        return $this->id;\n    }\n    public function setParentId(?string $parentId) : self\n    {\n        $this->parentId = $parentId;\n        return $this;\n    }\n    public function setTraceId(string $traceId) : self\n    {\n        $this->traceId = $traceId;\n        return $this;\n    }\n    public function getTraceId() : string\n    {\n        return $this->traceId;\n    }\n    public function isOpen() : bool\n    {\n        return isset($this->startTime) && !isset($this->endTime);\n    }\n    public function setIndependent(bool $independent) : self\n    {\n        $this->independent = $independent;\n        return $this;\n    }\n    public function addAnnotation(string $key, string $value) : self\n    {\n        $this->annotations[$key] = $value;\n        return $this;\n    }\n    public function addMetadata(string $key, mixed $value) : self\n    {\n        $this->metadata[$key] = $value;\n        return $this;\n    }\n    public function getCurrentSegment() : self\n    {\n        for ($max = count($this->subsegments); $this->lastOpenSegment < $max; $this->lastOpenSegment++) {\n            if ($this->subsegments[$this->lastOpenSegment]->isOpen()) {\n                return $this->subsegments[$this->lastOpenSegment]->getCurrentSegment();\n            }\n        }\n        return $this;\n    }\n    \/**\n     * @inheritDoc\n     * @return array<string, mixed>\n     *\/\n    public function jsonSerialize() : array\n    {\n        return array_filter(['id' => $this->id, 'parent_id' => $this->parentId, 'trace_id' => $this->traceId ?? null, 'name' => $this->name, 'start_time' => $this->startTime ?? null, 'end_time' => $this->endTime ?? null, 'subsegments' => $this->subsegments ?? null ?: null, 'type' => $this->independent ? 'subsegment' : null, 'fault' => $this->fault ?? null, 'error' => $this->error ?? null, 'annotations' => $this->annotations ?? null ?: null, 'metadata' => $this->metadata ?? null ?: null]);\n    }\n}","mutatedSourceCode":"<?php\n\nnamespace Fido\\PHPXray;\n\nuse JsonSerializable;\nuse Fido\\PHPXray\\Submission\\SegmentSubmitter;\nclass Segment implements JsonSerializable\n{\n    protected string $id;\n    protected ?string $parentId = null;\n    protected string $traceId;\n    protected ?string $name = null;\n    protected float $startTime;\n    protected float $endTime;\n    \/** @var Segment[] *\/\n    protected array $subsegments = [];\n    protected bool $error = false;\n    protected bool $fault = false;\n    protected bool $sampled = false;\n    protected bool $independent = false;\n    \/** @var array<string, mixed> *\/\n    private array $annotations;\n    \/** @var array<string, mixed> *\/\n    private array $metadata;\n    private int $lastOpenSegment = 0;\n    \/**\n     * @throws \\Exception if an appropriate source of randomness cannot be found.\n     *\/\n    public function __construct()\n    {\n        $this->id = bin2hex(random_bytes(8));\n    }\n    public function setTraceHeader(string $traceHeader = null) : self\n    {\n        if (is_null($traceHeader)) {\n            return $this;\n        }\n        $parts = explode(';', $traceHeader);\n        $variables = array_map(function ($str) : array {\n            return explode('=', $str);\n        }, $parts);\n        $variables = array_column($variables, 1, 0);\n        if (isset($variables['Root'])) {\n            $this->setTraceId($variables['Root']);\n        }\n        if (isset($variables['Sampled'])) {\n            $this->setSampled((bool) $variables['Sampled'] ?? false);\n        }\n        if (isset($variables['Parent'])) {\n            $this->setParentId($variables['Parent'] ?? null);\n        }\n        return $this;\n    }\n    public function begin() : self\n    {\n        $this->startTime = microtime(true);\n        return $this;\n    }\n    public function end() : self\n    {\n        $this->endTime = microtime(true);\n        return $this;\n    }\n    public function setName(string $name) : self\n    {\n        $this->name = $name;\n        return $this;\n    }\n    public function setError(bool $error) : self\n    {\n        $this->error = $error;\n        return $this;\n    }\n    public function setFault(bool $fault) : self\n    {\n        $this->fault = $fault;\n        return $this;\n    }\n    public function addSubsegment(Segment $subsegment) : self\n    {\n        if (!$this->isOpen()) {\n            return $this;\n        }\n        $this->subsegments[] = $subsegment;\n        $subsegment->setSampled($this->isSampled());\n        return $this;\n    }\n    public function submit(SegmentSubmitter $submitter) : void\n    {\n        if (!$this->isSampled()) {\n            return;\n        }\n        $submitter->submitSegment($this);\n    }\n    public function isSampled() : bool\n    {\n        return $this->sampled;\n    }\n    public function setSampled(bool $sampled) : self\n    {\n        $this->sampled = $sampled;\n        return $this;\n    }\n    public function getId() : string\n    {\n        return $this->id;\n    }\n    public function setParentId(?string $parentId) : self\n    {\n        $this->parentId = $parentId;\n        return $this;\n    }\n    public function setTraceId(string $traceId) : self\n    {\n        $this->traceId = $traceId;\n        return $this;\n    }\n    public function getTraceId() : string\n    {\n        return $this->traceId;\n    }\n    public function isOpen() : bool\n    {\n        return isset($this->startTime) && !isset($this->endTime);\n    }\n    public function setIndependent(bool $independent) : self\n    {\n        $this->independent = $independent;\n        return $this;\n    }\n    public function addAnnotation(string $key, string $value) : self\n    {\n        $this->annotations[$key] = $value;\n        return $this;\n    }\n    public function addMetadata(string $key, mixed $value) : self\n    {\n        $this->metadata[$key] = $value;\n        return $this;\n    }\n    public function getCurrentSegment() : self\n    {\n        for ($max = count($this->subsegments); $this->lastOpenSegment < $max; $this->lastOpenSegment++) {\n            if ($this->subsegments[$this->lastOpenSegment]->isOpen()) {\n                return $this->subsegments[$this->lastOpenSegment]->getCurrentSegment();\n            }\n        }\n        return $this;\n    }\n    \/**\n     * @inheritDoc\n     * @return array<string, mixed>\n     *\/\n    public function jsonSerialize() : array\n    {\n        return array_filter(['id' => $this->id, 'parent_id' => $this->parentId, 'trace_id' => $this->traceId ?? null, 'name' => $this->name, 'start_time' => $this->startTime ?? null, 'end_time' => $this->endTime ?? null, 'subsegments' => $this->subsegments ?? null ?: null, 'type' => $this->independent ? 'subsegment' : null, 'fault' => $this->fault ?? null, 'error' => $this->error ?? null, 'annotations' => $this->annotations ?? null ?: null, 'metadata' => $this->metadata ?? null ? null : $this->metadata ?? null]);\n    }\n}","originalFilePath":"\/home\/ranpafin\/php-xray\/src\/Segment.php","originalStartLine":210},"diff":"--- Original\n+++ New\n@@ @@\n      *\/\n     public function jsonSerialize() : array\n     {\n-        return array_filter(['id' => $this->id, 'parent_id' => $this->parentId, 'trace_id' => $this->traceId ?? null, 'name' => $this->name, 'start_time' => $this->startTime ?? null, 'end_time' => $this->endTime ?? null, 'subsegments' => $this->subsegments ?? null ?: null, 'type' => $this->independent ? 'subsegment' : null, 'fault' => $this->fault ?? null, 'error' => $this->error ?? null, 'annotations' => $this->annotations ?? null ?: null, 'metadata' => $this->metadata ?? null ?: null]);\n+        return array_filter(['id' => $this->id, 'parent_id' => $this->parentId, 'trace_id' => $this->traceId ?? null, 'name' => $this->name, 'start_time' => $this->startTime ?? null, 'end_time' => $this->endTime ?? null, 'subsegments' => $this->subsegments ?? null ?: null, 'type' => $this->independent ? 'subsegment' : null, 'fault' => $this->fault ?? null, 'error' => $this->error ?? null, 'annotations' => $this->annotations ?? null ?: null, 'metadata' => $this->metadata ?? null ? null : $this->metadata ?? null]);\n     }\n }","processOutput":"PHPUnit 9.5.10 by Sebastian Bergmann and contributors.\n\nRuntime:       PHP 8.0.13\nConfiguration: \/tmp\/tmp-folder\/infection\/phpunitConfiguration.f0a1242ad36bcf6d774513b62bca87c7.infection.xml\n\nE\n\nTime: 00:00.004, Memory: 8.00 MB\n\nThere was 1 error:\n\n1) Fido\\PHPXray\\DaemonSegmentSubmitterTest::testSubmitsToDaemon\nsocket_bind(): Unable to bind address [98]: Address already in use\n\n\/home\/ranpafin\/php-xray\/tests\/DaemonSegmentSubmitterTest.php:18\n\nERRORS!\nTests: 1, Assertions: 0, Errors: 1."},{"mutator":{"mutatorName":"PublicVisibility","originalSourceCode":"<?php\n\nnamespace Fido\\PHPXray;\n\nclass SqlSegment extends RemoteSegment\n{\n    protected string $url;\n    protected string $preparation;\n    protected string $databaseType;\n    protected string $databaseVersion;\n    protected string $driverVersion;\n    protected string $user;\n    protected string $query;\n    public function setUrl(string $url) : self\n    {\n        $this->url = $url;\n        return $this;\n    }\n    public function setPreparation(string $preparation) : self\n    {\n        $this->preparation = $preparation;\n        return $this;\n    }\n    public function setDatabaseType(string $databaseType) : self\n    {\n        $this->databaseType = $databaseType;\n        return $this;\n    }\n    public function setDatabaseVersion(string $databaseVersion) : self\n    {\n        $this->databaseVersion = $databaseVersion;\n        return $this;\n    }\n    public function setDriverVersion(string $driverVersion) : self\n    {\n        $this->driverVersion = $driverVersion;\n        return $this;\n    }\n    public function setUser(string $user) : self\n    {\n        $this->user = $user;\n        return $this;\n    }\n    public function setQuery(string $query) : self\n    {\n        $this->query = $query;\n        return $this;\n    }\n    \/**\n     * @inheritdoc\n     *\/\n    public function jsonSerialize() : array\n    {\n        $data = parent::jsonSerialize();\n        $data['sql'] = array_filter(['url' => $this->url ?? null, 'preparation' => $this->preparation ?? null, 'database_type' => $this->databaseType ?? null, 'database_version' => $this->databaseVersion ?? null, 'driver_version' => $this->driverVersion ?? null, 'user' => $this->user ?? null, 'sanitized_query' => $this->query ?? null]);\n        return $data;\n    }\n}","mutatedSourceCode":"<?php\n\nnamespace Fido\\PHPXray;\n\nclass SqlSegment extends RemoteSegment\n{\n    protected string $url;\n    protected string $preparation;\n    protected string $databaseType;\n    protected string $databaseVersion;\n    protected string $driverVersion;\n    protected string $user;\n    protected string $query;\n    protected function setUrl(string $url) : self\n    {\n        $this->url = $url;\n        return $this;\n    }\n    public function setPreparation(string $preparation) : self\n    {\n        $this->preparation = $preparation;\n        return $this;\n    }\n    public function setDatabaseType(string $databaseType) : self\n    {\n        $this->databaseType = $databaseType;\n        return $this;\n    }\n    public function setDatabaseVersion(string $databaseVersion) : self\n    {\n        $this->databaseVersion = $databaseVersion;\n        return $this;\n    }\n    public function setDriverVersion(string $driverVersion) : self\n    {\n        $this->driverVersion = $driverVersion;\n        return $this;\n    }\n    public function setUser(string $user) : self\n    {\n        $this->user = $user;\n        return $this;\n    }\n    public function setQuery(string $query) : self\n    {\n        $this->query = $query;\n        return $this;\n    }\n    \/**\n     * @inheritdoc\n     *\/\n    public function jsonSerialize() : array\n    {\n        $data = parent::jsonSerialize();\n        $data['sql'] = array_filter(['url' => $this->url ?? null, 'preparation' => $this->preparation ?? null, 'database_type' => $this->databaseType ?? null, 'database_version' => $this->databaseVersion ?? null, 'driver_version' => $this->driverVersion ?? null, 'user' => $this->user ?? null, 'sanitized_query' => $this->query ?? null]);\n        return $data;\n    }\n}","originalFilePath":"\/home\/ranpafin\/php-xray\/src\/SqlSegment.php","originalStartLine":15},"diff":"--- Original\n+++ New\n@@ @@\n     protected string $driverVersion;\n     protected string $user;\n     protected string $query;\n-    public function setUrl(string $url) : self\n+    protected function setUrl(string $url) : self\n     {\n         $this->url = $url;\n         return $this;","processOutput":"PHPUnit 9.5.10 by Sebastian Bergmann and contributors.\n\nRuntime:       PHP 8.0.13\nConfiguration: \/tmp\/tmp-folder\/infection\/phpunitConfiguration.235a9a54de1c1bd90fa7b9cf29f4a38d.infection.xml\n\nE                                                                   1 \/ 1 (100%)\n\nTime: 00:00.003, Memory: 8.00 MB\n\nThere was 1 error:\n\n1) Fido\\PHPXray\\SqlSegmentTest::testSerialisesCorrectly\nError: Call to protected method Fido\\PHPXray\\SqlSegment::setUrl() from scope Fido\\PHPXray\\SqlSegmentTest\n\n\/home\/ranpafin\/php-xray\/tests\/SqlSegmentTest.php:18\n\nERRORS!\nTests: 1, Assertions: 0, Errors: 1."},{"mutator":{"mutatorName":"PublicVisibility","originalSourceCode":"<?php\n\nnamespace Fido\\PHPXray;\n\nclass SqlSegment extends RemoteSegment\n{\n    protected string $url;\n    protected string $preparation;\n    protected string $databaseType;\n    protected string $databaseVersion;\n    protected string $driverVersion;\n    protected string $user;\n    protected string $query;\n    public function setUrl(string $url) : self\n    {\n        $this->url = $url;\n        return $this;\n    }\n    public function setPreparation(string $preparation) : self\n    {\n        $this->preparation = $preparation;\n        return $this;\n    }\n    public function setDatabaseType(string $databaseType) : self\n    {\n        $this->databaseType = $databaseType;\n        return $this;\n    }\n    public function setDatabaseVersion(string $databaseVersion) : self\n    {\n        $this->databaseVersion = $databaseVersion;\n        return $this;\n    }\n    public function setDriverVersion(string $driverVersion) : self\n    {\n        $this->driverVersion = $driverVersion;\n        return $this;\n    }\n    public function setUser(string $user) : self\n    {\n        $this->user = $user;\n        return $this;\n    }\n    public function setQuery(string $query) : self\n    {\n        $this->query = $query;\n        return $this;\n    }\n    \/**\n     * @inheritdoc\n     *\/\n    public function jsonSerialize() : array\n    {\n        $data = parent::jsonSerialize();\n        $data['sql'] = array_filter(['url' => $this->url ?? null, 'preparation' => $this->preparation ?? null, 'database_type' => $this->databaseType ?? null, 'database_version' => $this->databaseVersion ?? null, 'driver_version' => $this->driverVersion ?? null, 'user' => $this->user ?? null, 'sanitized_query' => $this->query ?? null]);\n        return $data;\n    }\n}","mutatedSourceCode":"<?php\n\nnamespace Fido\\PHPXray;\n\nclass SqlSegment extends RemoteSegment\n{\n    protected string $url;\n    protected string $preparation;\n    protected string $databaseType;\n    protected string $databaseVersion;\n    protected string $driverVersion;\n    protected string $user;\n    protected string $query;\n    public function setUrl(string $url) : self\n    {\n        $this->url = $url;\n        return $this;\n    }\n    protected function setPreparation(string $preparation) : self\n    {\n        $this->preparation = $preparation;\n        return $this;\n    }\n    public function setDatabaseType(string $databaseType) : self\n    {\n        $this->databaseType = $databaseType;\n        return $this;\n    }\n    public function setDatabaseVersion(string $databaseVersion) : self\n    {\n        $this->databaseVersion = $databaseVersion;\n        return $this;\n    }\n    public function setDriverVersion(string $driverVersion) : self\n    {\n        $this->driverVersion = $driverVersion;\n        return $this;\n    }\n    public function setUser(string $user) : self\n    {\n        $this->user = $user;\n        return $this;\n    }\n    public function setQuery(string $query) : self\n    {\n        $this->query = $query;\n        return $this;\n    }\n    \/**\n     * @inheritdoc\n     *\/\n    public function jsonSerialize() : array\n    {\n        $data = parent::jsonSerialize();\n        $data['sql'] = array_filter(['url' => $this->url ?? null, 'preparation' => $this->preparation ?? null, 'database_type' => $this->databaseType ?? null, 'database_version' => $this->databaseVersion ?? null, 'driver_version' => $this->driverVersion ?? null, 'user' => $this->user ?? null, 'sanitized_query' => $this->query ?? null]);\n        return $data;\n    }\n}","originalFilePath":"\/home\/ranpafin\/php-xray\/src\/SqlSegment.php","originalStartLine":22},"diff":"--- Original\n+++ New\n@@ @@\n         $this->url = $url;\n         return $this;\n     }\n-    public function setPreparation(string $preparation) : self\n+    protected function setPreparation(string $preparation) : self\n     {\n         $this->preparation = $preparation;\n         return $this;","processOutput":"PHPUnit 9.5.10 by Sebastian Bergmann and contributors.\n\nRuntime:       PHP 8.0.13\nConfiguration: \/tmp\/tmp-folder\/infection\/phpunitConfiguration.d7d6d98c5b2619e569fc35a04c651ba4.infection.xml\n\nE                                                                   1 \/ 1 (100%)\n\nTime: 00:00.004, Memory: 8.00 MB\n\nThere was 1 error:\n\n1) Fido\\PHPXray\\SqlSegmentTest::testSerialisesCorrectly\nError: Call to protected method Fido\\PHPXray\\SqlSegment::setPreparation() from scope Fido\\PHPXray\\SqlSegmentTest\n\n\/home\/ranpafin\/php-xray\/tests\/SqlSegmentTest.php:16\n\nERRORS!\nTests: 1, Assertions: 0, Errors: 1."},{"mutator":{"mutatorName":"PublicVisibility","originalSourceCode":"<?php\n\nnamespace Fido\\PHPXray;\n\nclass SqlSegment extends RemoteSegment\n{\n    protected string $url;\n    protected string $preparation;\n    protected string $databaseType;\n    protected string $databaseVersion;\n    protected string $driverVersion;\n    protected string $user;\n    protected string $query;\n    public function setUrl(string $url) : self\n    {\n        $this->url = $url;\n        return $this;\n    }\n    public function setPreparation(string $preparation) : self\n    {\n        $this->preparation = $preparation;\n        return $this;\n    }\n    public function setDatabaseType(string $databaseType) : self\n    {\n        $this->databaseType = $databaseType;\n        return $this;\n    }\n    public function setDatabaseVersion(string $databaseVersion) : self\n    {\n        $this->databaseVersion = $databaseVersion;\n        return $this;\n    }\n    public function setDriverVersion(string $driverVersion) : self\n    {\n        $this->driverVersion = $driverVersion;\n        return $this;\n    }\n    public function setUser(string $user) : self\n    {\n        $this->user = $user;\n        return $this;\n    }\n    public function setQuery(string $query) : self\n    {\n        $this->query = $query;\n        return $this;\n    }\n    \/**\n     * @inheritdoc\n     *\/\n    public function jsonSerialize() : array\n    {\n        $data = parent::jsonSerialize();\n        $data['sql'] = array_filter(['url' => $this->url ?? null, 'preparation' => $this->preparation ?? null, 'database_type' => $this->databaseType ?? null, 'database_version' => $this->databaseVersion ?? null, 'driver_version' => $this->driverVersion ?? null, 'user' => $this->user ?? null, 'sanitized_query' => $this->query ?? null]);\n        return $data;\n    }\n}","mutatedSourceCode":"<?php\n\nnamespace Fido\\PHPXray;\n\nclass SqlSegment extends RemoteSegment\n{\n    protected string $url;\n    protected string $preparation;\n    protected string $databaseType;\n    protected string $databaseVersion;\n    protected string $driverVersion;\n    protected string $user;\n    protected string $query;\n    public function setUrl(string $url) : self\n    {\n        $this->url = $url;\n        return $this;\n    }\n    public function setPreparation(string $preparation) : self\n    {\n        $this->preparation = $preparation;\n        return $this;\n    }\n    protected function setDatabaseType(string $databaseType) : self\n    {\n        $this->databaseType = $databaseType;\n        return $this;\n    }\n    public function setDatabaseVersion(string $databaseVersion) : self\n    {\n        $this->databaseVersion = $databaseVersion;\n        return $this;\n    }\n    public function setDriverVersion(string $driverVersion) : self\n    {\n        $this->driverVersion = $driverVersion;\n        return $this;\n    }\n    public function setUser(string $user) : self\n    {\n        $this->user = $user;\n        return $this;\n    }\n    public function setQuery(string $query) : self\n    {\n        $this->query = $query;\n        return $this;\n    }\n    \/**\n     * @inheritdoc\n     *\/\n    public function jsonSerialize() : array\n    {\n        $data = parent::jsonSerialize();\n        $data['sql'] = array_filter(['url' => $this->url ?? null, 'preparation' => $this->preparation ?? null, 'database_type' => $this->databaseType ?? null, 'database_version' => $this->databaseVersion ?? null, 'driver_version' => $this->driverVersion ?? null, 'user' => $this->user ?? null, 'sanitized_query' => $this->query ?? null]);\n        return $data;\n    }\n}","originalFilePath":"\/home\/ranpafin\/php-xray\/src\/SqlSegment.php","originalStartLine":29},"diff":"--- Original\n+++ New\n@@ @@\n         $this->preparation = $preparation;\n         return $this;\n     }\n-    public function setDatabaseType(string $databaseType) : self\n+    protected function setDatabaseType(string $databaseType) : self\n     {\n         $this->databaseType = $databaseType;\n         return $this;","processOutput":"PHPUnit 9.5.10 by Sebastian Bergmann and contributors.\n\nRuntime:       PHP 8.0.13\nConfiguration: \/tmp\/tmp-folder\/infection\/phpunitConfiguration.d868188c8031d00c7d0120ffeff6c60e.infection.xml\n\nE                                                                   1 \/ 1 (100%)\n\nTime: 00:00.003, Memory: 8.00 MB\n\nThere was 1 error:\n\n1) Fido\\PHPXray\\SqlSegmentTest::testSerialisesCorrectly\nError: Call to protected method Fido\\PHPXray\\SqlSegment::setDatabaseType() from scope Fido\\PHPXray\\SqlSegmentTest\n\n\/home\/ranpafin\/php-xray\/tests\/SqlSegmentTest.php:13\n\nERRORS!\nTests: 1, Assertions: 0, Errors: 1."},{"mutator":{"mutatorName":"PublicVisibility","originalSourceCode":"<?php\n\nnamespace Fido\\PHPXray;\n\nclass SqlSegment extends RemoteSegment\n{\n    protected string $url;\n    protected string $preparation;\n    protected string $databaseType;\n    protected string $databaseVersion;\n    protected string $driverVersion;\n    protected string $user;\n    protected string $query;\n    public function setUrl(string $url) : self\n    {\n        $this->url = $url;\n        return $this;\n    }\n    public function setPreparation(string $preparation) : self\n    {\n        $this->preparation = $preparation;\n        return $this;\n    }\n    public function setDatabaseType(string $databaseType) : self\n    {\n        $this->databaseType = $databaseType;\n        return $this;\n    }\n    public function setDatabaseVersion(string $databaseVersion) : self\n    {\n        $this->databaseVersion = $databaseVersion;\n        return $this;\n    }\n    public function setDriverVersion(string $driverVersion) : self\n    {\n        $this->driverVersion = $driverVersion;\n        return $this;\n    }\n    public function setUser(string $user) : self\n    {\n        $this->user = $user;\n        return $this;\n    }\n    public function setQuery(string $query) : self\n    {\n        $this->query = $query;\n        return $this;\n    }\n    \/**\n     * @inheritdoc\n     *\/\n    public function jsonSerialize() : array\n    {\n        $data = parent::jsonSerialize();\n        $data['sql'] = array_filter(['url' => $this->url ?? null, 'preparation' => $this->preparation ?? null, 'database_type' => $this->databaseType ?? null, 'database_version' => $this->databaseVersion ?? null, 'driver_version' => $this->driverVersion ?? null, 'user' => $this->user ?? null, 'sanitized_query' => $this->query ?? null]);\n        return $data;\n    }\n}","mutatedSourceCode":"<?php\n\nnamespace Fido\\PHPXray;\n\nclass SqlSegment extends RemoteSegment\n{\n    protected string $url;\n    protected string $preparation;\n    protected string $databaseType;\n    protected string $databaseVersion;\n    protected string $driverVersion;\n    protected string $user;\n    protected string $query;\n    public function setUrl(string $url) : self\n    {\n        $this->url = $url;\n        return $this;\n    }\n    public function setPreparation(string $preparation) : self\n    {\n        $this->preparation = $preparation;\n        return $this;\n    }\n    public function setDatabaseType(string $databaseType) : self\n    {\n        $this->databaseType = $databaseType;\n        return $this;\n    }\n    protected function setDatabaseVersion(string $databaseVersion) : self\n    {\n        $this->databaseVersion = $databaseVersion;\n        return $this;\n    }\n    public function setDriverVersion(string $driverVersion) : self\n    {\n        $this->driverVersion = $driverVersion;\n        return $this;\n    }\n    public function setUser(string $user) : self\n    {\n        $this->user = $user;\n        return $this;\n    }\n    public function setQuery(string $query) : self\n    {\n        $this->query = $query;\n        return $this;\n    }\n    \/**\n     * @inheritdoc\n     *\/\n    public function jsonSerialize() : array\n    {\n        $data = parent::jsonSerialize();\n        $data['sql'] = array_filter(['url' => $this->url ?? null, 'preparation' => $this->preparation ?? null, 'database_type' => $this->databaseType ?? null, 'database_version' => $this->databaseVersion ?? null, 'driver_version' => $this->driverVersion ?? null, 'user' => $this->user ?? null, 'sanitized_query' => $this->query ?? null]);\n        return $data;\n    }\n}","originalFilePath":"\/home\/ranpafin\/php-xray\/src\/SqlSegment.php","originalStartLine":36},"diff":"--- Original\n+++ New\n@@ @@\n         $this->databaseType = $databaseType;\n         return $this;\n     }\n-    public function setDatabaseVersion(string $databaseVersion) : self\n+    protected function setDatabaseVersion(string $databaseVersion) : self\n     {\n         $this->databaseVersion = $databaseVersion;\n         return $this;","processOutput":"PHPUnit 9.5.10 by Sebastian Bergmann and contributors.\n\nRuntime:       PHP 8.0.13\nConfiguration: \/tmp\/tmp-folder\/infection\/phpunitConfiguration.362c596fc60c9fe29061a6d13dcefe58.infection.xml\n\nE                                                                   1 \/ 1 (100%)\n\nTime: 00:00.004, Memory: 8.00 MB\n\nThere was 1 error:\n\n1) Fido\\PHPXray\\SqlSegmentTest::testSerialisesCorrectly\nError: Call to protected method Fido\\PHPXray\\SqlSegment::setDatabaseVersion() from scope Fido\\PHPXray\\SqlSegmentTest\n\n\/home\/ranpafin\/php-xray\/tests\/SqlSegmentTest.php:14\n\nERRORS!\nTests: 1, Assertions: 0, Errors: 1."},{"mutator":{"mutatorName":"PublicVisibility","originalSourceCode":"<?php\n\nnamespace Fido\\PHPXray;\n\nclass SqlSegment extends RemoteSegment\n{\n    protected string $url;\n    protected string $preparation;\n    protected string $databaseType;\n    protected string $databaseVersion;\n    protected string $driverVersion;\n    protected string $user;\n    protected string $query;\n    public function setUrl(string $url) : self\n    {\n        $this->url = $url;\n        return $this;\n    }\n    public function setPreparation(string $preparation) : self\n    {\n        $this->preparation = $preparation;\n        return $this;\n    }\n    public function setDatabaseType(string $databaseType) : self\n    {\n        $this->databaseType = $databaseType;\n        return $this;\n    }\n    public function setDatabaseVersion(string $databaseVersion) : self\n    {\n        $this->databaseVersion = $databaseVersion;\n        return $this;\n    }\n    public function setDriverVersion(string $driverVersion) : self\n    {\n        $this->driverVersion = $driverVersion;\n        return $this;\n    }\n    public function setUser(string $user) : self\n    {\n        $this->user = $user;\n        return $this;\n    }\n    public function setQuery(string $query) : self\n    {\n        $this->query = $query;\n        return $this;\n    }\n    \/**\n     * @inheritdoc\n     *\/\n    public function jsonSerialize() : array\n    {\n        $data = parent::jsonSerialize();\n        $data['sql'] = array_filter(['url' => $this->url ?? null, 'preparation' => $this->preparation ?? null, 'database_type' => $this->databaseType ?? null, 'database_version' => $this->databaseVersion ?? null, 'driver_version' => $this->driverVersion ?? null, 'user' => $this->user ?? null, 'sanitized_query' => $this->query ?? null]);\n        return $data;\n    }\n}","mutatedSourceCode":"<?php\n\nnamespace Fido\\PHPXray;\n\nclass SqlSegment extends RemoteSegment\n{\n    protected string $url;\n    protected string $preparation;\n    protected string $databaseType;\n    protected string $databaseVersion;\n    protected string $driverVersion;\n    protected string $user;\n    protected string $query;\n    public function setUrl(string $url) : self\n    {\n        $this->url = $url;\n        return $this;\n    }\n    public function setPreparation(string $preparation) : self\n    {\n        $this->preparation = $preparation;\n        return $this;\n    }\n    public function setDatabaseType(string $databaseType) : self\n    {\n        $this->databaseType = $databaseType;\n        return $this;\n    }\n    public function setDatabaseVersion(string $databaseVersion) : self\n    {\n        $this->databaseVersion = $databaseVersion;\n        return $this;\n    }\n    protected function setDriverVersion(string $driverVersion) : self\n    {\n        $this->driverVersion = $driverVersion;\n        return $this;\n    }\n    public function setUser(string $user) : self\n    {\n        $this->user = $user;\n        return $this;\n    }\n    public function setQuery(string $query) : self\n    {\n        $this->query = $query;\n        return $this;\n    }\n    \/**\n     * @inheritdoc\n     *\/\n    public function jsonSerialize() : array\n    {\n        $data = parent::jsonSerialize();\n        $data['sql'] = array_filter(['url' => $this->url ?? null, 'preparation' => $this->preparation ?? null, 'database_type' => $this->databaseType ?? null, 'database_version' => $this->databaseVersion ?? null, 'driver_version' => $this->driverVersion ?? null, 'user' => $this->user ?? null, 'sanitized_query' => $this->query ?? null]);\n        return $data;\n    }\n}","originalFilePath":"\/home\/ranpafin\/php-xray\/src\/SqlSegment.php","originalStartLine":43},"diff":"--- Original\n+++ New\n@@ @@\n         $this->databaseVersion = $databaseVersion;\n         return $this;\n     }\n-    public function setDriverVersion(string $driverVersion) : self\n+    protected function setDriverVersion(string $driverVersion) : self\n     {\n         $this->driverVersion = $driverVersion;\n         return $this;","processOutput":"PHPUnit 9.5.10 by Sebastian Bergmann and contributors.\n\nRuntime:       PHP 8.0.13\nConfiguration: \/tmp\/tmp-folder\/infection\/phpunitConfiguration.2978a00b18124ee60ba252889db341c1.infection.xml\n\nE                                                                   1 \/ 1 (100%)\n\nTime: 00:00.004, Memory: 8.00 MB\n\nThere was 1 error:\n\n1) Fido\\PHPXray\\SqlSegmentTest::testSerialisesCorrectly\nError: Call to protected method Fido\\PHPXray\\SqlSegment::setDriverVersion() from scope Fido\\PHPXray\\SqlSegmentTest\n\n\/home\/ranpafin\/php-xray\/tests\/SqlSegmentTest.php:15\n\nERRORS!\nTests: 1, Assertions: 0, Errors: 1."},{"mutator":{"mutatorName":"PublicVisibility","originalSourceCode":"<?php\n\nnamespace Fido\\PHPXray;\n\nclass SqlSegment extends RemoteSegment\n{\n    protected string $url;\n    protected string $preparation;\n    protected string $databaseType;\n    protected string $databaseVersion;\n    protected string $driverVersion;\n    protected string $user;\n    protected string $query;\n    public function setUrl(string $url) : self\n    {\n        $this->url = $url;\n        return $this;\n    }\n    public function setPreparation(string $preparation) : self\n    {\n        $this->preparation = $preparation;\n        return $this;\n    }\n    public function setDatabaseType(string $databaseType) : self\n    {\n        $this->databaseType = $databaseType;\n        return $this;\n    }\n    public function setDatabaseVersion(string $databaseVersion) : self\n    {\n        $this->databaseVersion = $databaseVersion;\n        return $this;\n    }\n    public function setDriverVersion(string $driverVersion) : self\n    {\n        $this->driverVersion = $driverVersion;\n        return $this;\n    }\n    public function setUser(string $user) : self\n    {\n        $this->user = $user;\n        return $this;\n    }\n    public function setQuery(string $query) : self\n    {\n        $this->query = $query;\n        return $this;\n    }\n    \/**\n     * @inheritdoc\n     *\/\n    public function jsonSerialize() : array\n    {\n        $data = parent::jsonSerialize();\n        $data['sql'] = array_filter(['url' => $this->url ?? null, 'preparation' => $this->preparation ?? null, 'database_type' => $this->databaseType ?? null, 'database_version' => $this->databaseVersion ?? null, 'driver_version' => $this->driverVersion ?? null, 'user' => $this->user ?? null, 'sanitized_query' => $this->query ?? null]);\n        return $data;\n    }\n}","mutatedSourceCode":"<?php\n\nnamespace Fido\\PHPXray;\n\nclass SqlSegment extends RemoteSegment\n{\n    protected string $url;\n    protected string $preparation;\n    protected string $databaseType;\n    protected string $databaseVersion;\n    protected string $driverVersion;\n    protected string $user;\n    protected string $query;\n    public function setUrl(string $url) : self\n    {\n        $this->url = $url;\n        return $this;\n    }\n    public function setPreparation(string $preparation) : self\n    {\n        $this->preparation = $preparation;\n        return $this;\n    }\n    public function setDatabaseType(string $databaseType) : self\n    {\n        $this->databaseType = $databaseType;\n        return $this;\n    }\n    public function setDatabaseVersion(string $databaseVersion) : self\n    {\n        $this->databaseVersion = $databaseVersion;\n        return $this;\n    }\n    public function setDriverVersion(string $driverVersion) : self\n    {\n        $this->driverVersion = $driverVersion;\n        return $this;\n    }\n    protected function setUser(string $user) : self\n    {\n        $this->user = $user;\n        return $this;\n    }\n    public function setQuery(string $query) : self\n    {\n        $this->query = $query;\n        return $this;\n    }\n    \/**\n     * @inheritdoc\n     *\/\n    public function jsonSerialize() : array\n    {\n        $data = parent::jsonSerialize();\n        $data['sql'] = array_filter(['url' => $this->url ?? null, 'preparation' => $this->preparation ?? null, 'database_type' => $this->databaseType ?? null, 'database_version' => $this->databaseVersion ?? null, 'driver_version' => $this->driverVersion ?? null, 'user' => $this->user ?? null, 'sanitized_query' => $this->query ?? null]);\n        return $data;\n    }\n}","originalFilePath":"\/home\/ranpafin\/php-xray\/src\/SqlSegment.php","originalStartLine":50},"diff":"--- Original\n+++ New\n@@ @@\n         $this->driverVersion = $driverVersion;\n         return $this;\n     }\n-    public function setUser(string $user) : self\n+    protected function setUser(string $user) : self\n     {\n         $this->user = $user;\n         return $this;","processOutput":"PHPUnit 9.5.10 by Sebastian Bergmann and contributors.\n\nRuntime:       PHP 8.0.13\nConfiguration: \/tmp\/tmp-folder\/infection\/phpunitConfiguration.085dfe9a14a4f68eca0067438edada34.infection.xml\n\nE                                                                   1 \/ 1 (100%)\n\nTime: 00:00.003, Memory: 8.00 MB\n\nThere was 1 error:\n\n1) Fido\\PHPXray\\SqlSegmentTest::testSerialisesCorrectly\nError: Call to protected method Fido\\PHPXray\\SqlSegment::setUser() from scope Fido\\PHPXray\\SqlSegmentTest\n\n\/home\/ranpafin\/php-xray\/tests\/SqlSegmentTest.php:17\n\nERRORS!\nTests: 1, Assertions: 0, Errors: 1."},{"mutator":{"mutatorName":"PublicVisibility","originalSourceCode":"<?php\n\nnamespace Fido\\PHPXray;\n\nclass SqlSegment extends RemoteSegment\n{\n    protected string $url;\n    protected string $preparation;\n    protected string $databaseType;\n    protected string $databaseVersion;\n    protected string $driverVersion;\n    protected string $user;\n    protected string $query;\n    public function setUrl(string $url) : self\n    {\n        $this->url = $url;\n        return $this;\n    }\n    public function setPreparation(string $preparation) : self\n    {\n        $this->preparation = $preparation;\n        return $this;\n    }\n    public function setDatabaseType(string $databaseType) : self\n    {\n        $this->databaseType = $databaseType;\n        return $this;\n    }\n    public function setDatabaseVersion(string $databaseVersion) : self\n    {\n        $this->databaseVersion = $databaseVersion;\n        return $this;\n    }\n    public function setDriverVersion(string $driverVersion) : self\n    {\n        $this->driverVersion = $driverVersion;\n        return $this;\n    }\n    public function setUser(string $user) : self\n    {\n        $this->user = $user;\n        return $this;\n    }\n    public function setQuery(string $query) : self\n    {\n        $this->query = $query;\n        return $this;\n    }\n    \/**\n     * @inheritdoc\n     *\/\n    public function jsonSerialize() : array\n    {\n        $data = parent::jsonSerialize();\n        $data['sql'] = array_filter(['url' => $this->url ?? null, 'preparation' => $this->preparation ?? null, 'database_type' => $this->databaseType ?? null, 'database_version' => $this->databaseVersion ?? null, 'driver_version' => $this->driverVersion ?? null, 'user' => $this->user ?? null, 'sanitized_query' => $this->query ?? null]);\n        return $data;\n    }\n}","mutatedSourceCode":"<?php\n\nnamespace Fido\\PHPXray;\n\nclass SqlSegment extends RemoteSegment\n{\n    protected string $url;\n    protected string $preparation;\n    protected string $databaseType;\n    protected string $databaseVersion;\n    protected string $driverVersion;\n    protected string $user;\n    protected string $query;\n    public function setUrl(string $url) : self\n    {\n        $this->url = $url;\n        return $this;\n    }\n    public function setPreparation(string $preparation) : self\n    {\n        $this->preparation = $preparation;\n        return $this;\n    }\n    public function setDatabaseType(string $databaseType) : self\n    {\n        $this->databaseType = $databaseType;\n        return $this;\n    }\n    public function setDatabaseVersion(string $databaseVersion) : self\n    {\n        $this->databaseVersion = $databaseVersion;\n        return $this;\n    }\n    public function setDriverVersion(string $driverVersion) : self\n    {\n        $this->driverVersion = $driverVersion;\n        return $this;\n    }\n    public function setUser(string $user) : self\n    {\n        $this->user = $user;\n        return $this;\n    }\n    protected function setQuery(string $query) : self\n    {\n        $this->query = $query;\n        return $this;\n    }\n    \/**\n     * @inheritdoc\n     *\/\n    public function jsonSerialize() : array\n    {\n        $data = parent::jsonSerialize();\n        $data['sql'] = array_filter(['url' => $this->url ?? null, 'preparation' => $this->preparation ?? null, 'database_type' => $this->databaseType ?? null, 'database_version' => $this->databaseVersion ?? null, 'driver_version' => $this->driverVersion ?? null, 'user' => $this->user ?? null, 'sanitized_query' => $this->query ?? null]);\n        return $data;\n    }\n}","originalFilePath":"\/home\/ranpafin\/php-xray\/src\/SqlSegment.php","originalStartLine":57},"diff":"--- Original\n+++ New\n@@ @@\n         $this->user = $user;\n         return $this;\n     }\n-    public function setQuery(string $query) : self\n+    protected function setQuery(string $query) : self\n     {\n         $this->query = $query;\n         return $this;","processOutput":"PHPUnit 9.5.10 by Sebastian Bergmann and contributors.\n\nRuntime:       PHP 8.0.13\nConfiguration: \/tmp\/tmp-folder\/infection\/phpunitConfiguration.6ea11fdd47bca0f2786a30a47189facb.infection.xml\n\nE\n\nTime: 00:00.004, Memory: 8.00 MB\n\nThere was 1 error:\n\n1) Fido\\PHPXray\\SqlSegmentTest::testSerialisesCorrectly\nError: Call to protected method Fido\\PHPXray\\SqlSegment::setQuery() from scope Fido\\PHPXray\\SqlSegmentTest\n\n\/home\/ranpafin\/php-xray\/tests\/SqlSegmentTest.php:12\n\nERRORS!\nTests: 1, Assertions: 0, Errors: 1."},{"mutator":{"mutatorName":"ArrayItemRemoval","originalSourceCode":"<?php\n\nnamespace Fido\\PHPXray;\n\nclass SqlSegment extends RemoteSegment\n{\n    protected string $url;\n    protected string $preparation;\n    protected string $databaseType;\n    protected string $databaseVersion;\n    protected string $driverVersion;\n    protected string $user;\n    protected string $query;\n    public function setUrl(string $url) : self\n    {\n        $this->url = $url;\n        return $this;\n    }\n    public function setPreparation(string $preparation) : self\n    {\n        $this->preparation = $preparation;\n        return $this;\n    }\n    public function setDatabaseType(string $databaseType) : self\n    {\n        $this->databaseType = $databaseType;\n        return $this;\n    }\n    public function setDatabaseVersion(string $databaseVersion) : self\n    {\n        $this->databaseVersion = $databaseVersion;\n        return $this;\n    }\n    public function setDriverVersion(string $driverVersion) : self\n    {\n        $this->driverVersion = $driverVersion;\n        return $this;\n    }\n    public function setUser(string $user) : self\n    {\n        $this->user = $user;\n        return $this;\n    }\n    public function setQuery(string $query) : self\n    {\n        $this->query = $query;\n        return $this;\n    }\n    \/**\n     * @inheritdoc\n     *\/\n    public function jsonSerialize() : array\n    {\n        $data = parent::jsonSerialize();\n        $data['sql'] = array_filter(['url' => $this->url ?? null, 'preparation' => $this->preparation ?? null, 'database_type' => $this->databaseType ?? null, 'database_version' => $this->databaseVersion ?? null, 'driver_version' => $this->driverVersion ?? null, 'user' => $this->user ?? null, 'sanitized_query' => $this->query ?? null]);\n        return $data;\n    }\n}","mutatedSourceCode":"<?php\n\nnamespace Fido\\PHPXray;\n\nclass SqlSegment extends RemoteSegment\n{\n    protected string $url;\n    protected string $preparation;\n    protected string $databaseType;\n    protected string $databaseVersion;\n    protected string $driverVersion;\n    protected string $user;\n    protected string $query;\n    public function setUrl(string $url) : self\n    {\n        $this->url = $url;\n        return $this;\n    }\n    public function setPreparation(string $preparation) : self\n    {\n        $this->preparation = $preparation;\n        return $this;\n    }\n    public function setDatabaseType(string $databaseType) : self\n    {\n        $this->databaseType = $databaseType;\n        return $this;\n    }\n    public function setDatabaseVersion(string $databaseVersion) : self\n    {\n        $this->databaseVersion = $databaseVersion;\n        return $this;\n    }\n    public function setDriverVersion(string $driverVersion) : self\n    {\n        $this->driverVersion = $driverVersion;\n        return $this;\n    }\n    public function setUser(string $user) : self\n    {\n        $this->user = $user;\n        return $this;\n    }\n    public function setQuery(string $query) : self\n    {\n        $this->query = $query;\n        return $this;\n    }\n    \/**\n     * @inheritdoc\n     *\/\n    public function jsonSerialize() : array\n    {\n        $data = parent::jsonSerialize();\n        $data['sql'] = array_filter(['preparation' => $this->preparation ?? null, 'database_type' => $this->databaseType ?? null, 'database_version' => $this->databaseVersion ?? null, 'driver_version' => $this->driverVersion ?? null, 'user' => $this->user ?? null, 'sanitized_query' => $this->query ?? null]);\n        return $data;\n    }\n}","originalFilePath":"\/home\/ranpafin\/php-xray\/src\/SqlSegment.php","originalStartLine":71},"diff":"--- Original\n+++ New\n@@ @@\n     public function jsonSerialize() : array\n     {\n         $data = parent::jsonSerialize();\n-        $data['sql'] = array_filter(['url' => $this->url ?? null, 'preparation' => $this->preparation ?? null, 'database_type' => $this->databaseType ?? null, 'database_version' => $this->databaseVersion ?? null, 'driver_version' => $this->driverVersion ?? null, 'user' => $this->user ?? null, 'sanitized_query' => $this->query ?? null]);\n+        $data['sql'] = array_filter(['preparation' => $this->preparation ?? null, 'database_type' => $this->databaseType ?? null, 'database_version' => $this->databaseVersion ?? null, 'driver_version' => $this->driverVersion ?? null, 'user' => $this->user ?? null, 'sanitized_query' => $this->query ?? null]);\n         return $data;\n     }\n }","processOutput":"PHPUnit 9.5.10 by Sebastian Bergmann and contributors.\n\nRuntime:       PHP 8.0.13\nConfiguration: \/tmp\/tmp-folder\/infection\/phpunitConfiguration.fbace90da8b5dbd9a26616926a2a0775.infection.xml\n\nE\n\nTime: 00:00.006, Memory: 8.00 MB\n\nThere was 1 error:\n\n1) Fido\\PHPXray\\SqlSegmentTest::testSerialisesCorrectly\nUndefined array key \"url\"\n\n\/home\/ranpafin\/php-xray\/tests\/SqlSegmentTest.php:30\n\nERRORS!\nTests: 1, Assertions: 7, Errors: 1."},{"mutator":{"mutatorName":"UnwrapArrayFilter","originalSourceCode":"<?php\n\nnamespace Fido\\PHPXray;\n\nclass SqlSegment extends RemoteSegment\n{\n    protected string $url;\n    protected string $preparation;\n    protected string $databaseType;\n    protected string $databaseVersion;\n    protected string $driverVersion;\n    protected string $user;\n    protected string $query;\n    public function setUrl(string $url) : self\n    {\n        $this->url = $url;\n        return $this;\n    }\n    public function setPreparation(string $preparation) : self\n    {\n        $this->preparation = $preparation;\n        return $this;\n    }\n    public function setDatabaseType(string $databaseType) : self\n    {\n        $this->databaseType = $databaseType;\n        return $this;\n    }\n    public function setDatabaseVersion(string $databaseVersion) : self\n    {\n        $this->databaseVersion = $databaseVersion;\n        return $this;\n    }\n    public function setDriverVersion(string $driverVersion) : self\n    {\n        $this->driverVersion = $driverVersion;\n        return $this;\n    }\n    public function setUser(string $user) : self\n    {\n        $this->user = $user;\n        return $this;\n    }\n    public function setQuery(string $query) : self\n    {\n        $this->query = $query;\n        return $this;\n    }\n    \/**\n     * @inheritdoc\n     *\/\n    public function jsonSerialize() : array\n    {\n        $data = parent::jsonSerialize();\n        $data['sql'] = array_filter(['url' => $this->url ?? null, 'preparation' => $this->preparation ?? null, 'database_type' => $this->databaseType ?? null, 'database_version' => $this->databaseVersion ?? null, 'driver_version' => $this->driverVersion ?? null, 'user' => $this->user ?? null, 'sanitized_query' => $this->query ?? null]);\n        return $data;\n    }\n}","mutatedSourceCode":"<?php\n\nnamespace Fido\\PHPXray;\n\nclass SqlSegment extends RemoteSegment\n{\n    protected string $url;\n    protected string $preparation;\n    protected string $databaseType;\n    protected string $databaseVersion;\n    protected string $driverVersion;\n    protected string $user;\n    protected string $query;\n    public function setUrl(string $url) : self\n    {\n        $this->url = $url;\n        return $this;\n    }\n    public function setPreparation(string $preparation) : self\n    {\n        $this->preparation = $preparation;\n        return $this;\n    }\n    public function setDatabaseType(string $databaseType) : self\n    {\n        $this->databaseType = $databaseType;\n        return $this;\n    }\n    public function setDatabaseVersion(string $databaseVersion) : self\n    {\n        $this->databaseVersion = $databaseVersion;\n        return $this;\n    }\n    public function setDriverVersion(string $driverVersion) : self\n    {\n        $this->driverVersion = $driverVersion;\n        return $this;\n    }\n    public function setUser(string $user) : self\n    {\n        $this->user = $user;\n        return $this;\n    }\n    public function setQuery(string $query) : self\n    {\n        $this->query = $query;\n        return $this;\n    }\n    \/**\n     * @inheritdoc\n     *\/\n    public function jsonSerialize() : array\n    {\n        $data = parent::jsonSerialize();\n        $data['sql'] = ['url' => $this->url ?? null, 'preparation' => $this->preparation ?? null, 'database_type' => $this->databaseType ?? null, 'database_version' => $this->databaseVersion ?? null, 'driver_version' => $this->driverVersion ?? null, 'user' => $this->user ?? null, 'sanitized_query' => $this->query ?? null];\n        return $data;\n    }\n}","originalFilePath":"\/home\/ranpafin\/php-xray\/src\/SqlSegment.php","originalStartLine":71},"diff":"--- Original\n+++ New\n@@ @@\n     public function jsonSerialize() : array\n     {\n         $data = parent::jsonSerialize();\n-        $data['sql'] = array_filter(['url' => $this->url ?? null, 'preparation' => $this->preparation ?? null, 'database_type' => $this->databaseType ?? null, 'database_version' => $this->databaseVersion ?? null, 'driver_version' => $this->driverVersion ?? null, 'user' => $this->user ?? null, 'sanitized_query' => $this->query ?? null]);\n+        $data['sql'] = ['url' => $this->url ?? null, 'preparation' => $this->preparation ?? null, 'database_type' => $this->databaseType ?? null, 'database_version' => $this->databaseVersion ?? null, 'driver_version' => $this->driverVersion ?? null, 'user' => $this->user ?? null, 'sanitized_query' => $this->query ?? null];\n         return $data;\n     }\n }","processOutput":"PHPUnit 9.5.10 by Sebastian Bergmann and contributors.\n\nRuntime:       PHP 8.0.13\nConfiguration: \/tmp\/tmp-folder\/infection\/phpunitConfiguration.a8f59bfcfd6c7f83e2de5c4505855e20.infection.xml\n\nE\n\nTime: 00:00.003, Memory: 8.00 MB\n\nThere was 1 error:\n\n1) Fido\\PHPXray\\DaemonSegmentSubmitterTest::testSubmitsToDaemon\nsocket_bind(): Unable to bind address [98]: Address already in use\n\n\/home\/ranpafin\/php-xray\/tests\/DaemonSegmentSubmitterTest.php:18\n\nERRORS!\nTests: 1, Assertions: 0, Errors: 1."},{"mutator":{"mutatorName":"Coalesce","originalSourceCode":"<?php\n\nnamespace Fido\\PHPXray;\n\nclass SqlSegment extends RemoteSegment\n{\n    protected string $url;\n    protected string $preparation;\n    protected string $databaseType;\n    protected string $databaseVersion;\n    protected string $driverVersion;\n    protected string $user;\n    protected string $query;\n    public function setUrl(string $url) : self\n    {\n        $this->url = $url;\n        return $this;\n    }\n    public function setPreparation(string $preparation) : self\n    {\n        $this->preparation = $preparation;\n        return $this;\n    }\n    public function setDatabaseType(string $databaseType) : self\n    {\n        $this->databaseType = $databaseType;\n        return $this;\n    }\n    public function setDatabaseVersion(string $databaseVersion) : self\n    {\n        $this->databaseVersion = $databaseVersion;\n        return $this;\n    }\n    public function setDriverVersion(string $driverVersion) : self\n    {\n        $this->driverVersion = $driverVersion;\n        return $this;\n    }\n    public function setUser(string $user) : self\n    {\n        $this->user = $user;\n        return $this;\n    }\n    public function setQuery(string $query) : self\n    {\n        $this->query = $query;\n        return $this;\n    }\n    \/**\n     * @inheritdoc\n     *\/\n    public function jsonSerialize() : array\n    {\n        $data = parent::jsonSerialize();\n        $data['sql'] = array_filter(['url' => $this->url ?? null, 'preparation' => $this->preparation ?? null, 'database_type' => $this->databaseType ?? null, 'database_version' => $this->databaseVersion ?? null, 'driver_version' => $this->driverVersion ?? null, 'user' => $this->user ?? null, 'sanitized_query' => $this->query ?? null]);\n        return $data;\n    }\n}","mutatedSourceCode":"<?php\n\nnamespace Fido\\PHPXray;\n\nclass SqlSegment extends RemoteSegment\n{\n    protected string $url;\n    protected string $preparation;\n    protected string $databaseType;\n    protected string $databaseVersion;\n    protected string $driverVersion;\n    protected string $user;\n    protected string $query;\n    public function setUrl(string $url) : self\n    {\n        $this->url = $url;\n        return $this;\n    }\n    public function setPreparation(string $preparation) : self\n    {\n        $this->preparation = $preparation;\n        return $this;\n    }\n    public function setDatabaseType(string $databaseType) : self\n    {\n        $this->databaseType = $databaseType;\n        return $this;\n    }\n    public function setDatabaseVersion(string $databaseVersion) : self\n    {\n        $this->databaseVersion = $databaseVersion;\n        return $this;\n    }\n    public function setDriverVersion(string $driverVersion) : self\n    {\n        $this->driverVersion = $driverVersion;\n        return $this;\n    }\n    public function setUser(string $user) : self\n    {\n        $this->user = $user;\n        return $this;\n    }\n    public function setQuery(string $query) : self\n    {\n        $this->query = $query;\n        return $this;\n    }\n    \/**\n     * @inheritdoc\n     *\/\n    public function jsonSerialize() : array\n    {\n        $data = parent::jsonSerialize();\n        $data['sql'] = array_filter(['url' => null ?? $this->url, 'preparation' => $this->preparation ?? null, 'database_type' => $this->databaseType ?? null, 'database_version' => $this->databaseVersion ?? null, 'driver_version' => $this->driverVersion ?? null, 'user' => $this->user ?? null, 'sanitized_query' => $this->query ?? null]);\n        return $data;\n    }\n}","originalFilePath":"\/home\/ranpafin\/php-xray\/src\/SqlSegment.php","originalStartLine":72},"diff":"--- Original\n+++ New\n@@ @@\n     public function jsonSerialize() : array\n     {\n         $data = parent::jsonSerialize();\n-        $data['sql'] = array_filter(['url' => $this->url ?? null, 'preparation' => $this->preparation ?? null, 'database_type' => $this->databaseType ?? null, 'database_version' => $this->databaseVersion ?? null, 'driver_version' => $this->driverVersion ?? null, 'user' => $this->user ?? null, 'sanitized_query' => $this->query ?? null]);\n+        $data['sql'] = array_filter(['url' => null ?? $this->url, 'preparation' => $this->preparation ?? null, 'database_type' => $this->databaseType ?? null, 'database_version' => $this->databaseVersion ?? null, 'driver_version' => $this->driverVersion ?? null, 'user' => $this->user ?? null, 'sanitized_query' => $this->query ?? null]);\n         return $data;\n     }\n }","processOutput":"PHPUnit 9.5.10 by Sebastian Bergmann and contributors.\n\nRuntime:       PHP 8.0.13\nConfiguration: \/tmp\/tmp-folder\/infection\/phpunitConfiguration.c3f366bc9b00a8abf77905f3a4f3dff3.infection.xml\n\nE\n\nTime: 00:00.003, Memory: 8.00 MB\n\nThere was 1 error:\n\n1) Fido\\PHPXray\\DaemonSegmentSubmitterTest::testSubmitsToDaemon\nsocket_bind(): Unable to bind address [98]: Address already in use\n\n\/home\/ranpafin\/php-xray\/tests\/DaemonSegmentSubmitterTest.php:18\n\nERRORS!\nTests: 1, Assertions: 0, Errors: 1."},{"mutator":{"mutatorName":"Coalesce","originalSourceCode":"<?php\n\nnamespace Fido\\PHPXray;\n\nclass SqlSegment extends RemoteSegment\n{\n    protected string $url;\n    protected string $preparation;\n    protected string $databaseType;\n    protected string $databaseVersion;\n    protected string $driverVersion;\n    protected string $user;\n    protected string $query;\n    public function setUrl(string $url) : self\n    {\n        $this->url = $url;\n        return $this;\n    }\n    public function setPreparation(string $preparation) : self\n    {\n        $this->preparation = $preparation;\n        return $this;\n    }\n    public function setDatabaseType(string $databaseType) : self\n    {\n        $this->databaseType = $databaseType;\n        return $this;\n    }\n    public function setDatabaseVersion(string $databaseVersion) : self\n    {\n        $this->databaseVersion = $databaseVersion;\n        return $this;\n    }\n    public function setDriverVersion(string $driverVersion) : self\n    {\n        $this->driverVersion = $driverVersion;\n        return $this;\n    }\n    public function setUser(string $user) : self\n    {\n        $this->user = $user;\n        return $this;\n    }\n    public function setQuery(string $query) : self\n    {\n        $this->query = $query;\n        return $this;\n    }\n    \/**\n     * @inheritdoc\n     *\/\n    public function jsonSerialize() : array\n    {\n        $data = parent::jsonSerialize();\n        $data['sql'] = array_filter(['url' => $this->url ?? null, 'preparation' => $this->preparation ?? null, 'database_type' => $this->databaseType ?? null, 'database_version' => $this->databaseVersion ?? null, 'driver_version' => $this->driverVersion ?? null, 'user' => $this->user ?? null, 'sanitized_query' => $this->query ?? null]);\n        return $data;\n    }\n}","mutatedSourceCode":"<?php\n\nnamespace Fido\\PHPXray;\n\nclass SqlSegment extends RemoteSegment\n{\n    protected string $url;\n    protected string $preparation;\n    protected string $databaseType;\n    protected string $databaseVersion;\n    protected string $driverVersion;\n    protected string $user;\n    protected string $query;\n    public function setUrl(string $url) : self\n    {\n        $this->url = $url;\n        return $this;\n    }\n    public function setPreparation(string $preparation) : self\n    {\n        $this->preparation = $preparation;\n        return $this;\n    }\n    public function setDatabaseType(string $databaseType) : self\n    {\n        $this->databaseType = $databaseType;\n        return $this;\n    }\n    public function setDatabaseVersion(string $databaseVersion) : self\n    {\n        $this->databaseVersion = $databaseVersion;\n        return $this;\n    }\n    public function setDriverVersion(string $driverVersion) : self\n    {\n        $this->driverVersion = $driverVersion;\n        return $this;\n    }\n    public function setUser(string $user) : self\n    {\n        $this->user = $user;\n        return $this;\n    }\n    public function setQuery(string $query) : self\n    {\n        $this->query = $query;\n        return $this;\n    }\n    \/**\n     * @inheritdoc\n     *\/\n    public function jsonSerialize() : array\n    {\n        $data = parent::jsonSerialize();\n        $data['sql'] = array_filter(['url' => $this->url ?? null, 'preparation' => null ?? $this->preparation, 'database_type' => $this->databaseType ?? null, 'database_version' => $this->databaseVersion ?? null, 'driver_version' => $this->driverVersion ?? null, 'user' => $this->user ?? null, 'sanitized_query' => $this->query ?? null]);\n        return $data;\n    }\n}","originalFilePath":"\/home\/ranpafin\/php-xray\/src\/SqlSegment.php","originalStartLine":73},"diff":"--- Original\n+++ New\n@@ @@\n     public function jsonSerialize() : array\n     {\n         $data = parent::jsonSerialize();\n-        $data['sql'] = array_filter(['url' => $this->url ?? null, 'preparation' => $this->preparation ?? null, 'database_type' => $this->databaseType ?? null, 'database_version' => $this->databaseVersion ?? null, 'driver_version' => $this->driverVersion ?? null, 'user' => $this->user ?? null, 'sanitized_query' => $this->query ?? null]);\n+        $data['sql'] = array_filter(['url' => $this->url ?? null, 'preparation' => null ?? $this->preparation, 'database_type' => $this->databaseType ?? null, 'database_version' => $this->databaseVersion ?? null, 'driver_version' => $this->driverVersion ?? null, 'user' => $this->user ?? null, 'sanitized_query' => $this->query ?? null]);\n         return $data;\n     }\n }","processOutput":"PHPUnit 9.5.10 by Sebastian Bergmann and contributors.\n\nRuntime:       PHP 8.0.13\nConfiguration: \/tmp\/tmp-folder\/infection\/phpunitConfiguration.5679ddcfb2654d80908f0cbd6617bdaf.infection.xml\n\nE\n\nTime: 00:00.003, Memory: 8.00 MB\n\nThere was 1 error:\n\n1) Fido\\PHPXray\\DaemonSegmentSubmitterTest::testSubmitsToDaemon\nsocket_bind(): Unable to bind address [98]: Address already in use\n\n\/home\/ranpafin\/php-xray\/tests\/DaemonSegmentSubmitterTest.php:18\n\nERRORS!\nTests: 1, Assertions: 0, Errors: 1."},{"mutator":{"mutatorName":"Coalesce","originalSourceCode":"<?php\n\nnamespace Fido\\PHPXray;\n\nclass SqlSegment extends RemoteSegment\n{\n    protected string $url;\n    protected string $preparation;\n    protected string $databaseType;\n    protected string $databaseVersion;\n    protected string $driverVersion;\n    protected string $user;\n    protected string $query;\n    public function setUrl(string $url) : self\n    {\n        $this->url = $url;\n        return $this;\n    }\n    public function setPreparation(string $preparation) : self\n    {\n        $this->preparation = $preparation;\n        return $this;\n    }\n    public function setDatabaseType(string $databaseType) : self\n    {\n        $this->databaseType = $databaseType;\n        return $this;\n    }\n    public function setDatabaseVersion(string $databaseVersion) : self\n    {\n        $this->databaseVersion = $databaseVersion;\n        return $this;\n    }\n    public function setDriverVersion(string $driverVersion) : self\n    {\n        $this->driverVersion = $driverVersion;\n        return $this;\n    }\n    public function setUser(string $user) : self\n    {\n        $this->user = $user;\n        return $this;\n    }\n    public function setQuery(string $query) : self\n    {\n        $this->query = $query;\n        return $this;\n    }\n    \/**\n     * @inheritdoc\n     *\/\n    public function jsonSerialize() : array\n    {\n        $data = parent::jsonSerialize();\n        $data['sql'] = array_filter(['url' => $this->url ?? null, 'preparation' => $this->preparation ?? null, 'database_type' => $this->databaseType ?? null, 'database_version' => $this->databaseVersion ?? null, 'driver_version' => $this->driverVersion ?? null, 'user' => $this->user ?? null, 'sanitized_query' => $this->query ?? null]);\n        return $data;\n    }\n}","mutatedSourceCode":"<?php\n\nnamespace Fido\\PHPXray;\n\nclass SqlSegment extends RemoteSegment\n{\n    protected string $url;\n    protected string $preparation;\n    protected string $databaseType;\n    protected string $databaseVersion;\n    protected string $driverVersion;\n    protected string $user;\n    protected string $query;\n    public function setUrl(string $url) : self\n    {\n        $this->url = $url;\n        return $this;\n    }\n    public function setPreparation(string $preparation) : self\n    {\n        $this->preparation = $preparation;\n        return $this;\n    }\n    public function setDatabaseType(string $databaseType) : self\n    {\n        $this->databaseType = $databaseType;\n        return $this;\n    }\n    public function setDatabaseVersion(string $databaseVersion) : self\n    {\n        $this->databaseVersion = $databaseVersion;\n        return $this;\n    }\n    public function setDriverVersion(string $driverVersion) : self\n    {\n        $this->driverVersion = $driverVersion;\n        return $this;\n    }\n    public function setUser(string $user) : self\n    {\n        $this->user = $user;\n        return $this;\n    }\n    public function setQuery(string $query) : self\n    {\n        $this->query = $query;\n        return $this;\n    }\n    \/**\n     * @inheritdoc\n     *\/\n    public function jsonSerialize() : array\n    {\n        $data = parent::jsonSerialize();\n        $data['sql'] = array_filter(['url' => $this->url ?? null, 'preparation' => $this->preparation ?? null, 'database_type' => null ?? $this->databaseType, 'database_version' => $this->databaseVersion ?? null, 'driver_version' => $this->driverVersion ?? null, 'user' => $this->user ?? null, 'sanitized_query' => $this->query ?? null]);\n        return $data;\n    }\n}","originalFilePath":"\/home\/ranpafin\/php-xray\/src\/SqlSegment.php","originalStartLine":74},"diff":"--- Original\n+++ New\n@@ @@\n     public function jsonSerialize() : array\n     {\n         $data = parent::jsonSerialize();\n-        $data['sql'] = array_filter(['url' => $this->url ?? null, 'preparation' => $this->preparation ?? null, 'database_type' => $this->databaseType ?? null, 'database_version' => $this->databaseVersion ?? null, 'driver_version' => $this->driverVersion ?? null, 'user' => $this->user ?? null, 'sanitized_query' => $this->query ?? null]);\n+        $data['sql'] = array_filter(['url' => $this->url ?? null, 'preparation' => $this->preparation ?? null, 'database_type' => null ?? $this->databaseType, 'database_version' => $this->databaseVersion ?? null, 'driver_version' => $this->driverVersion ?? null, 'user' => $this->user ?? null, 'sanitized_query' => $this->query ?? null]);\n         return $data;\n     }\n }","processOutput":"PHPUnit 9.5.10 by Sebastian Bergmann and contributors.\n\nRuntime:       PHP 8.0.13\nConfiguration: \/tmp\/tmp-folder\/infection\/phpunitConfiguration.ec36ae037951fc3000baec8c461645d5.infection.xml\n\nE\n\nTime: 00:00.004, Memory: 8.00 MB\n\nThere was 1 error:\n\n1) Fido\\PHPXray\\DaemonSegmentSubmitterTest::testSubmitsToDaemon\nsocket_bind(): Unable to bind address [98]: Address already in use\n\n\/home\/ranpafin\/php-xray\/tests\/DaemonSegmentSubmitterTest.php:18\n\nERRORS!\nTests: 1, Assertions: 0, Errors: 1."},{"mutator":{"mutatorName":"Coalesce","originalSourceCode":"<?php\n\nnamespace Fido\\PHPXray;\n\nclass SqlSegment extends RemoteSegment\n{\n    protected string $url;\n    protected string $preparation;\n    protected string $databaseType;\n    protected string $databaseVersion;\n    protected string $driverVersion;\n    protected string $user;\n    protected string $query;\n    public function setUrl(string $url) : self\n    {\n        $this->url = $url;\n        return $this;\n    }\n    public function setPreparation(string $preparation) : self\n    {\n        $this->preparation = $preparation;\n        return $this;\n    }\n    public function setDatabaseType(string $databaseType) : self\n    {\n        $this->databaseType = $databaseType;\n        return $this;\n    }\n    public function setDatabaseVersion(string $databaseVersion) : self\n    {\n        $this->databaseVersion = $databaseVersion;\n        return $this;\n    }\n    public function setDriverVersion(string $driverVersion) : self\n    {\n        $this->driverVersion = $driverVersion;\n        return $this;\n    }\n    public function setUser(string $user) : self\n    {\n        $this->user = $user;\n        return $this;\n    }\n    public function setQuery(string $query) : self\n    {\n        $this->query = $query;\n        return $this;\n    }\n    \/**\n     * @inheritdoc\n     *\/\n    public function jsonSerialize() : array\n    {\n        $data = parent::jsonSerialize();\n        $data['sql'] = array_filter(['url' => $this->url ?? null, 'preparation' => $this->preparation ?? null, 'database_type' => $this->databaseType ?? null, 'database_version' => $this->databaseVersion ?? null, 'driver_version' => $this->driverVersion ?? null, 'user' => $this->user ?? null, 'sanitized_query' => $this->query ?? null]);\n        return $data;\n    }\n}","mutatedSourceCode":"<?php\n\nnamespace Fido\\PHPXray;\n\nclass SqlSegment extends RemoteSegment\n{\n    protected string $url;\n    protected string $preparation;\n    protected string $databaseType;\n    protected string $databaseVersion;\n    protected string $driverVersion;\n    protected string $user;\n    protected string $query;\n    public function setUrl(string $url) : self\n    {\n        $this->url = $url;\n        return $this;\n    }\n    public function setPreparation(string $preparation) : self\n    {\n        $this->preparation = $preparation;\n        return $this;\n    }\n    public function setDatabaseType(string $databaseType) : self\n    {\n        $this->databaseType = $databaseType;\n        return $this;\n    }\n    public function setDatabaseVersion(string $databaseVersion) : self\n    {\n        $this->databaseVersion = $databaseVersion;\n        return $this;\n    }\n    public function setDriverVersion(string $driverVersion) : self\n    {\n        $this->driverVersion = $driverVersion;\n        return $this;\n    }\n    public function setUser(string $user) : self\n    {\n        $this->user = $user;\n        return $this;\n    }\n    public function setQuery(string $query) : self\n    {\n        $this->query = $query;\n        return $this;\n    }\n    \/**\n     * @inheritdoc\n     *\/\n    public function jsonSerialize() : array\n    {\n        $data = parent::jsonSerialize();\n        $data['sql'] = array_filter(['url' => $this->url ?? null, 'preparation' => $this->preparation ?? null, 'database_type' => $this->databaseType ?? null, 'database_version' => null ?? $this->databaseVersion, 'driver_version' => $this->driverVersion ?? null, 'user' => $this->user ?? null, 'sanitized_query' => $this->query ?? null]);\n        return $data;\n    }\n}","originalFilePath":"\/home\/ranpafin\/php-xray\/src\/SqlSegment.php","originalStartLine":75},"diff":"--- Original\n+++ New\n@@ @@\n     public function jsonSerialize() : array\n     {\n         $data = parent::jsonSerialize();\n-        $data['sql'] = array_filter(['url' => $this->url ?? null, 'preparation' => $this->preparation ?? null, 'database_type' => $this->databaseType ?? null, 'database_version' => $this->databaseVersion ?? null, 'driver_version' => $this->driverVersion ?? null, 'user' => $this->user ?? null, 'sanitized_query' => $this->query ?? null]);\n+        $data['sql'] = array_filter(['url' => $this->url ?? null, 'preparation' => $this->preparation ?? null, 'database_type' => $this->databaseType ?? null, 'database_version' => null ?? $this->databaseVersion, 'driver_version' => $this->driverVersion ?? null, 'user' => $this->user ?? null, 'sanitized_query' => $this->query ?? null]);\n         return $data;\n     }\n }","processOutput":"PHPUnit 9.5.10 by Sebastian Bergmann and contributors.\n\nRuntime:       PHP 8.0.13\nConfiguration: \/tmp\/tmp-folder\/infection\/phpunitConfiguration.8ba7cf3b63973c35530684681cbb21fa.infection.xml\n\nE\n\nTime: 00:00.004, Memory: 8.00 MB\n\nThere was 1 error:\n\n1) Fido\\PHPXray\\DaemonSegmentSubmitterTest::testSubmitsToDaemon\nsocket_bind(): Unable to bind address [98]: Address already in use\n\n\/home\/ranpafin\/php-xray\/tests\/DaemonSegmentSubmitterTest.php:18\n\nERRORS!\nTests: 1, Assertions: 0, Errors: 1."},{"mutator":{"mutatorName":"Coalesce","originalSourceCode":"<?php\n\nnamespace Fido\\PHPXray;\n\nclass SqlSegment extends RemoteSegment\n{\n    protected string $url;\n    protected string $preparation;\n    protected string $databaseType;\n    protected string $databaseVersion;\n    protected string $driverVersion;\n    protected string $user;\n    protected string $query;\n    public function setUrl(string $url) : self\n    {\n        $this->url = $url;\n        return $this;\n    }\n    public function setPreparation(string $preparation) : self\n    {\n        $this->preparation = $preparation;\n        return $this;\n    }\n    public function setDatabaseType(string $databaseType) : self\n    {\n        $this->databaseType = $databaseType;\n        return $this;\n    }\n    public function setDatabaseVersion(string $databaseVersion) : self\n    {\n        $this->databaseVersion = $databaseVersion;\n        return $this;\n    }\n    public function setDriverVersion(string $driverVersion) : self\n    {\n        $this->driverVersion = $driverVersion;\n        return $this;\n    }\n    public function setUser(string $user) : self\n    {\n        $this->user = $user;\n        return $this;\n    }\n    public function setQuery(string $query) : self\n    {\n        $this->query = $query;\n        return $this;\n    }\n    \/**\n     * @inheritdoc\n     *\/\n    public function jsonSerialize() : array\n    {\n        $data = parent::jsonSerialize();\n        $data['sql'] = array_filter(['url' => $this->url ?? null, 'preparation' => $this->preparation ?? null, 'database_type' => $this->databaseType ?? null, 'database_version' => $this->databaseVersion ?? null, 'driver_version' => $this->driverVersion ?? null, 'user' => $this->user ?? null, 'sanitized_query' => $this->query ?? null]);\n        return $data;\n    }\n}","mutatedSourceCode":"<?php\n\nnamespace Fido\\PHPXray;\n\nclass SqlSegment extends RemoteSegment\n{\n    protected string $url;\n    protected string $preparation;\n    protected string $databaseType;\n    protected string $databaseVersion;\n    protected string $driverVersion;\n    protected string $user;\n    protected string $query;\n    public function setUrl(string $url) : self\n    {\n        $this->url = $url;\n        return $this;\n    }\n    public function setPreparation(string $preparation) : self\n    {\n        $this->preparation = $preparation;\n        return $this;\n    }\n    public function setDatabaseType(string $databaseType) : self\n    {\n        $this->databaseType = $databaseType;\n        return $this;\n    }\n    public function setDatabaseVersion(string $databaseVersion) : self\n    {\n        $this->databaseVersion = $databaseVersion;\n        return $this;\n    }\n    public function setDriverVersion(string $driverVersion) : self\n    {\n        $this->driverVersion = $driverVersion;\n        return $this;\n    }\n    public function setUser(string $user) : self\n    {\n        $this->user = $user;\n        return $this;\n    }\n    public function setQuery(string $query) : self\n    {\n        $this->query = $query;\n        return $this;\n    }\n    \/**\n     * @inheritdoc\n     *\/\n    public function jsonSerialize() : array\n    {\n        $data = parent::jsonSerialize();\n        $data['sql'] = array_filter(['url' => $this->url ?? null, 'preparation' => $this->preparation ?? null, 'database_type' => $this->databaseType ?? null, 'database_version' => $this->databaseVersion ?? null, 'driver_version' => null ?? $this->driverVersion, 'user' => $this->user ?? null, 'sanitized_query' => $this->query ?? null]);\n        return $data;\n    }\n}","originalFilePath":"\/home\/ranpafin\/php-xray\/src\/SqlSegment.php","originalStartLine":76},"diff":"--- Original\n+++ New\n@@ @@\n     public function jsonSerialize() : array\n     {\n         $data = parent::jsonSerialize();\n-        $data['sql'] = array_filter(['url' => $this->url ?? null, 'preparation' => $this->preparation ?? null, 'database_type' => $this->databaseType ?? null, 'database_version' => $this->databaseVersion ?? null, 'driver_version' => $this->driverVersion ?? null, 'user' => $this->user ?? null, 'sanitized_query' => $this->query ?? null]);\n+        $data['sql'] = array_filter(['url' => $this->url ?? null, 'preparation' => $this->preparation ?? null, 'database_type' => $this->databaseType ?? null, 'database_version' => $this->databaseVersion ?? null, 'driver_version' => null ?? $this->driverVersion, 'user' => $this->user ?? null, 'sanitized_query' => $this->query ?? null]);\n         return $data;\n     }\n }","processOutput":"PHPUnit 9.5.10 by Sebastian Bergmann and contributors.\n\nRuntime:       PHP 8.0.13\nConfiguration: \/tmp\/tmp-folder\/infection\/phpunitConfiguration.91de66599f550b9da107ce6f8ea1459d.infection.xml\n\nE\n\nTime: 00:00.005, Memory: 8.00 MB\n\nThere was 1 error:\n\n1) Fido\\PHPXray\\DaemonSegmentSubmitterTest::testSubmitsToDaemon\nsocket_bind(): Unable to bind address [98]: Address already in use\n\n\/home\/ranpafin\/php-xray\/tests\/DaemonSegmentSubmitterTest.php:18\n\nERRORS!\nTests: 1, Assertions: 0, Errors: 1."},{"mutator":{"mutatorName":"Coalesce","originalSourceCode":"<?php\n\nnamespace Fido\\PHPXray;\n\nclass SqlSegment extends RemoteSegment\n{\n    protected string $url;\n    protected string $preparation;\n    protected string $databaseType;\n    protected string $databaseVersion;\n    protected string $driverVersion;\n    protected string $user;\n    protected string $query;\n    public function setUrl(string $url) : self\n    {\n        $this->url = $url;\n        return $this;\n    }\n    public function setPreparation(string $preparation) : self\n    {\n        $this->preparation = $preparation;\n        return $this;\n    }\n    public function setDatabaseType(string $databaseType) : self\n    {\n        $this->databaseType = $databaseType;\n        return $this;\n    }\n    public function setDatabaseVersion(string $databaseVersion) : self\n    {\n        $this->databaseVersion = $databaseVersion;\n        return $this;\n    }\n    public function setDriverVersion(string $driverVersion) : self\n    {\n        $this->driverVersion = $driverVersion;\n        return $this;\n    }\n    public function setUser(string $user) : self\n    {\n        $this->user = $user;\n        return $this;\n    }\n    public function setQuery(string $query) : self\n    {\n        $this->query = $query;\n        return $this;\n    }\n    \/**\n     * @inheritdoc\n     *\/\n    public function jsonSerialize() : array\n    {\n        $data = parent::jsonSerialize();\n        $data['sql'] = array_filter(['url' => $this->url ?? null, 'preparation' => $this->preparation ?? null, 'database_type' => $this->databaseType ?? null, 'database_version' => $this->databaseVersion ?? null, 'driver_version' => $this->driverVersion ?? null, 'user' => $this->user ?? null, 'sanitized_query' => $this->query ?? null]);\n        return $data;\n    }\n}","mutatedSourceCode":"<?php\n\nnamespace Fido\\PHPXray;\n\nclass SqlSegment extends RemoteSegment\n{\n    protected string $url;\n    protected string $preparation;\n    protected string $databaseType;\n    protected string $databaseVersion;\n    protected string $driverVersion;\n    protected string $user;\n    protected string $query;\n    public function setUrl(string $url) : self\n    {\n        $this->url = $url;\n        return $this;\n    }\n    public function setPreparation(string $preparation) : self\n    {\n        $this->preparation = $preparation;\n        return $this;\n    }\n    public function setDatabaseType(string $databaseType) : self\n    {\n        $this->databaseType = $databaseType;\n        return $this;\n    }\n    public function setDatabaseVersion(string $databaseVersion) : self\n    {\n        $this->databaseVersion = $databaseVersion;\n        return $this;\n    }\n    public function setDriverVersion(string $driverVersion) : self\n    {\n        $this->driverVersion = $driverVersion;\n        return $this;\n    }\n    public function setUser(string $user) : self\n    {\n        $this->user = $user;\n        return $this;\n    }\n    public function setQuery(string $query) : self\n    {\n        $this->query = $query;\n        return $this;\n    }\n    \/**\n     * @inheritdoc\n     *\/\n    public function jsonSerialize() : array\n    {\n        $data = parent::jsonSerialize();\n        $data['sql'] = array_filter(['url' => $this->url ?? null, 'preparation' => $this->preparation ?? null, 'database_type' => $this->databaseType ?? null, 'database_version' => $this->databaseVersion ?? null, 'driver_version' => $this->driverVersion ?? null, 'user' => null ?? $this->user, 'sanitized_query' => $this->query ?? null]);\n        return $data;\n    }\n}","originalFilePath":"\/home\/ranpafin\/php-xray\/src\/SqlSegment.php","originalStartLine":77},"diff":"--- Original\n+++ New\n@@ @@\n     public function jsonSerialize() : array\n     {\n         $data = parent::jsonSerialize();\n-        $data['sql'] = array_filter(['url' => $this->url ?? null, 'preparation' => $this->preparation ?? null, 'database_type' => $this->databaseType ?? null, 'database_version' => $this->databaseVersion ?? null, 'driver_version' => $this->driverVersion ?? null, 'user' => $this->user ?? null, 'sanitized_query' => $this->query ?? null]);\n+        $data['sql'] = array_filter(['url' => $this->url ?? null, 'preparation' => $this->preparation ?? null, 'database_type' => $this->databaseType ?? null, 'database_version' => $this->databaseVersion ?? null, 'driver_version' => $this->driverVersion ?? null, 'user' => null ?? $this->user, 'sanitized_query' => $this->query ?? null]);\n         return $data;\n     }\n }","processOutput":"PHPUnit 9.5.10 by Sebastian Bergmann and contributors.\n\nRuntime:       PHP 8.0.13\nConfiguration: \/tmp\/tmp-folder\/infection\/phpunitConfiguration.b5cbd7a29ed26663489c7fb07269d842.infection.xml\n\nE\n\nTime: 00:00.008, Memory: 8.00 MB\n\nThere was 1 error:\n\n1) Fido\\PHPXray\\DaemonSegmentSubmitterTest::testSubmitsToDaemon\nsocket_bind(): Unable to bind address [98]: Address already in use\n\n\/home\/ranpafin\/php-xray\/tests\/DaemonSegmentSubmitterTest.php:18\n\nERRORS!\nTests: 1, Assertions: 0, Errors: 1."},{"mutator":{"mutatorName":"Coalesce","originalSourceCode":"<?php\n\nnamespace Fido\\PHPXray;\n\nclass SqlSegment extends RemoteSegment\n{\n    protected string $url;\n    protected string $preparation;\n    protected string $databaseType;\n    protected string $databaseVersion;\n    protected string $driverVersion;\n    protected string $user;\n    protected string $query;\n    public function setUrl(string $url) : self\n    {\n        $this->url = $url;\n        return $this;\n    }\n    public function setPreparation(string $preparation) : self\n    {\n        $this->preparation = $preparation;\n        return $this;\n    }\n    public function setDatabaseType(string $databaseType) : self\n    {\n        $this->databaseType = $databaseType;\n        return $this;\n    }\n    public function setDatabaseVersion(string $databaseVersion) : self\n    {\n        $this->databaseVersion = $databaseVersion;\n        return $this;\n    }\n    public function setDriverVersion(string $driverVersion) : self\n    {\n        $this->driverVersion = $driverVersion;\n        return $this;\n    }\n    public function setUser(string $user) : self\n    {\n        $this->user = $user;\n        return $this;\n    }\n    public function setQuery(string $query) : self\n    {\n        $this->query = $query;\n        return $this;\n    }\n    \/**\n     * @inheritdoc\n     *\/\n    public function jsonSerialize() : array\n    {\n        $data = parent::jsonSerialize();\n        $data['sql'] = array_filter(['url' => $this->url ?? null, 'preparation' => $this->preparation ?? null, 'database_type' => $this->databaseType ?? null, 'database_version' => $this->databaseVersion ?? null, 'driver_version' => $this->driverVersion ?? null, 'user' => $this->user ?? null, 'sanitized_query' => $this->query ?? null]);\n        return $data;\n    }\n}","mutatedSourceCode":"<?php\n\nnamespace Fido\\PHPXray;\n\nclass SqlSegment extends RemoteSegment\n{\n    protected string $url;\n    protected string $preparation;\n    protected string $databaseType;\n    protected string $databaseVersion;\n    protected string $driverVersion;\n    protected string $user;\n    protected string $query;\n    public function setUrl(string $url) : self\n    {\n        $this->url = $url;\n        return $this;\n    }\n    public function setPreparation(string $preparation) : self\n    {\n        $this->preparation = $preparation;\n        return $this;\n    }\n    public function setDatabaseType(string $databaseType) : self\n    {\n        $this->databaseType = $databaseType;\n        return $this;\n    }\n    public function setDatabaseVersion(string $databaseVersion) : self\n    {\n        $this->databaseVersion = $databaseVersion;\n        return $this;\n    }\n    public function setDriverVersion(string $driverVersion) : self\n    {\n        $this->driverVersion = $driverVersion;\n        return $this;\n    }\n    public function setUser(string $user) : self\n    {\n        $this->user = $user;\n        return $this;\n    }\n    public function setQuery(string $query) : self\n    {\n        $this->query = $query;\n        return $this;\n    }\n    \/**\n     * @inheritdoc\n     *\/\n    public function jsonSerialize() : array\n    {\n        $data = parent::jsonSerialize();\n        $data['sql'] = array_filter(['url' => $this->url ?? null, 'preparation' => $this->preparation ?? null, 'database_type' => $this->databaseType ?? null, 'database_version' => $this->databaseVersion ?? null, 'driver_version' => $this->driverVersion ?? null, 'user' => $this->user ?? null, 'sanitized_query' => null ?? $this->query]);\n        return $data;\n    }\n}","originalFilePath":"\/home\/ranpafin\/php-xray\/src\/SqlSegment.php","originalStartLine":78},"diff":"--- Original\n+++ New\n@@ @@\n     public function jsonSerialize() : array\n     {\n         $data = parent::jsonSerialize();\n-        $data['sql'] = array_filter(['url' => $this->url ?? null, 'preparation' => $this->preparation ?? null, 'database_type' => $this->databaseType ?? null, 'database_version' => $this->databaseVersion ?? null, 'driver_version' => $this->driverVersion ?? null, 'user' => $this->user ?? null, 'sanitized_query' => $this->query ?? null]);\n+        $data['sql'] = array_filter(['url' => $this->url ?? null, 'preparation' => $this->preparation ?? null, 'database_type' => $this->databaseType ?? null, 'database_version' => $this->databaseVersion ?? null, 'driver_version' => $this->driverVersion ?? null, 'user' => $this->user ?? null, 'sanitized_query' => null ?? $this->query]);\n         return $data;\n     }\n }","processOutput":"PHPUnit 9.5.10 by Sebastian Bergmann and contributors.\n\nRuntime:       PHP 8.0.13\nConfiguration: \/tmp\/tmp-folder\/infection\/phpunitConfiguration.4c79913860876f206a7107e42472f6f9.infection.xml\n\nE\n\nTime: 00:00.003, Memory: 8.00 MB\n\nThere was 1 error:\n\n1) Fido\\PHPXray\\DaemonSegmentSubmitterTest::testSubmitsToDaemon\nsocket_bind(): Unable to bind address [98]: Address already in use\n\n\/home\/ranpafin\/php-xray\/tests\/DaemonSegmentSubmitterTest.php:18\n\nERRORS!\nTests: 1, Assertions: 0, Errors: 1."},{"mutator":{"mutatorName":"ArrayOneItem","originalSourceCode":"<?php\n\nnamespace Fido\\PHPXray;\n\nclass SqlSegment extends RemoteSegment\n{\n    protected string $url;\n    protected string $preparation;\n    protected string $databaseType;\n    protected string $databaseVersion;\n    protected string $driverVersion;\n    protected string $user;\n    protected string $query;\n    public function setUrl(string $url) : self\n    {\n        $this->url = $url;\n        return $this;\n    }\n    public function setPreparation(string $preparation) : self\n    {\n        $this->preparation = $preparation;\n        return $this;\n    }\n    public function setDatabaseType(string $databaseType) : self\n    {\n        $this->databaseType = $databaseType;\n        return $this;\n    }\n    public function setDatabaseVersion(string $databaseVersion) : self\n    {\n        $this->databaseVersion = $databaseVersion;\n        return $this;\n    }\n    public function setDriverVersion(string $driverVersion) : self\n    {\n        $this->driverVersion = $driverVersion;\n        return $this;\n    }\n    public function setUser(string $user) : self\n    {\n        $this->user = $user;\n        return $this;\n    }\n    public function setQuery(string $query) : self\n    {\n        $this->query = $query;\n        return $this;\n    }\n    \/**\n     * @inheritdoc\n     *\/\n    public function jsonSerialize() : array\n    {\n        $data = parent::jsonSerialize();\n        $data['sql'] = array_filter(['url' => $this->url ?? null, 'preparation' => $this->preparation ?? null, 'database_type' => $this->databaseType ?? null, 'database_version' => $this->databaseVersion ?? null, 'driver_version' => $this->driverVersion ?? null, 'user' => $this->user ?? null, 'sanitized_query' => $this->query ?? null]);\n        return $data;\n    }\n}","mutatedSourceCode":"<?php\n\nnamespace Fido\\PHPXray;\n\nclass SqlSegment extends RemoteSegment\n{\n    protected string $url;\n    protected string $preparation;\n    protected string $databaseType;\n    protected string $databaseVersion;\n    protected string $driverVersion;\n    protected string $user;\n    protected string $query;\n    public function setUrl(string $url) : self\n    {\n        $this->url = $url;\n        return $this;\n    }\n    public function setPreparation(string $preparation) : self\n    {\n        $this->preparation = $preparation;\n        return $this;\n    }\n    public function setDatabaseType(string $databaseType) : self\n    {\n        $this->databaseType = $databaseType;\n        return $this;\n    }\n    public function setDatabaseVersion(string $databaseVersion) : self\n    {\n        $this->databaseVersion = $databaseVersion;\n        return $this;\n    }\n    public function setDriverVersion(string $driverVersion) : self\n    {\n        $this->driverVersion = $driverVersion;\n        return $this;\n    }\n    public function setUser(string $user) : self\n    {\n        $this->user = $user;\n        return $this;\n    }\n    public function setQuery(string $query) : self\n    {\n        $this->query = $query;\n        return $this;\n    }\n    \/**\n     * @inheritdoc\n     *\/\n    public function jsonSerialize() : array\n    {\n        $data = parent::jsonSerialize();\n        $data['sql'] = array_filter(['url' => $this->url ?? null, 'preparation' => $this->preparation ?? null, 'database_type' => $this->databaseType ?? null, 'database_version' => $this->databaseVersion ?? null, 'driver_version' => $this->driverVersion ?? null, 'user' => $this->user ?? null, 'sanitized_query' => $this->query ?? null]);\n        return count($data) > 1 ? array_slice($data, 0, 1, true) : $data;\n    }\n}","originalFilePath":"\/home\/ranpafin\/php-xray\/src\/SqlSegment.php","originalStartLine":81},"diff":"--- Original\n+++ New\n@@ @@\n     {\n         $data = parent::jsonSerialize();\n         $data['sql'] = array_filter(['url' => $this->url ?? null, 'preparation' => $this->preparation ?? null, 'database_type' => $this->databaseType ?? null, 'database_version' => $this->databaseVersion ?? null, 'driver_version' => $this->driverVersion ?? null, 'user' => $this->user ?? null, 'sanitized_query' => $this->query ?? null]);\n-        return $data;\n+        return count($data) > 1 ? array_slice($data, 0, 1, true) : $data;\n     }\n }","processOutput":"PHPUnit 9.5.10 by Sebastian Bergmann and contributors.\n\nRuntime:       PHP 8.0.13\nConfiguration: \/tmp\/tmp-folder\/infection\/phpunitConfiguration.94e53d65b9272e46ba53103de627110d.infection.xml\n\nE\n\nTime: 00:00.004, Memory: 8.00 MB\n\nThere was 1 error:\n\n1) Fido\\PHPXray\\SqlSegmentTest::testSerialisesCorrectly\nUndefined array key \"namespace\"\n\n\/home\/ranpafin\/php-xray\/tests\/SqlSegmentTest.php:23\n\nERRORS!\nTests: 1, Assertions: 0, Errors: 1."},{"mutator":{"mutatorName":"DecrementInteger","originalSourceCode":"<?php\n\nnamespace Fido\\PHPXray\\Submission;\n\nuse Error;\nuse Fido\\PHPXray\\Segment;\nuse Socket;\nuse function socket_create;\nuse function socket_last_error;\nclass DaemonSegmentSubmitter implements SegmentSubmitter\n{\n    protected const MAX_SEGMENT_SIZE = 64000;\n    \/**\n     * @var array<string, mixed>\n     *\/\n    public const HEADER = ['format' => 'json', 'version' => 1];\n    private string $host;\n    private int $port;\n    \/** @var Socket *\/\n    private $socket;\n    public function __construct(string $host = '127.0.0.1', int $port = 2000)\n    {\n        if (isset($_SERVER['AWS_XRAY_DAEMON_ADDRESS'])) {\n            [$host, $port] = explode(\":\", $_SERVER['AWS_XRAY_DAEMON_ADDRESS']);\n        }\n        $this->host = $_SERVER['_AWS_XRAY_DAEMON_ADDRESS'] ?? $host;\n        $this->port = (int) ($_SERVER['_AWS_XRAY_DAEMON_PORT'] ?? $port);\n        if (!($socket = socket_create(AF_INET, SOCK_DGRAM, SOL_UDP))) {\n            throw new Error('Can\\'t create socket: ' . socket_last_error());\n        }\n        $this->socket = $socket;\n    }\n    public function __destruct()\n    {\n        socket_close($this->socket);\n    }\n    public function submitSegment(Segment $segment) : void\n    {\n        $packet = $this->buildPacket($segment);\n        $packetLength = strlen($packet);\n        if ($packetLength > self::MAX_SEGMENT_SIZE) {\n            $this->submitFragmented($segment);\n            return;\n        }\n        $this->sendPacket($packet);\n    }\n    \/**\n     * @param Segment|array<string, mixed> $segment\n     *\/\n    private function buildPacket(Segment|array $segment) : string\n    {\n        return implode(\"\\n\", array_map('json_encode', [self::HEADER, $segment]));\n    }\n    private function sendPacket(string $packet) : void\n    {\n        socket_sendto($this->socket, $packet, strlen($packet), 0, $this->host, $this->port);\n    }\n    private function submitFragmented(Segment $segment) : void\n    {\n        $rawSegment = $segment->jsonSerialize();\n        \/** @var Segment[] $subsegments *\/\n        $subsegments = $rawSegment['subsegments'] ?? [];\n        unset($rawSegment['subsegments']);\n        $this->submitOpenSegment($rawSegment);\n        foreach ($subsegments as $subsegment) {\n            $subsegment = clone $subsegment;\n            $subsegment->setParentId($segment->getId())->setTraceId($segment->getTraceId())->setIndependent(true);\n            $this->submitSegment($subsegment);\n        }\n        $completePacket = $this->buildPacket($rawSegment);\n        $this->sendPacket($completePacket);\n    }\n    \/**\n     * @param array<string, mixed> $openSegment\n     *\/\n    private function submitOpenSegment(array $openSegment) : void\n    {\n        unset($openSegment['end_time']);\n        $openSegment['in_progress'] = true;\n        $this->sendPacket($this->buildPacket($openSegment));\n    }\n}","mutatedSourceCode":"<?php\n\nnamespace Fido\\PHPXray\\Submission;\n\nuse Error;\nuse Fido\\PHPXray\\Segment;\nuse Socket;\nuse function socket_create;\nuse function socket_last_error;\nclass DaemonSegmentSubmitter implements SegmentSubmitter\n{\n    protected const MAX_SEGMENT_SIZE = 64000;\n    \/**\n     * @var array<string, mixed>\n     *\/\n    public const HEADER = ['format' => 'json', 'version' => 1];\n    private string $host;\n    private int $port;\n    \/** @var Socket *\/\n    private $socket;\n    public function __construct(string $host = '127.0.0.1', int $port = 1999)\n    {\n        if (isset($_SERVER['AWS_XRAY_DAEMON_ADDRESS'])) {\n            [$host, $port] = explode(\":\", $_SERVER['AWS_XRAY_DAEMON_ADDRESS']);\n        }\n        $this->host = $_SERVER['_AWS_XRAY_DAEMON_ADDRESS'] ?? $host;\n        $this->port = (int) ($_SERVER['_AWS_XRAY_DAEMON_PORT'] ?? $port);\n        if (!($socket = socket_create(AF_INET, SOCK_DGRAM, SOL_UDP))) {\n            throw new Error('Can\\'t create socket: ' . socket_last_error());\n        }\n        $this->socket = $socket;\n    }\n    public function __destruct()\n    {\n        socket_close($this->socket);\n    }\n    public function submitSegment(Segment $segment) : void\n    {\n        $packet = $this->buildPacket($segment);\n        $packetLength = strlen($packet);\n        if ($packetLength > self::MAX_SEGMENT_SIZE) {\n            $this->submitFragmented($segment);\n            return;\n        }\n        $this->sendPacket($packet);\n    }\n    \/**\n     * @param Segment|array<string, mixed> $segment\n     *\/\n    private function buildPacket(Segment|array $segment) : string\n    {\n        return implode(\"\\n\", array_map('json_encode', [self::HEADER, $segment]));\n    }\n    private function sendPacket(string $packet) : void\n    {\n        socket_sendto($this->socket, $packet, strlen($packet), 0, $this->host, $this->port);\n    }\n    private function submitFragmented(Segment $segment) : void\n    {\n        $rawSegment = $segment->jsonSerialize();\n        \/** @var Segment[] $subsegments *\/\n        $subsegments = $rawSegment['subsegments'] ?? [];\n        unset($rawSegment['subsegments']);\n        $this->submitOpenSegment($rawSegment);\n        foreach ($subsegments as $subsegment) {\n            $subsegment = clone $subsegment;\n            $subsegment->setParentId($segment->getId())->setTraceId($segment->getTraceId())->setIndependent(true);\n            $this->submitSegment($subsegment);\n        }\n        $completePacket = $this->buildPacket($rawSegment);\n        $this->sendPacket($completePacket);\n    }\n    \/**\n     * @param array<string, mixed> $openSegment\n     *\/\n    private function submitOpenSegment(array $openSegment) : void\n    {\n        unset($openSegment['end_time']);\n        $openSegment['in_progress'] = true;\n        $this->sendPacket($this->buildPacket($openSegment));\n    }\n}","originalFilePath":"\/home\/ranpafin\/php-xray\/src\/Submission\/DaemonSegmentSubmitter.php","originalStartLine":28},"diff":"--- Original\n+++ New\n@@ @@\n     private int $port;\n     \/** @var Socket *\/\n     private $socket;\n-    public function __construct(string $host = '127.0.0.1', int $port = 2000)\n+    public function __construct(string $host = '127.0.0.1', int $port = 1999)\n     {\n         if (isset($_SERVER['AWS_XRAY_DAEMON_ADDRESS'])) {\n             [$host, $port] = explode(\":\", $_SERVER['AWS_XRAY_DAEMON_ADDRESS']);","processOutput":"PHPUnit 9.5.10 by Sebastian Bergmann and contributors.\n\nRuntime:       PHP 8.0.13\nConfiguration: \/tmp\/tmp-folder\/infection\/phpunitConfiguration.f2e07205975c6e542928a2cefc1e26eb.infection.xml\n\nE\n\nTime: 00:00.003, Memory: 8.00 MB\n\nThere was 1 error:\n\n1) Fido\\PHPXray\\DaemonSegmentSubmitterTest::testSubmitsToDaemon\nsocket_bind(): Unable to bind address [98]: Address already in use\n\n\/home\/ranpafin\/php-xray\/tests\/DaemonSegmentSubmitterTest.php:18\n\nERRORS!\nTests: 1, Assertions: 0, Errors: 1."},{"mutator":{"mutatorName":"Coalesce","originalSourceCode":"<?php\n\nnamespace Fido\\PHPXray\\Submission;\n\nuse Error;\nuse Fido\\PHPXray\\Segment;\nuse Socket;\nuse function socket_create;\nuse function socket_last_error;\nclass DaemonSegmentSubmitter implements SegmentSubmitter\n{\n    protected const MAX_SEGMENT_SIZE = 64000;\n    \/**\n     * @var array<string, mixed>\n     *\/\n    public const HEADER = ['format' => 'json', 'version' => 1];\n    private string $host;\n    private int $port;\n    \/** @var Socket *\/\n    private $socket;\n    public function __construct(string $host = '127.0.0.1', int $port = 2000)\n    {\n        if (isset($_SERVER['AWS_XRAY_DAEMON_ADDRESS'])) {\n            [$host, $port] = explode(\":\", $_SERVER['AWS_XRAY_DAEMON_ADDRESS']);\n        }\n        $this->host = $_SERVER['_AWS_XRAY_DAEMON_ADDRESS'] ?? $host;\n        $this->port = (int) ($_SERVER['_AWS_XRAY_DAEMON_PORT'] ?? $port);\n        if (!($socket = socket_create(AF_INET, SOCK_DGRAM, SOL_UDP))) {\n            throw new Error('Can\\'t create socket: ' . socket_last_error());\n        }\n        $this->socket = $socket;\n    }\n    public function __destruct()\n    {\n        socket_close($this->socket);\n    }\n    public function submitSegment(Segment $segment) : void\n    {\n        $packet = $this->buildPacket($segment);\n        $packetLength = strlen($packet);\n        if ($packetLength > self::MAX_SEGMENT_SIZE) {\n            $this->submitFragmented($segment);\n            return;\n        }\n        $this->sendPacket($packet);\n    }\n    \/**\n     * @param Segment|array<string, mixed> $segment\n     *\/\n    private function buildPacket(Segment|array $segment) : string\n    {\n        return implode(\"\\n\", array_map('json_encode', [self::HEADER, $segment]));\n    }\n    private function sendPacket(string $packet) : void\n    {\n        socket_sendto($this->socket, $packet, strlen($packet), 0, $this->host, $this->port);\n    }\n    private function submitFragmented(Segment $segment) : void\n    {\n        $rawSegment = $segment->jsonSerialize();\n        \/** @var Segment[] $subsegments *\/\n        $subsegments = $rawSegment['subsegments'] ?? [];\n        unset($rawSegment['subsegments']);\n        $this->submitOpenSegment($rawSegment);\n        foreach ($subsegments as $subsegment) {\n            $subsegment = clone $subsegment;\n            $subsegment->setParentId($segment->getId())->setTraceId($segment->getTraceId())->setIndependent(true);\n            $this->submitSegment($subsegment);\n        }\n        $completePacket = $this->buildPacket($rawSegment);\n        $this->sendPacket($completePacket);\n    }\n    \/**\n     * @param array<string, mixed> $openSegment\n     *\/\n    private function submitOpenSegment(array $openSegment) : void\n    {\n        unset($openSegment['end_time']);\n        $openSegment['in_progress'] = true;\n        $this->sendPacket($this->buildPacket($openSegment));\n    }\n}","mutatedSourceCode":"<?php\n\nnamespace Fido\\PHPXray\\Submission;\n\nuse Error;\nuse Fido\\PHPXray\\Segment;\nuse Socket;\nuse function socket_create;\nuse function socket_last_error;\nclass DaemonSegmentSubmitter implements SegmentSubmitter\n{\n    protected const MAX_SEGMENT_SIZE = 64000;\n    \/**\n     * @var array<string, mixed>\n     *\/\n    public const HEADER = ['format' => 'json', 'version' => 1];\n    private string $host;\n    private int $port;\n    \/** @var Socket *\/\n    private $socket;\n    public function __construct(string $host = '127.0.0.1', int $port = 2000)\n    {\n        if (isset($_SERVER['AWS_XRAY_DAEMON_ADDRESS'])) {\n            [$host, $port] = explode(\":\", $_SERVER['AWS_XRAY_DAEMON_ADDRESS']);\n        }\n        $this->host = $host ?? $_SERVER['_AWS_XRAY_DAEMON_ADDRESS'];\n        $this->port = (int) ($_SERVER['_AWS_XRAY_DAEMON_PORT'] ?? $port);\n        if (!($socket = socket_create(AF_INET, SOCK_DGRAM, SOL_UDP))) {\n            throw new Error('Can\\'t create socket: ' . socket_last_error());\n        }\n        $this->socket = $socket;\n    }\n    public function __destruct()\n    {\n        socket_close($this->socket);\n    }\n    public function submitSegment(Segment $segment) : void\n    {\n        $packet = $this->buildPacket($segment);\n        $packetLength = strlen($packet);\n        if ($packetLength > self::MAX_SEGMENT_SIZE) {\n            $this->submitFragmented($segment);\n            return;\n        }\n        $this->sendPacket($packet);\n    }\n    \/**\n     * @param Segment|array<string, mixed> $segment\n     *\/\n    private function buildPacket(Segment|array $segment) : string\n    {\n        return implode(\"\\n\", array_map('json_encode', [self::HEADER, $segment]));\n    }\n    private function sendPacket(string $packet) : void\n    {\n        socket_sendto($this->socket, $packet, strlen($packet), 0, $this->host, $this->port);\n    }\n    private function submitFragmented(Segment $segment) : void\n    {\n        $rawSegment = $segment->jsonSerialize();\n        \/** @var Segment[] $subsegments *\/\n        $subsegments = $rawSegment['subsegments'] ?? [];\n        unset($rawSegment['subsegments']);\n        $this->submitOpenSegment($rawSegment);\n        foreach ($subsegments as $subsegment) {\n            $subsegment = clone $subsegment;\n            $subsegment->setParentId($segment->getId())->setTraceId($segment->getTraceId())->setIndependent(true);\n            $this->submitSegment($subsegment);\n        }\n        $completePacket = $this->buildPacket($rawSegment);\n        $this->sendPacket($completePacket);\n    }\n    \/**\n     * @param array<string, mixed> $openSegment\n     *\/\n    private function submitOpenSegment(array $openSegment) : void\n    {\n        unset($openSegment['end_time']);\n        $openSegment['in_progress'] = true;\n        $this->sendPacket($this->buildPacket($openSegment));\n    }\n}","originalFilePath":"\/home\/ranpafin\/php-xray\/src\/Submission\/DaemonSegmentSubmitter.php","originalStartLine":34},"diff":"--- Original\n+++ New\n@@ @@\n         if (isset($_SERVER['AWS_XRAY_DAEMON_ADDRESS'])) {\n             [$host, $port] = explode(\":\", $_SERVER['AWS_XRAY_DAEMON_ADDRESS']);\n         }\n-        $this->host = $_SERVER['_AWS_XRAY_DAEMON_ADDRESS'] ?? $host;\n+        $this->host = $host ?? $_SERVER['_AWS_XRAY_DAEMON_ADDRESS'];\n         $this->port = (int) ($_SERVER['_AWS_XRAY_DAEMON_PORT'] ?? $port);\n         if (!($socket = socket_create(AF_INET, SOCK_DGRAM, SOL_UDP))) {\n             throw new Error('Can\\'t create socket: ' . socket_last_error());","processOutput":"PHPUnit 9.5.10 by Sebastian Bergmann and contributors.\n\nRuntime:       PHP 8.0.13\nConfiguration: \/tmp\/tmp-folder\/infection\/phpunitConfiguration.45c7ff8e3fe15a7ff5095a083b486907.infection.xml\n\nE\n\nTime: 00:00.003, Memory: 8.00 MB\n\nThere was 1 error:\n\n1) Fido\\PHPXray\\DaemonSegmentSubmitterTest::testSubmitsToDaemon\nsocket_bind(): Unable to bind address [98]: Address already in use\n\n\/home\/ranpafin\/php-xray\/tests\/DaemonSegmentSubmitterTest.php:18\n\nERRORS!\nTests: 1, Assertions: 0, Errors: 1."},{"mutator":{"mutatorName":"Coalesce","originalSourceCode":"<?php\n\nnamespace Fido\\PHPXray\\Submission;\n\nuse Error;\nuse Fido\\PHPXray\\Segment;\nuse Socket;\nuse function socket_create;\nuse function socket_last_error;\nclass DaemonSegmentSubmitter implements SegmentSubmitter\n{\n    protected const MAX_SEGMENT_SIZE = 64000;\n    \/**\n     * @var array<string, mixed>\n     *\/\n    public const HEADER = ['format' => 'json', 'version' => 1];\n    private string $host;\n    private int $port;\n    \/** @var Socket *\/\n    private $socket;\n    public function __construct(string $host = '127.0.0.1', int $port = 2000)\n    {\n        if (isset($_SERVER['AWS_XRAY_DAEMON_ADDRESS'])) {\n            [$host, $port] = explode(\":\", $_SERVER['AWS_XRAY_DAEMON_ADDRESS']);\n        }\n        $this->host = $_SERVER['_AWS_XRAY_DAEMON_ADDRESS'] ?? $host;\n        $this->port = (int) ($_SERVER['_AWS_XRAY_DAEMON_PORT'] ?? $port);\n        if (!($socket = socket_create(AF_INET, SOCK_DGRAM, SOL_UDP))) {\n            throw new Error('Can\\'t create socket: ' . socket_last_error());\n        }\n        $this->socket = $socket;\n    }\n    public function __destruct()\n    {\n        socket_close($this->socket);\n    }\n    public function submitSegment(Segment $segment) : void\n    {\n        $packet = $this->buildPacket($segment);\n        $packetLength = strlen($packet);\n        if ($packetLength > self::MAX_SEGMENT_SIZE) {\n            $this->submitFragmented($segment);\n            return;\n        }\n        $this->sendPacket($packet);\n    }\n    \/**\n     * @param Segment|array<string, mixed> $segment\n     *\/\n    private function buildPacket(Segment|array $segment) : string\n    {\n        return implode(\"\\n\", array_map('json_encode', [self::HEADER, $segment]));\n    }\n    private function sendPacket(string $packet) : void\n    {\n        socket_sendto($this->socket, $packet, strlen($packet), 0, $this->host, $this->port);\n    }\n    private function submitFragmented(Segment $segment) : void\n    {\n        $rawSegment = $segment->jsonSerialize();\n        \/** @var Segment[] $subsegments *\/\n        $subsegments = $rawSegment['subsegments'] ?? [];\n        unset($rawSegment['subsegments']);\n        $this->submitOpenSegment($rawSegment);\n        foreach ($subsegments as $subsegment) {\n            $subsegment = clone $subsegment;\n            $subsegment->setParentId($segment->getId())->setTraceId($segment->getTraceId())->setIndependent(true);\n            $this->submitSegment($subsegment);\n        }\n        $completePacket = $this->buildPacket($rawSegment);\n        $this->sendPacket($completePacket);\n    }\n    \/**\n     * @param array<string, mixed> $openSegment\n     *\/\n    private function submitOpenSegment(array $openSegment) : void\n    {\n        unset($openSegment['end_time']);\n        $openSegment['in_progress'] = true;\n        $this->sendPacket($this->buildPacket($openSegment));\n    }\n}","mutatedSourceCode":"<?php\n\nnamespace Fido\\PHPXray\\Submission;\n\nuse Error;\nuse Fido\\PHPXray\\Segment;\nuse Socket;\nuse function socket_create;\nuse function socket_last_error;\nclass DaemonSegmentSubmitter implements SegmentSubmitter\n{\n    protected const MAX_SEGMENT_SIZE = 64000;\n    \/**\n     * @var array<string, mixed>\n     *\/\n    public const HEADER = ['format' => 'json', 'version' => 1];\n    private string $host;\n    private int $port;\n    \/** @var Socket *\/\n    private $socket;\n    public function __construct(string $host = '127.0.0.1', int $port = 2000)\n    {\n        if (isset($_SERVER['AWS_XRAY_DAEMON_ADDRESS'])) {\n            [$host, $port] = explode(\":\", $_SERVER['AWS_XRAY_DAEMON_ADDRESS']);\n        }\n        $this->host = $_SERVER['_AWS_XRAY_DAEMON_ADDRESS'] ?? $host;\n        $this->port = (int) ($port ?? $_SERVER['_AWS_XRAY_DAEMON_PORT']);\n        if (!($socket = socket_create(AF_INET, SOCK_DGRAM, SOL_UDP))) {\n            throw new Error('Can\\'t create socket: ' . socket_last_error());\n        }\n        $this->socket = $socket;\n    }\n    public function __destruct()\n    {\n        socket_close($this->socket);\n    }\n    public function submitSegment(Segment $segment) : void\n    {\n        $packet = $this->buildPacket($segment);\n        $packetLength = strlen($packet);\n        if ($packetLength > self::MAX_SEGMENT_SIZE) {\n            $this->submitFragmented($segment);\n            return;\n        }\n        $this->sendPacket($packet);\n    }\n    \/**\n     * @param Segment|array<string, mixed> $segment\n     *\/\n    private function buildPacket(Segment|array $segment) : string\n    {\n        return implode(\"\\n\", array_map('json_encode', [self::HEADER, $segment]));\n    }\n    private function sendPacket(string $packet) : void\n    {\n        socket_sendto($this->socket, $packet, strlen($packet), 0, $this->host, $this->port);\n    }\n    private function submitFragmented(Segment $segment) : void\n    {\n        $rawSegment = $segment->jsonSerialize();\n        \/** @var Segment[] $subsegments *\/\n        $subsegments = $rawSegment['subsegments'] ?? [];\n        unset($rawSegment['subsegments']);\n        $this->submitOpenSegment($rawSegment);\n        foreach ($subsegments as $subsegment) {\n            $subsegment = clone $subsegment;\n            $subsegment->setParentId($segment->getId())->setTraceId($segment->getTraceId())->setIndependent(true);\n            $this->submitSegment($subsegment);\n        }\n        $completePacket = $this->buildPacket($rawSegment);\n        $this->sendPacket($completePacket);\n    }\n    \/**\n     * @param array<string, mixed> $openSegment\n     *\/\n    private function submitOpenSegment(array $openSegment) : void\n    {\n        unset($openSegment['end_time']);\n        $openSegment['in_progress'] = true;\n        $this->sendPacket($this->buildPacket($openSegment));\n    }\n}","originalFilePath":"\/home\/ranpafin\/php-xray\/src\/Submission\/DaemonSegmentSubmitter.php","originalStartLine":35},"diff":"--- Original\n+++ New\n@@ @@\n             [$host, $port] = explode(\":\", $_SERVER['AWS_XRAY_DAEMON_ADDRESS']);\n         }\n         $this->host = $_SERVER['_AWS_XRAY_DAEMON_ADDRESS'] ?? $host;\n-        $this->port = (int) ($_SERVER['_AWS_XRAY_DAEMON_PORT'] ?? $port);\n+        $this->port = (int) ($port ?? $_SERVER['_AWS_XRAY_DAEMON_PORT']);\n         if (!($socket = socket_create(AF_INET, SOCK_DGRAM, SOL_UDP))) {\n             throw new Error('Can\\'t create socket: ' . socket_last_error());\n         }","processOutput":"PHPUnit 9.5.10 by Sebastian Bergmann and contributors.\n\nRuntime:       PHP 8.0.13\nConfiguration: \/tmp\/tmp-folder\/infection\/phpunitConfiguration.3741c0704f8fe4affad3c83288a0091b.infection.xml\n\nE\n\nTime: 00:00.003, Memory: 8.00 MB\n\nThere was 1 error:\n\n1) Fido\\PHPXray\\DaemonSegmentSubmitterTest::testSubmitsToDaemon\nsocket_bind(): Unable to bind address [98]: Address already in use\n\n\/home\/ranpafin\/php-xray\/tests\/DaemonSegmentSubmitterTest.php:18\n\nERRORS!\nTests: 1, Assertions: 0, Errors: 1."},{"mutator":{"mutatorName":"CastInt","originalSourceCode":"<?php\n\nnamespace Fido\\PHPXray\\Submission;\n\nuse Error;\nuse Fido\\PHPXray\\Segment;\nuse Socket;\nuse function socket_create;\nuse function socket_last_error;\nclass DaemonSegmentSubmitter implements SegmentSubmitter\n{\n    protected const MAX_SEGMENT_SIZE = 64000;\n    \/**\n     * @var array<string, mixed>\n     *\/\n    public const HEADER = ['format' => 'json', 'version' => 1];\n    private string $host;\n    private int $port;\n    \/** @var Socket *\/\n    private $socket;\n    public function __construct(string $host = '127.0.0.1', int $port = 2000)\n    {\n        if (isset($_SERVER['AWS_XRAY_DAEMON_ADDRESS'])) {\n            [$host, $port] = explode(\":\", $_SERVER['AWS_XRAY_DAEMON_ADDRESS']);\n        }\n        $this->host = $_SERVER['_AWS_XRAY_DAEMON_ADDRESS'] ?? $host;\n        $this->port = (int) ($_SERVER['_AWS_XRAY_DAEMON_PORT'] ?? $port);\n        if (!($socket = socket_create(AF_INET, SOCK_DGRAM, SOL_UDP))) {\n            throw new Error('Can\\'t create socket: ' . socket_last_error());\n        }\n        $this->socket = $socket;\n    }\n    public function __destruct()\n    {\n        socket_close($this->socket);\n    }\n    public function submitSegment(Segment $segment) : void\n    {\n        $packet = $this->buildPacket($segment);\n        $packetLength = strlen($packet);\n        if ($packetLength > self::MAX_SEGMENT_SIZE) {\n            $this->submitFragmented($segment);\n            return;\n        }\n        $this->sendPacket($packet);\n    }\n    \/**\n     * @param Segment|array<string, mixed> $segment\n     *\/\n    private function buildPacket(Segment|array $segment) : string\n    {\n        return implode(\"\\n\", array_map('json_encode', [self::HEADER, $segment]));\n    }\n    private function sendPacket(string $packet) : void\n    {\n        socket_sendto($this->socket, $packet, strlen($packet), 0, $this->host, $this->port);\n    }\n    private function submitFragmented(Segment $segment) : void\n    {\n        $rawSegment = $segment->jsonSerialize();\n        \/** @var Segment[] $subsegments *\/\n        $subsegments = $rawSegment['subsegments'] ?? [];\n        unset($rawSegment['subsegments']);\n        $this->submitOpenSegment($rawSegment);\n        foreach ($subsegments as $subsegment) {\n            $subsegment = clone $subsegment;\n            $subsegment->setParentId($segment->getId())->setTraceId($segment->getTraceId())->setIndependent(true);\n            $this->submitSegment($subsegment);\n        }\n        $completePacket = $this->buildPacket($rawSegment);\n        $this->sendPacket($completePacket);\n    }\n    \/**\n     * @param array<string, mixed> $openSegment\n     *\/\n    private function submitOpenSegment(array $openSegment) : void\n    {\n        unset($openSegment['end_time']);\n        $openSegment['in_progress'] = true;\n        $this->sendPacket($this->buildPacket($openSegment));\n    }\n}","mutatedSourceCode":"<?php\n\nnamespace Fido\\PHPXray\\Submission;\n\nuse Error;\nuse Fido\\PHPXray\\Segment;\nuse Socket;\nuse function socket_create;\nuse function socket_last_error;\nclass DaemonSegmentSubmitter implements SegmentSubmitter\n{\n    protected const MAX_SEGMENT_SIZE = 64000;\n    \/**\n     * @var array<string, mixed>\n     *\/\n    public const HEADER = ['format' => 'json', 'version' => 1];\n    private string $host;\n    private int $port;\n    \/** @var Socket *\/\n    private $socket;\n    public function __construct(string $host = '127.0.0.1', int $port = 2000)\n    {\n        if (isset($_SERVER['AWS_XRAY_DAEMON_ADDRESS'])) {\n            [$host, $port] = explode(\":\", $_SERVER['AWS_XRAY_DAEMON_ADDRESS']);\n        }\n        $this->host = $_SERVER['_AWS_XRAY_DAEMON_ADDRESS'] ?? $host;\n        $this->port = $_SERVER['_AWS_XRAY_DAEMON_PORT'] ?? $port;\n        if (!($socket = socket_create(AF_INET, SOCK_DGRAM, SOL_UDP))) {\n            throw new Error('Can\\'t create socket: ' . socket_last_error());\n        }\n        $this->socket = $socket;\n    }\n    public function __destruct()\n    {\n        socket_close($this->socket);\n    }\n    public function submitSegment(Segment $segment) : void\n    {\n        $packet = $this->buildPacket($segment);\n        $packetLength = strlen($packet);\n        if ($packetLength > self::MAX_SEGMENT_SIZE) {\n            $this->submitFragmented($segment);\n            return;\n        }\n        $this->sendPacket($packet);\n    }\n    \/**\n     * @param Segment|array<string, mixed> $segment\n     *\/\n    private function buildPacket(Segment|array $segment) : string\n    {\n        return implode(\"\\n\", array_map('json_encode', [self::HEADER, $segment]));\n    }\n    private function sendPacket(string $packet) : void\n    {\n        socket_sendto($this->socket, $packet, strlen($packet), 0, $this->host, $this->port);\n    }\n    private function submitFragmented(Segment $segment) : void\n    {\n        $rawSegment = $segment->jsonSerialize();\n        \/** @var Segment[] $subsegments *\/\n        $subsegments = $rawSegment['subsegments'] ?? [];\n        unset($rawSegment['subsegments']);\n        $this->submitOpenSegment($rawSegment);\n        foreach ($subsegments as $subsegment) {\n            $subsegment = clone $subsegment;\n            $subsegment->setParentId($segment->getId())->setTraceId($segment->getTraceId())->setIndependent(true);\n            $this->submitSegment($subsegment);\n        }\n        $completePacket = $this->buildPacket($rawSegment);\n        $this->sendPacket($completePacket);\n    }\n    \/**\n     * @param array<string, mixed> $openSegment\n     *\/\n    private function submitOpenSegment(array $openSegment) : void\n    {\n        unset($openSegment['end_time']);\n        $openSegment['in_progress'] = true;\n        $this->sendPacket($this->buildPacket($openSegment));\n    }\n}","originalFilePath":"\/home\/ranpafin\/php-xray\/src\/Submission\/DaemonSegmentSubmitter.php","originalStartLine":35},"diff":"--- Original\n+++ New\n@@ @@\n             [$host, $port] = explode(\":\", $_SERVER['AWS_XRAY_DAEMON_ADDRESS']);\n         }\n         $this->host = $_SERVER['_AWS_XRAY_DAEMON_ADDRESS'] ?? $host;\n-        $this->port = (int) ($_SERVER['_AWS_XRAY_DAEMON_PORT'] ?? $port);\n+        $this->port = $_SERVER['_AWS_XRAY_DAEMON_PORT'] ?? $port;\n         if (!($socket = socket_create(AF_INET, SOCK_DGRAM, SOL_UDP))) {\n             throw new Error('Can\\'t create socket: ' . socket_last_error());\n         }","processOutput":"PHPUnit 9.5.10 by Sebastian Bergmann and contributors.\n\nRuntime:       PHP 8.0.13\nConfiguration: \/tmp\/tmp-folder\/infection\/phpunitConfiguration.229179991bbc153a7490f4648b36ad58.infection.xml\n\nE\n\nTime: 00:00.003, Memory: 8.00 MB\n\nThere was 1 error:\n\n1) Fido\\PHPXray\\DaemonSegmentSubmitterTest::testSubmitsToDaemon\nsocket_bind(): Unable to bind address [98]: Address already in use\n\n\/home\/ranpafin\/php-xray\/tests\/DaemonSegmentSubmitterTest.php:18\n\nERRORS!\nTests: 1, Assertions: 0, Errors: 1."},{"mutator":{"mutatorName":"LogicalNot","originalSourceCode":"<?php\n\nnamespace Fido\\PHPXray\\Submission;\n\nuse Error;\nuse Fido\\PHPXray\\Segment;\nuse Socket;\nuse function socket_create;\nuse function socket_last_error;\nclass DaemonSegmentSubmitter implements SegmentSubmitter\n{\n    protected const MAX_SEGMENT_SIZE = 64000;\n    \/**\n     * @var array<string, mixed>\n     *\/\n    public const HEADER = ['format' => 'json', 'version' => 1];\n    private string $host;\n    private int $port;\n    \/** @var Socket *\/\n    private $socket;\n    public function __construct(string $host = '127.0.0.1', int $port = 2000)\n    {\n        if (isset($_SERVER['AWS_XRAY_DAEMON_ADDRESS'])) {\n            [$host, $port] = explode(\":\", $_SERVER['AWS_XRAY_DAEMON_ADDRESS']);\n        }\n        $this->host = $_SERVER['_AWS_XRAY_DAEMON_ADDRESS'] ?? $host;\n        $this->port = (int) ($_SERVER['_AWS_XRAY_DAEMON_PORT'] ?? $port);\n        if (!($socket = socket_create(AF_INET, SOCK_DGRAM, SOL_UDP))) {\n            throw new Error('Can\\'t create socket: ' . socket_last_error());\n        }\n        $this->socket = $socket;\n    }\n    public function __destruct()\n    {\n        socket_close($this->socket);\n    }\n    public function submitSegment(Segment $segment) : void\n    {\n        $packet = $this->buildPacket($segment);\n        $packetLength = strlen($packet);\n        if ($packetLength > self::MAX_SEGMENT_SIZE) {\n            $this->submitFragmented($segment);\n            return;\n        }\n        $this->sendPacket($packet);\n    }\n    \/**\n     * @param Segment|array<string, mixed> $segment\n     *\/\n    private function buildPacket(Segment|array $segment) : string\n    {\n        return implode(\"\\n\", array_map('json_encode', [self::HEADER, $segment]));\n    }\n    private function sendPacket(string $packet) : void\n    {\n        socket_sendto($this->socket, $packet, strlen($packet), 0, $this->host, $this->port);\n    }\n    private function submitFragmented(Segment $segment) : void\n    {\n        $rawSegment = $segment->jsonSerialize();\n        \/** @var Segment[] $subsegments *\/\n        $subsegments = $rawSegment['subsegments'] ?? [];\n        unset($rawSegment['subsegments']);\n        $this->submitOpenSegment($rawSegment);\n        foreach ($subsegments as $subsegment) {\n            $subsegment = clone $subsegment;\n            $subsegment->setParentId($segment->getId())->setTraceId($segment->getTraceId())->setIndependent(true);\n            $this->submitSegment($subsegment);\n        }\n        $completePacket = $this->buildPacket($rawSegment);\n        $this->sendPacket($completePacket);\n    }\n    \/**\n     * @param array<string, mixed> $openSegment\n     *\/\n    private function submitOpenSegment(array $openSegment) : void\n    {\n        unset($openSegment['end_time']);\n        $openSegment['in_progress'] = true;\n        $this->sendPacket($this->buildPacket($openSegment));\n    }\n}","mutatedSourceCode":"<?php\n\nnamespace Fido\\PHPXray\\Submission;\n\nuse Error;\nuse Fido\\PHPXray\\Segment;\nuse Socket;\nuse function socket_create;\nuse function socket_last_error;\nclass DaemonSegmentSubmitter implements SegmentSubmitter\n{\n    protected const MAX_SEGMENT_SIZE = 64000;\n    \/**\n     * @var array<string, mixed>\n     *\/\n    public const HEADER = ['format' => 'json', 'version' => 1];\n    private string $host;\n    private int $port;\n    \/** @var Socket *\/\n    private $socket;\n    public function __construct(string $host = '127.0.0.1', int $port = 2000)\n    {\n        if (isset($_SERVER['AWS_XRAY_DAEMON_ADDRESS'])) {\n            [$host, $port] = explode(\":\", $_SERVER['AWS_XRAY_DAEMON_ADDRESS']);\n        }\n        $this->host = $_SERVER['_AWS_XRAY_DAEMON_ADDRESS'] ?? $host;\n        $this->port = (int) ($_SERVER['_AWS_XRAY_DAEMON_PORT'] ?? $port);\n        if ($socket = socket_create(AF_INET, SOCK_DGRAM, SOL_UDP)) {\n            throw new Error('Can\\'t create socket: ' . socket_last_error());\n        }\n        $this->socket = $socket;\n    }\n    public function __destruct()\n    {\n        socket_close($this->socket);\n    }\n    public function submitSegment(Segment $segment) : void\n    {\n        $packet = $this->buildPacket($segment);\n        $packetLength = strlen($packet);\n        if ($packetLength > self::MAX_SEGMENT_SIZE) {\n            $this->submitFragmented($segment);\n            return;\n        }\n        $this->sendPacket($packet);\n    }\n    \/**\n     * @param Segment|array<string, mixed> $segment\n     *\/\n    private function buildPacket(Segment|array $segment) : string\n    {\n        return implode(\"\\n\", array_map('json_encode', [self::HEADER, $segment]));\n    }\n    private function sendPacket(string $packet) : void\n    {\n        socket_sendto($this->socket, $packet, strlen($packet), 0, $this->host, $this->port);\n    }\n    private function submitFragmented(Segment $segment) : void\n    {\n        $rawSegment = $segment->jsonSerialize();\n        \/** @var Segment[] $subsegments *\/\n        $subsegments = $rawSegment['subsegments'] ?? [];\n        unset($rawSegment['subsegments']);\n        $this->submitOpenSegment($rawSegment);\n        foreach ($subsegments as $subsegment) {\n            $subsegment = clone $subsegment;\n            $subsegment->setParentId($segment->getId())->setTraceId($segment->getTraceId())->setIndependent(true);\n            $this->submitSegment($subsegment);\n        }\n        $completePacket = $this->buildPacket($rawSegment);\n        $this->sendPacket($completePacket);\n    }\n    \/**\n     * @param array<string, mixed> $openSegment\n     *\/\n    private function submitOpenSegment(array $openSegment) : void\n    {\n        unset($openSegment['end_time']);\n        $openSegment['in_progress'] = true;\n        $this->sendPacket($this->buildPacket($openSegment));\n    }\n}","originalFilePath":"\/home\/ranpafin\/php-xray\/src\/Submission\/DaemonSegmentSubmitter.php","originalStartLine":37},"diff":"--- Original\n+++ New\n@@ @@\n         }\n         $this->host = $_SERVER['_AWS_XRAY_DAEMON_ADDRESS'] ?? $host;\n         $this->port = (int) ($_SERVER['_AWS_XRAY_DAEMON_PORT'] ?? $port);\n-        if (!($socket = socket_create(AF_INET, SOCK_DGRAM, SOL_UDP))) {\n+        if ($socket = socket_create(AF_INET, SOCK_DGRAM, SOL_UDP)) {\n             throw new Error('Can\\'t create socket: ' . socket_last_error());\n         }\n         $this->socket = $socket;","processOutput":"PHPUnit 9.5.10 by Sebastian Bergmann and contributors.\n\nRuntime:       PHP 8.0.13\nConfiguration: \/tmp\/tmp-folder\/infection\/phpunitConfiguration.3a0937a2e9b9aa8ec1844c60ad2fcc51.infection.xml\n\nE\n\nTime: 00:00.003, Memory: 8.00 MB\n\nThere was 1 error:\n\n1) Fido\\PHPXray\\DaemonSegmentSubmitterTest::testSubmitsToDaemon\nsocket_bind(): Unable to bind address [98]: Address already in use\n\n\/home\/ranpafin\/php-xray\/tests\/DaemonSegmentSubmitterTest.php:18\n\nERRORS!\nTests: 1, Assertions: 0, Errors: 1."},{"mutator":{"mutatorName":"GreaterThan","originalSourceCode":"<?php\n\nnamespace Fido\\PHPXray\\Submission;\n\nuse Error;\nuse Fido\\PHPXray\\Segment;\nuse Socket;\nuse function socket_create;\nuse function socket_last_error;\nclass DaemonSegmentSubmitter implements SegmentSubmitter\n{\n    protected const MAX_SEGMENT_SIZE = 64000;\n    \/**\n     * @var array<string, mixed>\n     *\/\n    public const HEADER = ['format' => 'json', 'version' => 1];\n    private string $host;\n    private int $port;\n    \/** @var Socket *\/\n    private $socket;\n    public function __construct(string $host = '127.0.0.1', int $port = 2000)\n    {\n        if (isset($_SERVER['AWS_XRAY_DAEMON_ADDRESS'])) {\n            [$host, $port] = explode(\":\", $_SERVER['AWS_XRAY_DAEMON_ADDRESS']);\n        }\n        $this->host = $_SERVER['_AWS_XRAY_DAEMON_ADDRESS'] ?? $host;\n        $this->port = (int) ($_SERVER['_AWS_XRAY_DAEMON_PORT'] ?? $port);\n        if (!($socket = socket_create(AF_INET, SOCK_DGRAM, SOL_UDP))) {\n            throw new Error('Can\\'t create socket: ' . socket_last_error());\n        }\n        $this->socket = $socket;\n    }\n    public function __destruct()\n    {\n        socket_close($this->socket);\n    }\n    public function submitSegment(Segment $segment) : void\n    {\n        $packet = $this->buildPacket($segment);\n        $packetLength = strlen($packet);\n        if ($packetLength > self::MAX_SEGMENT_SIZE) {\n            $this->submitFragmented($segment);\n            return;\n        }\n        $this->sendPacket($packet);\n    }\n    \/**\n     * @param Segment|array<string, mixed> $segment\n     *\/\n    private function buildPacket(Segment|array $segment) : string\n    {\n        return implode(\"\\n\", array_map('json_encode', [self::HEADER, $segment]));\n    }\n    private function sendPacket(string $packet) : void\n    {\n        socket_sendto($this->socket, $packet, strlen($packet), 0, $this->host, $this->port);\n    }\n    private function submitFragmented(Segment $segment) : void\n    {\n        $rawSegment = $segment->jsonSerialize();\n        \/** @var Segment[] $subsegments *\/\n        $subsegments = $rawSegment['subsegments'] ?? [];\n        unset($rawSegment['subsegments']);\n        $this->submitOpenSegment($rawSegment);\n        foreach ($subsegments as $subsegment) {\n            $subsegment = clone $subsegment;\n            $subsegment->setParentId($segment->getId())->setTraceId($segment->getTraceId())->setIndependent(true);\n            $this->submitSegment($subsegment);\n        }\n        $completePacket = $this->buildPacket($rawSegment);\n        $this->sendPacket($completePacket);\n    }\n    \/**\n     * @param array<string, mixed> $openSegment\n     *\/\n    private function submitOpenSegment(array $openSegment) : void\n    {\n        unset($openSegment['end_time']);\n        $openSegment['in_progress'] = true;\n        $this->sendPacket($this->buildPacket($openSegment));\n    }\n}","mutatedSourceCode":"<?php\n\nnamespace Fido\\PHPXray\\Submission;\n\nuse Error;\nuse Fido\\PHPXray\\Segment;\nuse Socket;\nuse function socket_create;\nuse function socket_last_error;\nclass DaemonSegmentSubmitter implements SegmentSubmitter\n{\n    protected const MAX_SEGMENT_SIZE = 64000;\n    \/**\n     * @var array<string, mixed>\n     *\/\n    public const HEADER = ['format' => 'json', 'version' => 1];\n    private string $host;\n    private int $port;\n    \/** @var Socket *\/\n    private $socket;\n    public function __construct(string $host = '127.0.0.1', int $port = 2000)\n    {\n        if (isset($_SERVER['AWS_XRAY_DAEMON_ADDRESS'])) {\n            [$host, $port] = explode(\":\", $_SERVER['AWS_XRAY_DAEMON_ADDRESS']);\n        }\n        $this->host = $_SERVER['_AWS_XRAY_DAEMON_ADDRESS'] ?? $host;\n        $this->port = (int) ($_SERVER['_AWS_XRAY_DAEMON_PORT'] ?? $port);\n        if (!($socket = socket_create(AF_INET, SOCK_DGRAM, SOL_UDP))) {\n            throw new Error('Can\\'t create socket: ' . socket_last_error());\n        }\n        $this->socket = $socket;\n    }\n    public function __destruct()\n    {\n        socket_close($this->socket);\n    }\n    public function submitSegment(Segment $segment) : void\n    {\n        $packet = $this->buildPacket($segment);\n        $packetLength = strlen($packet);\n        if ($packetLength >= self::MAX_SEGMENT_SIZE) {\n            $this->submitFragmented($segment);\n            return;\n        }\n        $this->sendPacket($packet);\n    }\n    \/**\n     * @param Segment|array<string, mixed> $segment\n     *\/\n    private function buildPacket(Segment|array $segment) : string\n    {\n        return implode(\"\\n\", array_map('json_encode', [self::HEADER, $segment]));\n    }\n    private function sendPacket(string $packet) : void\n    {\n        socket_sendto($this->socket, $packet, strlen($packet), 0, $this->host, $this->port);\n    }\n    private function submitFragmented(Segment $segment) : void\n    {\n        $rawSegment = $segment->jsonSerialize();\n        \/** @var Segment[] $subsegments *\/\n        $subsegments = $rawSegment['subsegments'] ?? [];\n        unset($rawSegment['subsegments']);\n        $this->submitOpenSegment($rawSegment);\n        foreach ($subsegments as $subsegment) {\n            $subsegment = clone $subsegment;\n            $subsegment->setParentId($segment->getId())->setTraceId($segment->getTraceId())->setIndependent(true);\n            $this->submitSegment($subsegment);\n        }\n        $completePacket = $this->buildPacket($rawSegment);\n        $this->sendPacket($completePacket);\n    }\n    \/**\n     * @param array<string, mixed> $openSegment\n     *\/\n    private function submitOpenSegment(array $openSegment) : void\n    {\n        unset($openSegment['end_time']);\n        $openSegment['in_progress'] = true;\n        $this->sendPacket($this->buildPacket($openSegment));\n    }\n}","originalFilePath":"\/home\/ranpafin\/php-xray\/src\/Submission\/DaemonSegmentSubmitter.php","originalStartLine":53},"diff":"--- Original\n+++ New\n@@ @@\n     {\n         $packet = $this->buildPacket($segment);\n         $packetLength = strlen($packet);\n-        if ($packetLength > self::MAX_SEGMENT_SIZE) {\n+        if ($packetLength >= self::MAX_SEGMENT_SIZE) {\n             $this->submitFragmented($segment);\n             return;\n         }","processOutput":"PHPUnit 9.5.10 by Sebastian Bergmann and contributors.\n\nRuntime:       PHP 8.0.13\nConfiguration: \/tmp\/tmp-folder\/infection\/phpunitConfiguration.5305b0d4b557861fcac249a89ccf0c65.infection.xml\n\nE\n\nTime: 00:00.002, Memory: 8.00 MB\n\nThere was 1 error:\n\n1) Fido\\PHPXray\\DaemonSegmentSubmitterTest::testSubmitsToDaemon\nsocket_bind(): Unable to bind address [98]: Address already in use\n\n\/home\/ranpafin\/php-xray\/tests\/DaemonSegmentSubmitterTest.php:18\n\nERRORS!\nTests: 1, Assertions: 0, Errors: 1."},{"mutator":{"mutatorName":"GreaterThanNegotiation","originalSourceCode":"<?php\n\nnamespace Fido\\PHPXray\\Submission;\n\nuse Error;\nuse Fido\\PHPXray\\Segment;\nuse Socket;\nuse function socket_create;\nuse function socket_last_error;\nclass DaemonSegmentSubmitter implements SegmentSubmitter\n{\n    protected const MAX_SEGMENT_SIZE = 64000;\n    \/**\n     * @var array<string, mixed>\n     *\/\n    public const HEADER = ['format' => 'json', 'version' => 1];\n    private string $host;\n    private int $port;\n    \/** @var Socket *\/\n    private $socket;\n    public function __construct(string $host = '127.0.0.1', int $port = 2000)\n    {\n        if (isset($_SERVER['AWS_XRAY_DAEMON_ADDRESS'])) {\n            [$host, $port] = explode(\":\", $_SERVER['AWS_XRAY_DAEMON_ADDRESS']);\n        }\n        $this->host = $_SERVER['_AWS_XRAY_DAEMON_ADDRESS'] ?? $host;\n        $this->port = (int) ($_SERVER['_AWS_XRAY_DAEMON_PORT'] ?? $port);\n        if (!($socket = socket_create(AF_INET, SOCK_DGRAM, SOL_UDP))) {\n            throw new Error('Can\\'t create socket: ' . socket_last_error());\n        }\n        $this->socket = $socket;\n    }\n    public function __destruct()\n    {\n        socket_close($this->socket);\n    }\n    public function submitSegment(Segment $segment) : void\n    {\n        $packet = $this->buildPacket($segment);\n        $packetLength = strlen($packet);\n        if ($packetLength > self::MAX_SEGMENT_SIZE) {\n            $this->submitFragmented($segment);\n            return;\n        }\n        $this->sendPacket($packet);\n    }\n    \/**\n     * @param Segment|array<string, mixed> $segment\n     *\/\n    private function buildPacket(Segment|array $segment) : string\n    {\n        return implode(\"\\n\", array_map('json_encode', [self::HEADER, $segment]));\n    }\n    private function sendPacket(string $packet) : void\n    {\n        socket_sendto($this->socket, $packet, strlen($packet), 0, $this->host, $this->port);\n    }\n    private function submitFragmented(Segment $segment) : void\n    {\n        $rawSegment = $segment->jsonSerialize();\n        \/** @var Segment[] $subsegments *\/\n        $subsegments = $rawSegment['subsegments'] ?? [];\n        unset($rawSegment['subsegments']);\n        $this->submitOpenSegment($rawSegment);\n        foreach ($subsegments as $subsegment) {\n            $subsegment = clone $subsegment;\n            $subsegment->setParentId($segment->getId())->setTraceId($segment->getTraceId())->setIndependent(true);\n            $this->submitSegment($subsegment);\n        }\n        $completePacket = $this->buildPacket($rawSegment);\n        $this->sendPacket($completePacket);\n    }\n    \/**\n     * @param array<string, mixed> $openSegment\n     *\/\n    private function submitOpenSegment(array $openSegment) : void\n    {\n        unset($openSegment['end_time']);\n        $openSegment['in_progress'] = true;\n        $this->sendPacket($this->buildPacket($openSegment));\n    }\n}","mutatedSourceCode":"<?php\n\nnamespace Fido\\PHPXray\\Submission;\n\nuse Error;\nuse Fido\\PHPXray\\Segment;\nuse Socket;\nuse function socket_create;\nuse function socket_last_error;\nclass DaemonSegmentSubmitter implements SegmentSubmitter\n{\n    protected const MAX_SEGMENT_SIZE = 64000;\n    \/**\n     * @var array<string, mixed>\n     *\/\n    public const HEADER = ['format' => 'json', 'version' => 1];\n    private string $host;\n    private int $port;\n    \/** @var Socket *\/\n    private $socket;\n    public function __construct(string $host = '127.0.0.1', int $port = 2000)\n    {\n        if (isset($_SERVER['AWS_XRAY_DAEMON_ADDRESS'])) {\n            [$host, $port] = explode(\":\", $_SERVER['AWS_XRAY_DAEMON_ADDRESS']);\n        }\n        $this->host = $_SERVER['_AWS_XRAY_DAEMON_ADDRESS'] ?? $host;\n        $this->port = (int) ($_SERVER['_AWS_XRAY_DAEMON_PORT'] ?? $port);\n        if (!($socket = socket_create(AF_INET, SOCK_DGRAM, SOL_UDP))) {\n            throw new Error('Can\\'t create socket: ' . socket_last_error());\n        }\n        $this->socket = $socket;\n    }\n    public function __destruct()\n    {\n        socket_close($this->socket);\n    }\n    public function submitSegment(Segment $segment) : void\n    {\n        $packet = $this->buildPacket($segment);\n        $packetLength = strlen($packet);\n        if ($packetLength <= self::MAX_SEGMENT_SIZE) {\n            $this->submitFragmented($segment);\n            return;\n        }\n        $this->sendPacket($packet);\n    }\n    \/**\n     * @param Segment|array<string, mixed> $segment\n     *\/\n    private function buildPacket(Segment|array $segment) : string\n    {\n        return implode(\"\\n\", array_map('json_encode', [self::HEADER, $segment]));\n    }\n    private function sendPacket(string $packet) : void\n    {\n        socket_sendto($this->socket, $packet, strlen($packet), 0, $this->host, $this->port);\n    }\n    private function submitFragmented(Segment $segment) : void\n    {\n        $rawSegment = $segment->jsonSerialize();\n        \/** @var Segment[] $subsegments *\/\n        $subsegments = $rawSegment['subsegments'] ?? [];\n        unset($rawSegment['subsegments']);\n        $this->submitOpenSegment($rawSegment);\n        foreach ($subsegments as $subsegment) {\n            $subsegment = clone $subsegment;\n            $subsegment->setParentId($segment->getId())->setTraceId($segment->getTraceId())->setIndependent(true);\n            $this->submitSegment($subsegment);\n        }\n        $completePacket = $this->buildPacket($rawSegment);\n        $this->sendPacket($completePacket);\n    }\n    \/**\n     * @param array<string, mixed> $openSegment\n     *\/\n    private function submitOpenSegment(array $openSegment) : void\n    {\n        unset($openSegment['end_time']);\n        $openSegment['in_progress'] = true;\n        $this->sendPacket($this->buildPacket($openSegment));\n    }\n}","originalFilePath":"\/home\/ranpafin\/php-xray\/src\/Submission\/DaemonSegmentSubmitter.php","originalStartLine":53},"diff":"--- Original\n+++ New\n@@ @@\n     {\n         $packet = $this->buildPacket($segment);\n         $packetLength = strlen($packet);\n-        if ($packetLength > self::MAX_SEGMENT_SIZE) {\n+        if ($packetLength <= self::MAX_SEGMENT_SIZE) {\n             $this->submitFragmented($segment);\n             return;\n         }","processOutput":"PHPUnit 9.5.10 by Sebastian Bergmann and contributors.\n\nRuntime:       PHP 8.0.13\nConfiguration: \/tmp\/tmp-folder\/infection\/phpunitConfiguration.35495e8f46960bb45b61e1fdfc5fd305.infection.xml\n\nE\n\nTime: 00:00.003, Memory: 8.00 MB\n\nThere was 1 error:\n\n1) Fido\\PHPXray\\DaemonSegmentSubmitterTest::testSubmitsToDaemon\nsocket_bind(): Unable to bind address [98]: Address already in use\n\n\/home\/ranpafin\/php-xray\/tests\/DaemonSegmentSubmitterTest.php:18\n\nERRORS!\nTests: 1, Assertions: 0, Errors: 1."},{"mutator":{"mutatorName":"MethodCallRemoval","originalSourceCode":"<?php\n\nnamespace Fido\\PHPXray\\Submission;\n\nuse Error;\nuse Fido\\PHPXray\\Segment;\nuse Socket;\nuse function socket_create;\nuse function socket_last_error;\nclass DaemonSegmentSubmitter implements SegmentSubmitter\n{\n    protected const MAX_SEGMENT_SIZE = 64000;\n    \/**\n     * @var array<string, mixed>\n     *\/\n    public const HEADER = ['format' => 'json', 'version' => 1];\n    private string $host;\n    private int $port;\n    \/** @var Socket *\/\n    private $socket;\n    public function __construct(string $host = '127.0.0.1', int $port = 2000)\n    {\n        if (isset($_SERVER['AWS_XRAY_DAEMON_ADDRESS'])) {\n            [$host, $port] = explode(\":\", $_SERVER['AWS_XRAY_DAEMON_ADDRESS']);\n        }\n        $this->host = $_SERVER['_AWS_XRAY_DAEMON_ADDRESS'] ?? $host;\n        $this->port = (int) ($_SERVER['_AWS_XRAY_DAEMON_PORT'] ?? $port);\n        if (!($socket = socket_create(AF_INET, SOCK_DGRAM, SOL_UDP))) {\n            throw new Error('Can\\'t create socket: ' . socket_last_error());\n        }\n        $this->socket = $socket;\n    }\n    public function __destruct()\n    {\n        socket_close($this->socket);\n    }\n    public function submitSegment(Segment $segment) : void\n    {\n        $packet = $this->buildPacket($segment);\n        $packetLength = strlen($packet);\n        if ($packetLength > self::MAX_SEGMENT_SIZE) {\n            $this->submitFragmented($segment);\n            return;\n        }\n        $this->sendPacket($packet);\n    }\n    \/**\n     * @param Segment|array<string, mixed> $segment\n     *\/\n    private function buildPacket(Segment|array $segment) : string\n    {\n        return implode(\"\\n\", array_map('json_encode', [self::HEADER, $segment]));\n    }\n    private function sendPacket(string $packet) : void\n    {\n        socket_sendto($this->socket, $packet, strlen($packet), 0, $this->host, $this->port);\n    }\n    private function submitFragmented(Segment $segment) : void\n    {\n        $rawSegment = $segment->jsonSerialize();\n        \/** @var Segment[] $subsegments *\/\n        $subsegments = $rawSegment['subsegments'] ?? [];\n        unset($rawSegment['subsegments']);\n        $this->submitOpenSegment($rawSegment);\n        foreach ($subsegments as $subsegment) {\n            $subsegment = clone $subsegment;\n            $subsegment->setParentId($segment->getId())->setTraceId($segment->getTraceId())->setIndependent(true);\n            $this->submitSegment($subsegment);\n        }\n        $completePacket = $this->buildPacket($rawSegment);\n        $this->sendPacket($completePacket);\n    }\n    \/**\n     * @param array<string, mixed> $openSegment\n     *\/\n    private function submitOpenSegment(array $openSegment) : void\n    {\n        unset($openSegment['end_time']);\n        $openSegment['in_progress'] = true;\n        $this->sendPacket($this->buildPacket($openSegment));\n    }\n}","mutatedSourceCode":"<?php\n\nnamespace Fido\\PHPXray\\Submission;\n\nuse Error;\nuse Fido\\PHPXray\\Segment;\nuse Socket;\nuse function socket_create;\nuse function socket_last_error;\nclass DaemonSegmentSubmitter implements SegmentSubmitter\n{\n    protected const MAX_SEGMENT_SIZE = 64000;\n    \/**\n     * @var array<string, mixed>\n     *\/\n    public const HEADER = ['format' => 'json', 'version' => 1];\n    private string $host;\n    private int $port;\n    \/** @var Socket *\/\n    private $socket;\n    public function __construct(string $host = '127.0.0.1', int $port = 2000)\n    {\n        if (isset($_SERVER['AWS_XRAY_DAEMON_ADDRESS'])) {\n            [$host, $port] = explode(\":\", $_SERVER['AWS_XRAY_DAEMON_ADDRESS']);\n        }\n        $this->host = $_SERVER['_AWS_XRAY_DAEMON_ADDRESS'] ?? $host;\n        $this->port = (int) ($_SERVER['_AWS_XRAY_DAEMON_PORT'] ?? $port);\n        if (!($socket = socket_create(AF_INET, SOCK_DGRAM, SOL_UDP))) {\n            throw new Error('Can\\'t create socket: ' . socket_last_error());\n        }\n        $this->socket = $socket;\n    }\n    public function __destruct()\n    {\n        socket_close($this->socket);\n    }\n    public function submitSegment(Segment $segment) : void\n    {\n        $packet = $this->buildPacket($segment);\n        $packetLength = strlen($packet);\n        if ($packetLength > self::MAX_SEGMENT_SIZE) {\n            \n            return;\n        }\n        $this->sendPacket($packet);\n    }\n    \/**\n     * @param Segment|array<string, mixed> $segment\n     *\/\n    private function buildPacket(Segment|array $segment) : string\n    {\n        return implode(\"\\n\", array_map('json_encode', [self::HEADER, $segment]));\n    }\n    private function sendPacket(string $packet) : void\n    {\n        socket_sendto($this->socket, $packet, strlen($packet), 0, $this->host, $this->port);\n    }\n    private function submitFragmented(Segment $segment) : void\n    {\n        $rawSegment = $segment->jsonSerialize();\n        \/** @var Segment[] $subsegments *\/\n        $subsegments = $rawSegment['subsegments'] ?? [];\n        unset($rawSegment['subsegments']);\n        $this->submitOpenSegment($rawSegment);\n        foreach ($subsegments as $subsegment) {\n            $subsegment = clone $subsegment;\n            $subsegment->setParentId($segment->getId())->setTraceId($segment->getTraceId())->setIndependent(true);\n            $this->submitSegment($subsegment);\n        }\n        $completePacket = $this->buildPacket($rawSegment);\n        $this->sendPacket($completePacket);\n    }\n    \/**\n     * @param array<string, mixed> $openSegment\n     *\/\n    private function submitOpenSegment(array $openSegment) : void\n    {\n        unset($openSegment['end_time']);\n        $openSegment['in_progress'] = true;\n        $this->sendPacket($this->buildPacket($openSegment));\n    }\n}","originalFilePath":"\/home\/ranpafin\/php-xray\/src\/Submission\/DaemonSegmentSubmitter.php","originalStartLine":54},"diff":"--- Original\n+++ New\n@@ @@\n         $packet = $this->buildPacket($segment);\n         $packetLength = strlen($packet);\n         if ($packetLength > self::MAX_SEGMENT_SIZE) {\n-            $this->submitFragmented($segment);\n+            \n             return;\n         }\n         $this->sendPacket($packet);","processOutput":"PHPUnit 9.5.10 by Sebastian Bergmann and contributors.\n\nRuntime:       PHP 8.0.13\nConfiguration: \/tmp\/tmp-folder\/infection\/phpunitConfiguration.8cb58dcfade9419eec88b8aec3eccc17.infection.xml\n\nE\n\nTime: 00:00.002, Memory: 8.00 MB\n\nThere was 1 error:\n\n1) Fido\\PHPXray\\DaemonSegmentSubmitterTest::testSubmitsToDaemon\nsocket_bind(): Unable to bind address [98]: Address already in use\n\n\/home\/ranpafin\/php-xray\/tests\/DaemonSegmentSubmitterTest.php:18\n\nERRORS!\nTests: 1, Assertions: 0, Errors: 1."},{"mutator":{"mutatorName":"MethodCallRemoval","originalSourceCode":"<?php\n\nnamespace Fido\\PHPXray\\Submission;\n\nuse Error;\nuse Fido\\PHPXray\\Segment;\nuse Socket;\nuse function socket_create;\nuse function socket_last_error;\nclass DaemonSegmentSubmitter implements SegmentSubmitter\n{\n    protected const MAX_SEGMENT_SIZE = 64000;\n    \/**\n     * @var array<string, mixed>\n     *\/\n    public const HEADER = ['format' => 'json', 'version' => 1];\n    private string $host;\n    private int $port;\n    \/** @var Socket *\/\n    private $socket;\n    public function __construct(string $host = '127.0.0.1', int $port = 2000)\n    {\n        if (isset($_SERVER['AWS_XRAY_DAEMON_ADDRESS'])) {\n            [$host, $port] = explode(\":\", $_SERVER['AWS_XRAY_DAEMON_ADDRESS']);\n        }\n        $this->host = $_SERVER['_AWS_XRAY_DAEMON_ADDRESS'] ?? $host;\n        $this->port = (int) ($_SERVER['_AWS_XRAY_DAEMON_PORT'] ?? $port);\n        if (!($socket = socket_create(AF_INET, SOCK_DGRAM, SOL_UDP))) {\n            throw new Error('Can\\'t create socket: ' . socket_last_error());\n        }\n        $this->socket = $socket;\n    }\n    public function __destruct()\n    {\n        socket_close($this->socket);\n    }\n    public function submitSegment(Segment $segment) : void\n    {\n        $packet = $this->buildPacket($segment);\n        $packetLength = strlen($packet);\n        if ($packetLength > self::MAX_SEGMENT_SIZE) {\n            $this->submitFragmented($segment);\n            return;\n        }\n        $this->sendPacket($packet);\n    }\n    \/**\n     * @param Segment|array<string, mixed> $segment\n     *\/\n    private function buildPacket(Segment|array $segment) : string\n    {\n        return implode(\"\\n\", array_map('json_encode', [self::HEADER, $segment]));\n    }\n    private function sendPacket(string $packet) : void\n    {\n        socket_sendto($this->socket, $packet, strlen($packet), 0, $this->host, $this->port);\n    }\n    private function submitFragmented(Segment $segment) : void\n    {\n        $rawSegment = $segment->jsonSerialize();\n        \/** @var Segment[] $subsegments *\/\n        $subsegments = $rawSegment['subsegments'] ?? [];\n        unset($rawSegment['subsegments']);\n        $this->submitOpenSegment($rawSegment);\n        foreach ($subsegments as $subsegment) {\n            $subsegment = clone $subsegment;\n            $subsegment->setParentId($segment->getId())->setTraceId($segment->getTraceId())->setIndependent(true);\n            $this->submitSegment($subsegment);\n        }\n        $completePacket = $this->buildPacket($rawSegment);\n        $this->sendPacket($completePacket);\n    }\n    \/**\n     * @param array<string, mixed> $openSegment\n     *\/\n    private function submitOpenSegment(array $openSegment) : void\n    {\n        unset($openSegment['end_time']);\n        $openSegment['in_progress'] = true;\n        $this->sendPacket($this->buildPacket($openSegment));\n    }\n}","mutatedSourceCode":"<?php\n\nnamespace Fido\\PHPXray\\Submission;\n\nuse Error;\nuse Fido\\PHPXray\\Segment;\nuse Socket;\nuse function socket_create;\nuse function socket_last_error;\nclass DaemonSegmentSubmitter implements SegmentSubmitter\n{\n    protected const MAX_SEGMENT_SIZE = 64000;\n    \/**\n     * @var array<string, mixed>\n     *\/\n    public const HEADER = ['format' => 'json', 'version' => 1];\n    private string $host;\n    private int $port;\n    \/** @var Socket *\/\n    private $socket;\n    public function __construct(string $host = '127.0.0.1', int $port = 2000)\n    {\n        if (isset($_SERVER['AWS_XRAY_DAEMON_ADDRESS'])) {\n            [$host, $port] = explode(\":\", $_SERVER['AWS_XRAY_DAEMON_ADDRESS']);\n        }\n        $this->host = $_SERVER['_AWS_XRAY_DAEMON_ADDRESS'] ?? $host;\n        $this->port = (int) ($_SERVER['_AWS_XRAY_DAEMON_PORT'] ?? $port);\n        if (!($socket = socket_create(AF_INET, SOCK_DGRAM, SOL_UDP))) {\n            throw new Error('Can\\'t create socket: ' . socket_last_error());\n        }\n        $this->socket = $socket;\n    }\n    public function __destruct()\n    {\n        socket_close($this->socket);\n    }\n    public function submitSegment(Segment $segment) : void\n    {\n        $packet = $this->buildPacket($segment);\n        $packetLength = strlen($packet);\n        if ($packetLength > self::MAX_SEGMENT_SIZE) {\n            $this->submitFragmented($segment);\n            return;\n        }\n        \n    }\n    \/**\n     * @param Segment|array<string, mixed> $segment\n     *\/\n    private function buildPacket(Segment|array $segment) : string\n    {\n        return implode(\"\\n\", array_map('json_encode', [self::HEADER, $segment]));\n    }\n    private function sendPacket(string $packet) : void\n    {\n        socket_sendto($this->socket, $packet, strlen($packet), 0, $this->host, $this->port);\n    }\n    private function submitFragmented(Segment $segment) : void\n    {\n        $rawSegment = $segment->jsonSerialize();\n        \/** @var Segment[] $subsegments *\/\n        $subsegments = $rawSegment['subsegments'] ?? [];\n        unset($rawSegment['subsegments']);\n        $this->submitOpenSegment($rawSegment);\n        foreach ($subsegments as $subsegment) {\n            $subsegment = clone $subsegment;\n            $subsegment->setParentId($segment->getId())->setTraceId($segment->getTraceId())->setIndependent(true);\n            $this->submitSegment($subsegment);\n        }\n        $completePacket = $this->buildPacket($rawSegment);\n        $this->sendPacket($completePacket);\n    }\n    \/**\n     * @param array<string, mixed> $openSegment\n     *\/\n    private function submitOpenSegment(array $openSegment) : void\n    {\n        unset($openSegment['end_time']);\n        $openSegment['in_progress'] = true;\n        $this->sendPacket($this->buildPacket($openSegment));\n    }\n}","originalFilePath":"\/home\/ranpafin\/php-xray\/src\/Submission\/DaemonSegmentSubmitter.php","originalStartLine":58},"diff":"--- Original\n+++ New\n@@ @@\n             $this->submitFragmented($segment);\n             return;\n         }\n-        $this->sendPacket($packet);\n+        \n     }\n     \/**\n      * @param Segment|array<string, mixed> $segment","processOutput":"PHPUnit 9.5.10 by Sebastian Bergmann and contributors.\n\nRuntime:       PHP 8.0.13\nConfiguration: \/tmp\/tmp-folder\/infection\/phpunitConfiguration.afe3c6f276ac817191752075880b62e0.infection.xml\n\nE\n\nTime: 00:00.003, Memory: 8.00 MB\n\nThere was 1 error:\n\n1) Fido\\PHPXray\\DaemonSegmentSubmitterTest::testSubmitsToDaemon\nsocket_bind(): Unable to bind address [98]: Address already in use\n\n\/home\/ranpafin\/php-xray\/tests\/DaemonSegmentSubmitterTest.php:18\n\nERRORS!\nTests: 1, Assertions: 0, Errors: 1."},{"mutator":{"mutatorName":"ArrayItemRemoval","originalSourceCode":"<?php\n\nnamespace Fido\\PHPXray\\Submission;\n\nuse Error;\nuse Fido\\PHPXray\\Segment;\nuse Socket;\nuse function socket_create;\nuse function socket_last_error;\nclass DaemonSegmentSubmitter implements SegmentSubmitter\n{\n    protected const MAX_SEGMENT_SIZE = 64000;\n    \/**\n     * @var array<string, mixed>\n     *\/\n    public const HEADER = ['format' => 'json', 'version' => 1];\n    private string $host;\n    private int $port;\n    \/** @var Socket *\/\n    private $socket;\n    public function __construct(string $host = '127.0.0.1', int $port = 2000)\n    {\n        if (isset($_SERVER['AWS_XRAY_DAEMON_ADDRESS'])) {\n            [$host, $port] = explode(\":\", $_SERVER['AWS_XRAY_DAEMON_ADDRESS']);\n        }\n        $this->host = $_SERVER['_AWS_XRAY_DAEMON_ADDRESS'] ?? $host;\n        $this->port = (int) ($_SERVER['_AWS_XRAY_DAEMON_PORT'] ?? $port);\n        if (!($socket = socket_create(AF_INET, SOCK_DGRAM, SOL_UDP))) {\n            throw new Error('Can\\'t create socket: ' . socket_last_error());\n        }\n        $this->socket = $socket;\n    }\n    public function __destruct()\n    {\n        socket_close($this->socket);\n    }\n    public function submitSegment(Segment $segment) : void\n    {\n        $packet = $this->buildPacket($segment);\n        $packetLength = strlen($packet);\n        if ($packetLength > self::MAX_SEGMENT_SIZE) {\n            $this->submitFragmented($segment);\n            return;\n        }\n        $this->sendPacket($packet);\n    }\n    \/**\n     * @param Segment|array<string, mixed> $segment\n     *\/\n    private function buildPacket(Segment|array $segment) : string\n    {\n        return implode(\"\\n\", array_map('json_encode', [self::HEADER, $segment]));\n    }\n    private function sendPacket(string $packet) : void\n    {\n        socket_sendto($this->socket, $packet, strlen($packet), 0, $this->host, $this->port);\n    }\n    private function submitFragmented(Segment $segment) : void\n    {\n        $rawSegment = $segment->jsonSerialize();\n        \/** @var Segment[] $subsegments *\/\n        $subsegments = $rawSegment['subsegments'] ?? [];\n        unset($rawSegment['subsegments']);\n        $this->submitOpenSegment($rawSegment);\n        foreach ($subsegments as $subsegment) {\n            $subsegment = clone $subsegment;\n            $subsegment->setParentId($segment->getId())->setTraceId($segment->getTraceId())->setIndependent(true);\n            $this->submitSegment($subsegment);\n        }\n        $completePacket = $this->buildPacket($rawSegment);\n        $this->sendPacket($completePacket);\n    }\n    \/**\n     * @param array<string, mixed> $openSegment\n     *\/\n    private function submitOpenSegment(array $openSegment) : void\n    {\n        unset($openSegment['end_time']);\n        $openSegment['in_progress'] = true;\n        $this->sendPacket($this->buildPacket($openSegment));\n    }\n}","mutatedSourceCode":"<?php\n\nnamespace Fido\\PHPXray\\Submission;\n\nuse Error;\nuse Fido\\PHPXray\\Segment;\nuse Socket;\nuse function socket_create;\nuse function socket_last_error;\nclass DaemonSegmentSubmitter implements SegmentSubmitter\n{\n    protected const MAX_SEGMENT_SIZE = 64000;\n    \/**\n     * @var array<string, mixed>\n     *\/\n    public const HEADER = ['format' => 'json', 'version' => 1];\n    private string $host;\n    private int $port;\n    \/** @var Socket *\/\n    private $socket;\n    public function __construct(string $host = '127.0.0.1', int $port = 2000)\n    {\n        if (isset($_SERVER['AWS_XRAY_DAEMON_ADDRESS'])) {\n            [$host, $port] = explode(\":\", $_SERVER['AWS_XRAY_DAEMON_ADDRESS']);\n        }\n        $this->host = $_SERVER['_AWS_XRAY_DAEMON_ADDRESS'] ?? $host;\n        $this->port = (int) ($_SERVER['_AWS_XRAY_DAEMON_PORT'] ?? $port);\n        if (!($socket = socket_create(AF_INET, SOCK_DGRAM, SOL_UDP))) {\n            throw new Error('Can\\'t create socket: ' . socket_last_error());\n        }\n        $this->socket = $socket;\n    }\n    public function __destruct()\n    {\n        socket_close($this->socket);\n    }\n    public function submitSegment(Segment $segment) : void\n    {\n        $packet = $this->buildPacket($segment);\n        $packetLength = strlen($packet);\n        if ($packetLength > self::MAX_SEGMENT_SIZE) {\n            $this->submitFragmented($segment);\n            return;\n        }\n        $this->sendPacket($packet);\n    }\n    \/**\n     * @param Segment|array<string, mixed> $segment\n     *\/\n    private function buildPacket(Segment|array $segment) : string\n    {\n        return implode(\"\\n\", array_map('json_encode', [$segment]));\n    }\n    private function sendPacket(string $packet) : void\n    {\n        socket_sendto($this->socket, $packet, strlen($packet), 0, $this->host, $this->port);\n    }\n    private function submitFragmented(Segment $segment) : void\n    {\n        $rawSegment = $segment->jsonSerialize();\n        \/** @var Segment[] $subsegments *\/\n        $subsegments = $rawSegment['subsegments'] ?? [];\n        unset($rawSegment['subsegments']);\n        $this->submitOpenSegment($rawSegment);\n        foreach ($subsegments as $subsegment) {\n            $subsegment = clone $subsegment;\n            $subsegment->setParentId($segment->getId())->setTraceId($segment->getTraceId())->setIndependent(true);\n            $this->submitSegment($subsegment);\n        }\n        $completePacket = $this->buildPacket($rawSegment);\n        $this->sendPacket($completePacket);\n    }\n    \/**\n     * @param array<string, mixed> $openSegment\n     *\/\n    private function submitOpenSegment(array $openSegment) : void\n    {\n        unset($openSegment['end_time']);\n        $openSegment['in_progress'] = true;\n        $this->sendPacket($this->buildPacket($openSegment));\n    }\n}","originalFilePath":"\/home\/ranpafin\/php-xray\/src\/Submission\/DaemonSegmentSubmitter.php","originalStartLine":66},"diff":"--- Original\n+++ New\n@@ @@\n      *\/\n     private function buildPacket(Segment|array $segment) : string\n     {\n-        return implode(\"\\n\", array_map('json_encode', [self::HEADER, $segment]));\n+        return implode(\"\\n\", array_map('json_encode', [$segment]));\n     }\n     private function sendPacket(string $packet) : void\n     {","processOutput":"PHPUnit 9.5.10 by Sebastian Bergmann and contributors.\n\nRuntime:       PHP 8.0.13\nConfiguration: \/tmp\/tmp-folder\/infection\/phpunitConfiguration.3016860002ee620669c2229ef9d5e4f5.infection.xml\n\nE\n\nTime: 00:00.003, Memory: 8.00 MB\n\nThere was 1 error:\n\n1) Fido\\PHPXray\\DaemonSegmentSubmitterTest::testSubmitsToDaemon\nsocket_bind(): Unable to bind address [98]: Address already in use\n\n\/home\/ranpafin\/php-xray\/tests\/DaemonSegmentSubmitterTest.php:18\n\nERRORS!\nTests: 1, Assertions: 0, Errors: 1."},{"mutator":{"mutatorName":"UnwrapArrayMap","originalSourceCode":"<?php\n\nnamespace Fido\\PHPXray\\Submission;\n\nuse Error;\nuse Fido\\PHPXray\\Segment;\nuse Socket;\nuse function socket_create;\nuse function socket_last_error;\nclass DaemonSegmentSubmitter implements SegmentSubmitter\n{\n    protected const MAX_SEGMENT_SIZE = 64000;\n    \/**\n     * @var array<string, mixed>\n     *\/\n    public const HEADER = ['format' => 'json', 'version' => 1];\n    private string $host;\n    private int $port;\n    \/** @var Socket *\/\n    private $socket;\n    public function __construct(string $host = '127.0.0.1', int $port = 2000)\n    {\n        if (isset($_SERVER['AWS_XRAY_DAEMON_ADDRESS'])) {\n            [$host, $port] = explode(\":\", $_SERVER['AWS_XRAY_DAEMON_ADDRESS']);\n        }\n        $this->host = $_SERVER['_AWS_XRAY_DAEMON_ADDRESS'] ?? $host;\n        $this->port = (int) ($_SERVER['_AWS_XRAY_DAEMON_PORT'] ?? $port);\n        if (!($socket = socket_create(AF_INET, SOCK_DGRAM, SOL_UDP))) {\n            throw new Error('Can\\'t create socket: ' . socket_last_error());\n        }\n        $this->socket = $socket;\n    }\n    public function __destruct()\n    {\n        socket_close($this->socket);\n    }\n    public function submitSegment(Segment $segment) : void\n    {\n        $packet = $this->buildPacket($segment);\n        $packetLength = strlen($packet);\n        if ($packetLength > self::MAX_SEGMENT_SIZE) {\n            $this->submitFragmented($segment);\n            return;\n        }\n        $this->sendPacket($packet);\n    }\n    \/**\n     * @param Segment|array<string, mixed> $segment\n     *\/\n    private function buildPacket(Segment|array $segment) : string\n    {\n        return implode(\"\\n\", array_map('json_encode', [self::HEADER, $segment]));\n    }\n    private function sendPacket(string $packet) : void\n    {\n        socket_sendto($this->socket, $packet, strlen($packet), 0, $this->host, $this->port);\n    }\n    private function submitFragmented(Segment $segment) : void\n    {\n        $rawSegment = $segment->jsonSerialize();\n        \/** @var Segment[] $subsegments *\/\n        $subsegments = $rawSegment['subsegments'] ?? [];\n        unset($rawSegment['subsegments']);\n        $this->submitOpenSegment($rawSegment);\n        foreach ($subsegments as $subsegment) {\n            $subsegment = clone $subsegment;\n            $subsegment->setParentId($segment->getId())->setTraceId($segment->getTraceId())->setIndependent(true);\n            $this->submitSegment($subsegment);\n        }\n        $completePacket = $this->buildPacket($rawSegment);\n        $this->sendPacket($completePacket);\n    }\n    \/**\n     * @param array<string, mixed> $openSegment\n     *\/\n    private function submitOpenSegment(array $openSegment) : void\n    {\n        unset($openSegment['end_time']);\n        $openSegment['in_progress'] = true;\n        $this->sendPacket($this->buildPacket($openSegment));\n    }\n}","mutatedSourceCode":"<?php\n\nnamespace Fido\\PHPXray\\Submission;\n\nuse Error;\nuse Fido\\PHPXray\\Segment;\nuse Socket;\nuse function socket_create;\nuse function socket_last_error;\nclass DaemonSegmentSubmitter implements SegmentSubmitter\n{\n    protected const MAX_SEGMENT_SIZE = 64000;\n    \/**\n     * @var array<string, mixed>\n     *\/\n    public const HEADER = ['format' => 'json', 'version' => 1];\n    private string $host;\n    private int $port;\n    \/** @var Socket *\/\n    private $socket;\n    public function __construct(string $host = '127.0.0.1', int $port = 2000)\n    {\n        if (isset($_SERVER['AWS_XRAY_DAEMON_ADDRESS'])) {\n            [$host, $port] = explode(\":\", $_SERVER['AWS_XRAY_DAEMON_ADDRESS']);\n        }\n        $this->host = $_SERVER['_AWS_XRAY_DAEMON_ADDRESS'] ?? $host;\n        $this->port = (int) ($_SERVER['_AWS_XRAY_DAEMON_PORT'] ?? $port);\n        if (!($socket = socket_create(AF_INET, SOCK_DGRAM, SOL_UDP))) {\n            throw new Error('Can\\'t create socket: ' . socket_last_error());\n        }\n        $this->socket = $socket;\n    }\n    public function __destruct()\n    {\n        socket_close($this->socket);\n    }\n    public function submitSegment(Segment $segment) : void\n    {\n        $packet = $this->buildPacket($segment);\n        $packetLength = strlen($packet);\n        if ($packetLength > self::MAX_SEGMENT_SIZE) {\n            $this->submitFragmented($segment);\n            return;\n        }\n        $this->sendPacket($packet);\n    }\n    \/**\n     * @param Segment|array<string, mixed> $segment\n     *\/\n    private function buildPacket(Segment|array $segment) : string\n    {\n        return implode(\"\\n\", [self::HEADER, $segment]);\n    }\n    private function sendPacket(string $packet) : void\n    {\n        socket_sendto($this->socket, $packet, strlen($packet), 0, $this->host, $this->port);\n    }\n    private function submitFragmented(Segment $segment) : void\n    {\n        $rawSegment = $segment->jsonSerialize();\n        \/** @var Segment[] $subsegments *\/\n        $subsegments = $rawSegment['subsegments'] ?? [];\n        unset($rawSegment['subsegments']);\n        $this->submitOpenSegment($rawSegment);\n        foreach ($subsegments as $subsegment) {\n            $subsegment = clone $subsegment;\n            $subsegment->setParentId($segment->getId())->setTraceId($segment->getTraceId())->setIndependent(true);\n            $this->submitSegment($subsegment);\n        }\n        $completePacket = $this->buildPacket($rawSegment);\n        $this->sendPacket($completePacket);\n    }\n    \/**\n     * @param array<string, mixed> $openSegment\n     *\/\n    private function submitOpenSegment(array $openSegment) : void\n    {\n        unset($openSegment['end_time']);\n        $openSegment['in_progress'] = true;\n        $this->sendPacket($this->buildPacket($openSegment));\n    }\n}","originalFilePath":"\/home\/ranpafin\/php-xray\/src\/Submission\/DaemonSegmentSubmitter.php","originalStartLine":66},"diff":"--- Original\n+++ New\n@@ @@\n      *\/\n     private function buildPacket(Segment|array $segment) : string\n     {\n-        return implode(\"\\n\", array_map('json_encode', [self::HEADER, $segment]));\n+        return implode(\"\\n\", [self::HEADER, $segment]);\n     }\n     private function sendPacket(string $packet) : void\n     {","processOutput":"PHPUnit 9.5.10 by Sebastian Bergmann and contributors.\n\nRuntime:       PHP 8.0.13\nConfiguration: \/tmp\/tmp-folder\/infection\/phpunitConfiguration.f11ad6b8c7d5de53724a384e4472fe5e.infection.xml\n\nE\n\nTime: 00:00.003, Memory: 8.00 MB\n\nThere was 1 error:\n\n1) Fido\\PHPXray\\DaemonSegmentSubmitterTest::testSubmitsToDaemon\nsocket_bind(): Unable to bind address [98]: Address already in use\n\n\/home\/ranpafin\/php-xray\/tests\/DaemonSegmentSubmitterTest.php:18\n\nERRORS!\nTests: 1, Assertions: 0, Errors: 1."},{"mutator":{"mutatorName":"DecrementInteger","originalSourceCode":"<?php\n\nnamespace Fido\\PHPXray\\Submission;\n\nuse Error;\nuse Fido\\PHPXray\\Segment;\nuse Socket;\nuse function socket_create;\nuse function socket_last_error;\nclass DaemonSegmentSubmitter implements SegmentSubmitter\n{\n    protected const MAX_SEGMENT_SIZE = 64000;\n    \/**\n     * @var array<string, mixed>\n     *\/\n    public const HEADER = ['format' => 'json', 'version' => 1];\n    private string $host;\n    private int $port;\n    \/** @var Socket *\/\n    private $socket;\n    public function __construct(string $host = '127.0.0.1', int $port = 2000)\n    {\n        if (isset($_SERVER['AWS_XRAY_DAEMON_ADDRESS'])) {\n            [$host, $port] = explode(\":\", $_SERVER['AWS_XRAY_DAEMON_ADDRESS']);\n        }\n        $this->host = $_SERVER['_AWS_XRAY_DAEMON_ADDRESS'] ?? $host;\n        $this->port = (int) ($_SERVER['_AWS_XRAY_DAEMON_PORT'] ?? $port);\n        if (!($socket = socket_create(AF_INET, SOCK_DGRAM, SOL_UDP))) {\n            throw new Error('Can\\'t create socket: ' . socket_last_error());\n        }\n        $this->socket = $socket;\n    }\n    public function __destruct()\n    {\n        socket_close($this->socket);\n    }\n    public function submitSegment(Segment $segment) : void\n    {\n        $packet = $this->buildPacket($segment);\n        $packetLength = strlen($packet);\n        if ($packetLength > self::MAX_SEGMENT_SIZE) {\n            $this->submitFragmented($segment);\n            return;\n        }\n        $this->sendPacket($packet);\n    }\n    \/**\n     * @param Segment|array<string, mixed> $segment\n     *\/\n    private function buildPacket(Segment|array $segment) : string\n    {\n        return implode(\"\\n\", array_map('json_encode', [self::HEADER, $segment]));\n    }\n    private function sendPacket(string $packet) : void\n    {\n        socket_sendto($this->socket, $packet, strlen($packet), 0, $this->host, $this->port);\n    }\n    private function submitFragmented(Segment $segment) : void\n    {\n        $rawSegment = $segment->jsonSerialize();\n        \/** @var Segment[] $subsegments *\/\n        $subsegments = $rawSegment['subsegments'] ?? [];\n        unset($rawSegment['subsegments']);\n        $this->submitOpenSegment($rawSegment);\n        foreach ($subsegments as $subsegment) {\n            $subsegment = clone $subsegment;\n            $subsegment->setParentId($segment->getId())->setTraceId($segment->getTraceId())->setIndependent(true);\n            $this->submitSegment($subsegment);\n        }\n        $completePacket = $this->buildPacket($rawSegment);\n        $this->sendPacket($completePacket);\n    }\n    \/**\n     * @param array<string, mixed> $openSegment\n     *\/\n    private function submitOpenSegment(array $openSegment) : void\n    {\n        unset($openSegment['end_time']);\n        $openSegment['in_progress'] = true;\n        $this->sendPacket($this->buildPacket($openSegment));\n    }\n}","mutatedSourceCode":"<?php\n\nnamespace Fido\\PHPXray\\Submission;\n\nuse Error;\nuse Fido\\PHPXray\\Segment;\nuse Socket;\nuse function socket_create;\nuse function socket_last_error;\nclass DaemonSegmentSubmitter implements SegmentSubmitter\n{\n    protected const MAX_SEGMENT_SIZE = 64000;\n    \/**\n     * @var array<string, mixed>\n     *\/\n    public const HEADER = ['format' => 'json', 'version' => 1];\n    private string $host;\n    private int $port;\n    \/** @var Socket *\/\n    private $socket;\n    public function __construct(string $host = '127.0.0.1', int $port = 2000)\n    {\n        if (isset($_SERVER['AWS_XRAY_DAEMON_ADDRESS'])) {\n            [$host, $port] = explode(\":\", $_SERVER['AWS_XRAY_DAEMON_ADDRESS']);\n        }\n        $this->host = $_SERVER['_AWS_XRAY_DAEMON_ADDRESS'] ?? $host;\n        $this->port = (int) ($_SERVER['_AWS_XRAY_DAEMON_PORT'] ?? $port);\n        if (!($socket = socket_create(AF_INET, SOCK_DGRAM, SOL_UDP))) {\n            throw new Error('Can\\'t create socket: ' . socket_last_error());\n        }\n        $this->socket = $socket;\n    }\n    public function __destruct()\n    {\n        socket_close($this->socket);\n    }\n    public function submitSegment(Segment $segment) : void\n    {\n        $packet = $this->buildPacket($segment);\n        $packetLength = strlen($packet);\n        if ($packetLength > self::MAX_SEGMENT_SIZE) {\n            $this->submitFragmented($segment);\n            return;\n        }\n        $this->sendPacket($packet);\n    }\n    \/**\n     * @param Segment|array<string, mixed> $segment\n     *\/\n    private function buildPacket(Segment|array $segment) : string\n    {\n        return implode(\"\\n\", array_map('json_encode', [self::HEADER, $segment]));\n    }\n    private function sendPacket(string $packet) : void\n    {\n        socket_sendto($this->socket, $packet, strlen($packet), -1, $this->host, $this->port);\n    }\n    private function submitFragmented(Segment $segment) : void\n    {\n        $rawSegment = $segment->jsonSerialize();\n        \/** @var Segment[] $subsegments *\/\n        $subsegments = $rawSegment['subsegments'] ?? [];\n        unset($rawSegment['subsegments']);\n        $this->submitOpenSegment($rawSegment);\n        foreach ($subsegments as $subsegment) {\n            $subsegment = clone $subsegment;\n            $subsegment->setParentId($segment->getId())->setTraceId($segment->getTraceId())->setIndependent(true);\n            $this->submitSegment($subsegment);\n        }\n        $completePacket = $this->buildPacket($rawSegment);\n        $this->sendPacket($completePacket);\n    }\n    \/**\n     * @param array<string, mixed> $openSegment\n     *\/\n    private function submitOpenSegment(array $openSegment) : void\n    {\n        unset($openSegment['end_time']);\n        $openSegment['in_progress'] = true;\n        $this->sendPacket($this->buildPacket($openSegment));\n    }\n}","originalFilePath":"\/home\/ranpafin\/php-xray\/src\/Submission\/DaemonSegmentSubmitter.php","originalStartLine":71},"diff":"--- Original\n+++ New\n@@ @@\n     }\n     private function sendPacket(string $packet) : void\n     {\n-        socket_sendto($this->socket, $packet, strlen($packet), 0, $this->host, $this->port);\n+        socket_sendto($this->socket, $packet, strlen($packet), -1, $this->host, $this->port);\n     }\n     private function submitFragmented(Segment $segment) : void\n     {","processOutput":"PHPUnit 9.5.10 by Sebastian Bergmann and contributors.\n\nRuntime:       PHP 8.0.13\nConfiguration: \/tmp\/tmp-folder\/infection\/phpunitConfiguration.821561772064b37d9418578f3bdefde9.infection.xml\n\nE\n\nTime: 00:00.003, Memory: 8.00 MB\n\nThere was 1 error:\n\n1) Fido\\PHPXray\\DaemonSegmentSubmitterTest::testSubmitsToDaemon\nsocket_bind(): Unable to bind address [98]: Address already in use\n\n\/home\/ranpafin\/php-xray\/tests\/DaemonSegmentSubmitterTest.php:18\n\nERRORS!\nTests: 1, Assertions: 0, Errors: 1."},{"mutator":{"mutatorName":"IncrementInteger","originalSourceCode":"<?php\n\nnamespace Fido\\PHPXray\\Submission;\n\nuse Error;\nuse Fido\\PHPXray\\Segment;\nuse Socket;\nuse function socket_create;\nuse function socket_last_error;\nclass DaemonSegmentSubmitter implements SegmentSubmitter\n{\n    protected const MAX_SEGMENT_SIZE = 64000;\n    \/**\n     * @var array<string, mixed>\n     *\/\n    public const HEADER = ['format' => 'json', 'version' => 1];\n    private string $host;\n    private int $port;\n    \/** @var Socket *\/\n    private $socket;\n    public function __construct(string $host = '127.0.0.1', int $port = 2000)\n    {\n        if (isset($_SERVER['AWS_XRAY_DAEMON_ADDRESS'])) {\n            [$host, $port] = explode(\":\", $_SERVER['AWS_XRAY_DAEMON_ADDRESS']);\n        }\n        $this->host = $_SERVER['_AWS_XRAY_DAEMON_ADDRESS'] ?? $host;\n        $this->port = (int) ($_SERVER['_AWS_XRAY_DAEMON_PORT'] ?? $port);\n        if (!($socket = socket_create(AF_INET, SOCK_DGRAM, SOL_UDP))) {\n            throw new Error('Can\\'t create socket: ' . socket_last_error());\n        }\n        $this->socket = $socket;\n    }\n    public function __destruct()\n    {\n        socket_close($this->socket);\n    }\n    public function submitSegment(Segment $segment) : void\n    {\n        $packet = $this->buildPacket($segment);\n        $packetLength = strlen($packet);\n        if ($packetLength > self::MAX_SEGMENT_SIZE) {\n            $this->submitFragmented($segment);\n            return;\n        }\n        $this->sendPacket($packet);\n    }\n    \/**\n     * @param Segment|array<string, mixed> $segment\n     *\/\n    private function buildPacket(Segment|array $segment) : string\n    {\n        return implode(\"\\n\", array_map('json_encode', [self::HEADER, $segment]));\n    }\n    private function sendPacket(string $packet) : void\n    {\n        socket_sendto($this->socket, $packet, strlen($packet), 0, $this->host, $this->port);\n    }\n    private function submitFragmented(Segment $segment) : void\n    {\n        $rawSegment = $segment->jsonSerialize();\n        \/** @var Segment[] $subsegments *\/\n        $subsegments = $rawSegment['subsegments'] ?? [];\n        unset($rawSegment['subsegments']);\n        $this->submitOpenSegment($rawSegment);\n        foreach ($subsegments as $subsegment) {\n            $subsegment = clone $subsegment;\n            $subsegment->setParentId($segment->getId())->setTraceId($segment->getTraceId())->setIndependent(true);\n            $this->submitSegment($subsegment);\n        }\n        $completePacket = $this->buildPacket($rawSegment);\n        $this->sendPacket($completePacket);\n    }\n    \/**\n     * @param array<string, mixed> $openSegment\n     *\/\n    private function submitOpenSegment(array $openSegment) : void\n    {\n        unset($openSegment['end_time']);\n        $openSegment['in_progress'] = true;\n        $this->sendPacket($this->buildPacket($openSegment));\n    }\n}","mutatedSourceCode":"<?php\n\nnamespace Fido\\PHPXray\\Submission;\n\nuse Error;\nuse Fido\\PHPXray\\Segment;\nuse Socket;\nuse function socket_create;\nuse function socket_last_error;\nclass DaemonSegmentSubmitter implements SegmentSubmitter\n{\n    protected const MAX_SEGMENT_SIZE = 64000;\n    \/**\n     * @var array<string, mixed>\n     *\/\n    public const HEADER = ['format' => 'json', 'version' => 1];\n    private string $host;\n    private int $port;\n    \/** @var Socket *\/\n    private $socket;\n    public function __construct(string $host = '127.0.0.1', int $port = 2000)\n    {\n        if (isset($_SERVER['AWS_XRAY_DAEMON_ADDRESS'])) {\n            [$host, $port] = explode(\":\", $_SERVER['AWS_XRAY_DAEMON_ADDRESS']);\n        }\n        $this->host = $_SERVER['_AWS_XRAY_DAEMON_ADDRESS'] ?? $host;\n        $this->port = (int) ($_SERVER['_AWS_XRAY_DAEMON_PORT'] ?? $port);\n        if (!($socket = socket_create(AF_INET, SOCK_DGRAM, SOL_UDP))) {\n            throw new Error('Can\\'t create socket: ' . socket_last_error());\n        }\n        $this->socket = $socket;\n    }\n    public function __destruct()\n    {\n        socket_close($this->socket);\n    }\n    public function submitSegment(Segment $segment) : void\n    {\n        $packet = $this->buildPacket($segment);\n        $packetLength = strlen($packet);\n        if ($packetLength > self::MAX_SEGMENT_SIZE) {\n            $this->submitFragmented($segment);\n            return;\n        }\n        $this->sendPacket($packet);\n    }\n    \/**\n     * @param Segment|array<string, mixed> $segment\n     *\/\n    private function buildPacket(Segment|array $segment) : string\n    {\n        return implode(\"\\n\", array_map('json_encode', [self::HEADER, $segment]));\n    }\n    private function sendPacket(string $packet) : void\n    {\n        socket_sendto($this->socket, $packet, strlen($packet), 1, $this->host, $this->port);\n    }\n    private function submitFragmented(Segment $segment) : void\n    {\n        $rawSegment = $segment->jsonSerialize();\n        \/** @var Segment[] $subsegments *\/\n        $subsegments = $rawSegment['subsegments'] ?? [];\n        unset($rawSegment['subsegments']);\n        $this->submitOpenSegment($rawSegment);\n        foreach ($subsegments as $subsegment) {\n            $subsegment = clone $subsegment;\n            $subsegment->setParentId($segment->getId())->setTraceId($segment->getTraceId())->setIndependent(true);\n            $this->submitSegment($subsegment);\n        }\n        $completePacket = $this->buildPacket($rawSegment);\n        $this->sendPacket($completePacket);\n    }\n    \/**\n     * @param array<string, mixed> $openSegment\n     *\/\n    private function submitOpenSegment(array $openSegment) : void\n    {\n        unset($openSegment['end_time']);\n        $openSegment['in_progress'] = true;\n        $this->sendPacket($this->buildPacket($openSegment));\n    }\n}","originalFilePath":"\/home\/ranpafin\/php-xray\/src\/Submission\/DaemonSegmentSubmitter.php","originalStartLine":71},"diff":"--- Original\n+++ New\n@@ @@\n     }\n     private function sendPacket(string $packet) : void\n     {\n-        socket_sendto($this->socket, $packet, strlen($packet), 0, $this->host, $this->port);\n+        socket_sendto($this->socket, $packet, strlen($packet), 1, $this->host, $this->port);\n     }\n     private function submitFragmented(Segment $segment) : void\n     {","processOutput":"PHPUnit 9.5.10 by Sebastian Bergmann and contributors.\n\nRuntime:       PHP 8.0.13\nConfiguration: \/tmp\/tmp-folder\/infection\/phpunitConfiguration.b93b0e837979a9ff4fbe18d03b06398b.infection.xml\n\nE\n\nTime: 00:00.003, Memory: 8.00 MB\n\nThere was 1 error:\n\n1) Fido\\PHPXray\\DaemonSegmentSubmitterTest::testSubmitsToDaemon\nsocket_bind(): Unable to bind address [98]: Address already in use\n\n\/home\/ranpafin\/php-xray\/tests\/DaemonSegmentSubmitterTest.php:18\n\nERRORS!\nTests: 1, Assertions: 0, Errors: 1."},{"mutator":{"mutatorName":"FunctionCallRemoval","originalSourceCode":"<?php\n\nnamespace Fido\\PHPXray\\Submission;\n\nuse Error;\nuse Fido\\PHPXray\\Segment;\nuse Socket;\nuse function socket_create;\nuse function socket_last_error;\nclass DaemonSegmentSubmitter implements SegmentSubmitter\n{\n    protected const MAX_SEGMENT_SIZE = 64000;\n    \/**\n     * @var array<string, mixed>\n     *\/\n    public const HEADER = ['format' => 'json', 'version' => 1];\n    private string $host;\n    private int $port;\n    \/** @var Socket *\/\n    private $socket;\n    public function __construct(string $host = '127.0.0.1', int $port = 2000)\n    {\n        if (isset($_SERVER['AWS_XRAY_DAEMON_ADDRESS'])) {\n            [$host, $port] = explode(\":\", $_SERVER['AWS_XRAY_DAEMON_ADDRESS']);\n        }\n        $this->host = $_SERVER['_AWS_XRAY_DAEMON_ADDRESS'] ?? $host;\n        $this->port = (int) ($_SERVER['_AWS_XRAY_DAEMON_PORT'] ?? $port);\n        if (!($socket = socket_create(AF_INET, SOCK_DGRAM, SOL_UDP))) {\n            throw new Error('Can\\'t create socket: ' . socket_last_error());\n        }\n        $this->socket = $socket;\n    }\n    public function __destruct()\n    {\n        socket_close($this->socket);\n    }\n    public function submitSegment(Segment $segment) : void\n    {\n        $packet = $this->buildPacket($segment);\n        $packetLength = strlen($packet);\n        if ($packetLength > self::MAX_SEGMENT_SIZE) {\n            $this->submitFragmented($segment);\n            return;\n        }\n        $this->sendPacket($packet);\n    }\n    \/**\n     * @param Segment|array<string, mixed> $segment\n     *\/\n    private function buildPacket(Segment|array $segment) : string\n    {\n        return implode(\"\\n\", array_map('json_encode', [self::HEADER, $segment]));\n    }\n    private function sendPacket(string $packet) : void\n    {\n        socket_sendto($this->socket, $packet, strlen($packet), 0, $this->host, $this->port);\n    }\n    private function submitFragmented(Segment $segment) : void\n    {\n        $rawSegment = $segment->jsonSerialize();\n        \/** @var Segment[] $subsegments *\/\n        $subsegments = $rawSegment['subsegments'] ?? [];\n        unset($rawSegment['subsegments']);\n        $this->submitOpenSegment($rawSegment);\n        foreach ($subsegments as $subsegment) {\n            $subsegment = clone $subsegment;\n            $subsegment->setParentId($segment->getId())->setTraceId($segment->getTraceId())->setIndependent(true);\n            $this->submitSegment($subsegment);\n        }\n        $completePacket = $this->buildPacket($rawSegment);\n        $this->sendPacket($completePacket);\n    }\n    \/**\n     * @param array<string, mixed> $openSegment\n     *\/\n    private function submitOpenSegment(array $openSegment) : void\n    {\n        unset($openSegment['end_time']);\n        $openSegment['in_progress'] = true;\n        $this->sendPacket($this->buildPacket($openSegment));\n    }\n}","mutatedSourceCode":"<?php\n\nnamespace Fido\\PHPXray\\Submission;\n\nuse Error;\nuse Fido\\PHPXray\\Segment;\nuse Socket;\nuse function socket_create;\nuse function socket_last_error;\nclass DaemonSegmentSubmitter implements SegmentSubmitter\n{\n    protected const MAX_SEGMENT_SIZE = 64000;\n    \/**\n     * @var array<string, mixed>\n     *\/\n    public const HEADER = ['format' => 'json', 'version' => 1];\n    private string $host;\n    private int $port;\n    \/** @var Socket *\/\n    private $socket;\n    public function __construct(string $host = '127.0.0.1', int $port = 2000)\n    {\n        if (isset($_SERVER['AWS_XRAY_DAEMON_ADDRESS'])) {\n            [$host, $port] = explode(\":\", $_SERVER['AWS_XRAY_DAEMON_ADDRESS']);\n        }\n        $this->host = $_SERVER['_AWS_XRAY_DAEMON_ADDRESS'] ?? $host;\n        $this->port = (int) ($_SERVER['_AWS_XRAY_DAEMON_PORT'] ?? $port);\n        if (!($socket = socket_create(AF_INET, SOCK_DGRAM, SOL_UDP))) {\n            throw new Error('Can\\'t create socket: ' . socket_last_error());\n        }\n        $this->socket = $socket;\n    }\n    public function __destruct()\n    {\n        socket_close($this->socket);\n    }\n    public function submitSegment(Segment $segment) : void\n    {\n        $packet = $this->buildPacket($segment);\n        $packetLength = strlen($packet);\n        if ($packetLength > self::MAX_SEGMENT_SIZE) {\n            $this->submitFragmented($segment);\n            return;\n        }\n        $this->sendPacket($packet);\n    }\n    \/**\n     * @param Segment|array<string, mixed> $segment\n     *\/\n    private function buildPacket(Segment|array $segment) : string\n    {\n        return implode(\"\\n\", array_map('json_encode', [self::HEADER, $segment]));\n    }\n    private function sendPacket(string $packet) : void\n    {\n        \n    }\n    private function submitFragmented(Segment $segment) : void\n    {\n        $rawSegment = $segment->jsonSerialize();\n        \/** @var Segment[] $subsegments *\/\n        $subsegments = $rawSegment['subsegments'] ?? [];\n        unset($rawSegment['subsegments']);\n        $this->submitOpenSegment($rawSegment);\n        foreach ($subsegments as $subsegment) {\n            $subsegment = clone $subsegment;\n            $subsegment->setParentId($segment->getId())->setTraceId($segment->getTraceId())->setIndependent(true);\n            $this->submitSegment($subsegment);\n        }\n        $completePacket = $this->buildPacket($rawSegment);\n        $this->sendPacket($completePacket);\n    }\n    \/**\n     * @param array<string, mixed> $openSegment\n     *\/\n    private function submitOpenSegment(array $openSegment) : void\n    {\n        unset($openSegment['end_time']);\n        $openSegment['in_progress'] = true;\n        $this->sendPacket($this->buildPacket($openSegment));\n    }\n}","originalFilePath":"\/home\/ranpafin\/php-xray\/src\/Submission\/DaemonSegmentSubmitter.php","originalStartLine":71},"diff":"--- Original\n+++ New\n@@ @@\n     }\n     private function sendPacket(string $packet) : void\n     {\n-        socket_sendto($this->socket, $packet, strlen($packet), 0, $this->host, $this->port);\n+        \n     }\n     private function submitFragmented(Segment $segment) : void\n     {","processOutput":"PHPUnit 9.5.10 by Sebastian Bergmann and contributors.\n\nRuntime:       PHP 8.0.13\nConfiguration: \/tmp\/tmp-folder\/infection\/phpunitConfiguration.e8ef162a3605b219b88716a82f88ec54.infection.xml\n\nE\n\nTime: 00:00.003, Memory: 8.00 MB\n\nThere was 1 error:\n\n1) Fido\\PHPXray\\DaemonSegmentSubmitterTest::testSubmitsToDaemon\nsocket_bind(): Unable to bind address [98]: Address already in use\n\n\/home\/ranpafin\/php-xray\/tests\/DaemonSegmentSubmitterTest.php:18\n\nERRORS!\nTests: 1, Assertions: 0, Errors: 1."},{"mutator":{"mutatorName":"Coalesce","originalSourceCode":"<?php\n\nnamespace Fido\\PHPXray\\Submission;\n\nuse Error;\nuse Fido\\PHPXray\\Segment;\nuse Socket;\nuse function socket_create;\nuse function socket_last_error;\nclass DaemonSegmentSubmitter implements SegmentSubmitter\n{\n    protected const MAX_SEGMENT_SIZE = 64000;\n    \/**\n     * @var array<string, mixed>\n     *\/\n    public const HEADER = ['format' => 'json', 'version' => 1];\n    private string $host;\n    private int $port;\n    \/** @var Socket *\/\n    private $socket;\n    public function __construct(string $host = '127.0.0.1', int $port = 2000)\n    {\n        if (isset($_SERVER['AWS_XRAY_DAEMON_ADDRESS'])) {\n            [$host, $port] = explode(\":\", $_SERVER['AWS_XRAY_DAEMON_ADDRESS']);\n        }\n        $this->host = $_SERVER['_AWS_XRAY_DAEMON_ADDRESS'] ?? $host;\n        $this->port = (int) ($_SERVER['_AWS_XRAY_DAEMON_PORT'] ?? $port);\n        if (!($socket = socket_create(AF_INET, SOCK_DGRAM, SOL_UDP))) {\n            throw new Error('Can\\'t create socket: ' . socket_last_error());\n        }\n        $this->socket = $socket;\n    }\n    public function __destruct()\n    {\n        socket_close($this->socket);\n    }\n    public function submitSegment(Segment $segment) : void\n    {\n        $packet = $this->buildPacket($segment);\n        $packetLength = strlen($packet);\n        if ($packetLength > self::MAX_SEGMENT_SIZE) {\n            $this->submitFragmented($segment);\n            return;\n        }\n        $this->sendPacket($packet);\n    }\n    \/**\n     * @param Segment|array<string, mixed> $segment\n     *\/\n    private function buildPacket(Segment|array $segment) : string\n    {\n        return implode(\"\\n\", array_map('json_encode', [self::HEADER, $segment]));\n    }\n    private function sendPacket(string $packet) : void\n    {\n        socket_sendto($this->socket, $packet, strlen($packet), 0, $this->host, $this->port);\n    }\n    private function submitFragmented(Segment $segment) : void\n    {\n        $rawSegment = $segment->jsonSerialize();\n        \/** @var Segment[] $subsegments *\/\n        $subsegments = $rawSegment['subsegments'] ?? [];\n        unset($rawSegment['subsegments']);\n        $this->submitOpenSegment($rawSegment);\n        foreach ($subsegments as $subsegment) {\n            $subsegment = clone $subsegment;\n            $subsegment->setParentId($segment->getId())->setTraceId($segment->getTraceId())->setIndependent(true);\n            $this->submitSegment($subsegment);\n        }\n        $completePacket = $this->buildPacket($rawSegment);\n        $this->sendPacket($completePacket);\n    }\n    \/**\n     * @param array<string, mixed> $openSegment\n     *\/\n    private function submitOpenSegment(array $openSegment) : void\n    {\n        unset($openSegment['end_time']);\n        $openSegment['in_progress'] = true;\n        $this->sendPacket($this->buildPacket($openSegment));\n    }\n}","mutatedSourceCode":"<?php\n\nnamespace Fido\\PHPXray\\Submission;\n\nuse Error;\nuse Fido\\PHPXray\\Segment;\nuse Socket;\nuse function socket_create;\nuse function socket_last_error;\nclass DaemonSegmentSubmitter implements SegmentSubmitter\n{\n    protected const MAX_SEGMENT_SIZE = 64000;\n    \/**\n     * @var array<string, mixed>\n     *\/\n    public const HEADER = ['format' => 'json', 'version' => 1];\n    private string $host;\n    private int $port;\n    \/** @var Socket *\/\n    private $socket;\n    public function __construct(string $host = '127.0.0.1', int $port = 2000)\n    {\n        if (isset($_SERVER['AWS_XRAY_DAEMON_ADDRESS'])) {\n            [$host, $port] = explode(\":\", $_SERVER['AWS_XRAY_DAEMON_ADDRESS']);\n        }\n        $this->host = $_SERVER['_AWS_XRAY_DAEMON_ADDRESS'] ?? $host;\n        $this->port = (int) ($_SERVER['_AWS_XRAY_DAEMON_PORT'] ?? $port);\n        if (!($socket = socket_create(AF_INET, SOCK_DGRAM, SOL_UDP))) {\n            throw new Error('Can\\'t create socket: ' . socket_last_error());\n        }\n        $this->socket = $socket;\n    }\n    public function __destruct()\n    {\n        socket_close($this->socket);\n    }\n    public function submitSegment(Segment $segment) : void\n    {\n        $packet = $this->buildPacket($segment);\n        $packetLength = strlen($packet);\n        if ($packetLength > self::MAX_SEGMENT_SIZE) {\n            $this->submitFragmented($segment);\n            return;\n        }\n        $this->sendPacket($packet);\n    }\n    \/**\n     * @param Segment|array<string, mixed> $segment\n     *\/\n    private function buildPacket(Segment|array $segment) : string\n    {\n        return implode(\"\\n\", array_map('json_encode', [self::HEADER, $segment]));\n    }\n    private function sendPacket(string $packet) : void\n    {\n        socket_sendto($this->socket, $packet, strlen($packet), 0, $this->host, $this->port);\n    }\n    private function submitFragmented(Segment $segment) : void\n    {\n        $rawSegment = $segment->jsonSerialize();\n        \/** @var Segment[] $subsegments *\/\n        $subsegments = [] ?? $rawSegment['subsegments'];\n        unset($rawSegment['subsegments']);\n        $this->submitOpenSegment($rawSegment);\n        foreach ($subsegments as $subsegment) {\n            $subsegment = clone $subsegment;\n            $subsegment->setParentId($segment->getId())->setTraceId($segment->getTraceId())->setIndependent(true);\n            $this->submitSegment($subsegment);\n        }\n        $completePacket = $this->buildPacket($rawSegment);\n        $this->sendPacket($completePacket);\n    }\n    \/**\n     * @param array<string, mixed> $openSegment\n     *\/\n    private function submitOpenSegment(array $openSegment) : void\n    {\n        unset($openSegment['end_time']);\n        $openSegment['in_progress'] = true;\n        $this->sendPacket($this->buildPacket($openSegment));\n    }\n}","originalFilePath":"\/home\/ranpafin\/php-xray\/src\/Submission\/DaemonSegmentSubmitter.php","originalStartLine":78},"diff":"--- Original\n+++ New\n@@ @@\n     {\n         $rawSegment = $segment->jsonSerialize();\n         \/** @var Segment[] $subsegments *\/\n-        $subsegments = $rawSegment['subsegments'] ?? [];\n+        $subsegments = [] ?? $rawSegment['subsegments'];\n         unset($rawSegment['subsegments']);\n         $this->submitOpenSegment($rawSegment);\n         foreach ($subsegments as $subsegment) {","processOutput":"PHPUnit 9.5.10 by Sebastian Bergmann and contributors.\n\nRuntime:       PHP 8.0.13\nConfiguration: \/tmp\/tmp-folder\/infection\/phpunitConfiguration.ad5fbfede604b750d65c41af1111c50f.infection.xml\n\nE\n\nTime: 00:00.003, Memory: 8.00 MB\n\nThere was 1 error:\n\n1) Fido\\PHPXray\\DaemonSegmentSubmitterTest::testSubmitsToDaemon\nsocket_bind(): Unable to bind address [98]: Address already in use\n\n\/home\/ranpafin\/php-xray\/tests\/DaemonSegmentSubmitterTest.php:18\n\nERRORS!\nTests: 1, Assertions: 0, Errors: 1."},{"mutator":{"mutatorName":"MethodCallRemoval","originalSourceCode":"<?php\n\nnamespace Fido\\PHPXray\\Submission;\n\nuse Error;\nuse Fido\\PHPXray\\Segment;\nuse Socket;\nuse function socket_create;\nuse function socket_last_error;\nclass DaemonSegmentSubmitter implements SegmentSubmitter\n{\n    protected const MAX_SEGMENT_SIZE = 64000;\n    \/**\n     * @var array<string, mixed>\n     *\/\n    public const HEADER = ['format' => 'json', 'version' => 1];\n    private string $host;\n    private int $port;\n    \/** @var Socket *\/\n    private $socket;\n    public function __construct(string $host = '127.0.0.1', int $port = 2000)\n    {\n        if (isset($_SERVER['AWS_XRAY_DAEMON_ADDRESS'])) {\n            [$host, $port] = explode(\":\", $_SERVER['AWS_XRAY_DAEMON_ADDRESS']);\n        }\n        $this->host = $_SERVER['_AWS_XRAY_DAEMON_ADDRESS'] ?? $host;\n        $this->port = (int) ($_SERVER['_AWS_XRAY_DAEMON_PORT'] ?? $port);\n        if (!($socket = socket_create(AF_INET, SOCK_DGRAM, SOL_UDP))) {\n            throw new Error('Can\\'t create socket: ' . socket_last_error());\n        }\n        $this->socket = $socket;\n    }\n    public function __destruct()\n    {\n        socket_close($this->socket);\n    }\n    public function submitSegment(Segment $segment) : void\n    {\n        $packet = $this->buildPacket($segment);\n        $packetLength = strlen($packet);\n        if ($packetLength > self::MAX_SEGMENT_SIZE) {\n            $this->submitFragmented($segment);\n            return;\n        }\n        $this->sendPacket($packet);\n    }\n    \/**\n     * @param Segment|array<string, mixed> $segment\n     *\/\n    private function buildPacket(Segment|array $segment) : string\n    {\n        return implode(\"\\n\", array_map('json_encode', [self::HEADER, $segment]));\n    }\n    private function sendPacket(string $packet) : void\n    {\n        socket_sendto($this->socket, $packet, strlen($packet), 0, $this->host, $this->port);\n    }\n    private function submitFragmented(Segment $segment) : void\n    {\n        $rawSegment = $segment->jsonSerialize();\n        \/** @var Segment[] $subsegments *\/\n        $subsegments = $rawSegment['subsegments'] ?? [];\n        unset($rawSegment['subsegments']);\n        $this->submitOpenSegment($rawSegment);\n        foreach ($subsegments as $subsegment) {\n            $subsegment = clone $subsegment;\n            $subsegment->setParentId($segment->getId())->setTraceId($segment->getTraceId())->setIndependent(true);\n            $this->submitSegment($subsegment);\n        }\n        $completePacket = $this->buildPacket($rawSegment);\n        $this->sendPacket($completePacket);\n    }\n    \/**\n     * @param array<string, mixed> $openSegment\n     *\/\n    private function submitOpenSegment(array $openSegment) : void\n    {\n        unset($openSegment['end_time']);\n        $openSegment['in_progress'] = true;\n        $this->sendPacket($this->buildPacket($openSegment));\n    }\n}","mutatedSourceCode":"<?php\n\nnamespace Fido\\PHPXray\\Submission;\n\nuse Error;\nuse Fido\\PHPXray\\Segment;\nuse Socket;\nuse function socket_create;\nuse function socket_last_error;\nclass DaemonSegmentSubmitter implements SegmentSubmitter\n{\n    protected const MAX_SEGMENT_SIZE = 64000;\n    \/**\n     * @var array<string, mixed>\n     *\/\n    public const HEADER = ['format' => 'json', 'version' => 1];\n    private string $host;\n    private int $port;\n    \/** @var Socket *\/\n    private $socket;\n    public function __construct(string $host = '127.0.0.1', int $port = 2000)\n    {\n        if (isset($_SERVER['AWS_XRAY_DAEMON_ADDRESS'])) {\n            [$host, $port] = explode(\":\", $_SERVER['AWS_XRAY_DAEMON_ADDRESS']);\n        }\n        $this->host = $_SERVER['_AWS_XRAY_DAEMON_ADDRESS'] ?? $host;\n        $this->port = (int) ($_SERVER['_AWS_XRAY_DAEMON_PORT'] ?? $port);\n        if (!($socket = socket_create(AF_INET, SOCK_DGRAM, SOL_UDP))) {\n            throw new Error('Can\\'t create socket: ' . socket_last_error());\n        }\n        $this->socket = $socket;\n    }\n    public function __destruct()\n    {\n        socket_close($this->socket);\n    }\n    public function submitSegment(Segment $segment) : void\n    {\n        $packet = $this->buildPacket($segment);\n        $packetLength = strlen($packet);\n        if ($packetLength > self::MAX_SEGMENT_SIZE) {\n            $this->submitFragmented($segment);\n            return;\n        }\n        $this->sendPacket($packet);\n    }\n    \/**\n     * @param Segment|array<string, mixed> $segment\n     *\/\n    private function buildPacket(Segment|array $segment) : string\n    {\n        return implode(\"\\n\", array_map('json_encode', [self::HEADER, $segment]));\n    }\n    private function sendPacket(string $packet) : void\n    {\n        socket_sendto($this->socket, $packet, strlen($packet), 0, $this->host, $this->port);\n    }\n    private function submitFragmented(Segment $segment) : void\n    {\n        $rawSegment = $segment->jsonSerialize();\n        \/** @var Segment[] $subsegments *\/\n        $subsegments = $rawSegment['subsegments'] ?? [];\n        unset($rawSegment['subsegments']);\n        \n        foreach ($subsegments as $subsegment) {\n            $subsegment = clone $subsegment;\n            $subsegment->setParentId($segment->getId())->setTraceId($segment->getTraceId())->setIndependent(true);\n            $this->submitSegment($subsegment);\n        }\n        $completePacket = $this->buildPacket($rawSegment);\n        $this->sendPacket($completePacket);\n    }\n    \/**\n     * @param array<string, mixed> $openSegment\n     *\/\n    private function submitOpenSegment(array $openSegment) : void\n    {\n        unset($openSegment['end_time']);\n        $openSegment['in_progress'] = true;\n        $this->sendPacket($this->buildPacket($openSegment));\n    }\n}","originalFilePath":"\/home\/ranpafin\/php-xray\/src\/Submission\/DaemonSegmentSubmitter.php","originalStartLine":80},"diff":"--- Original\n+++ New\n@@ @@\n         \/** @var Segment[] $subsegments *\/\n         $subsegments = $rawSegment['subsegments'] ?? [];\n         unset($rawSegment['subsegments']);\n-        $this->submitOpenSegment($rawSegment);\n+        \n         foreach ($subsegments as $subsegment) {\n             $subsegment = clone $subsegment;\n             $subsegment->setParentId($segment->getId())->setTraceId($segment->getTraceId())->setIndependent(true);","processOutput":"PHPUnit 9.5.10 by Sebastian Bergmann and contributors.\n\nRuntime:       PHP 8.0.13\nConfiguration: \/tmp\/tmp-folder\/infection\/phpunitConfiguration.8b31dd98e879c4a3dc9b8cfa949ccd3a.infection.xml\n\nE\n\nTime: 00:00.002, Memory: 8.00 MB\n\nThere was 1 error:\n\n1) Fido\\PHPXray\\DaemonSegmentSubmitterTest::testSubmitsToDaemon\nsocket_bind(): Unable to bind address [98]: Address already in use\n\n\/home\/ranpafin\/php-xray\/tests\/DaemonSegmentSubmitterTest.php:18\n\nERRORS!\nTests: 1, Assertions: 0, Errors: 1."},{"mutator":{"mutatorName":"Foreach_","originalSourceCode":"<?php\n\nnamespace Fido\\PHPXray\\Submission;\n\nuse Error;\nuse Fido\\PHPXray\\Segment;\nuse Socket;\nuse function socket_create;\nuse function socket_last_error;\nclass DaemonSegmentSubmitter implements SegmentSubmitter\n{\n    protected const MAX_SEGMENT_SIZE = 64000;\n    \/**\n     * @var array<string, mixed>\n     *\/\n    public const HEADER = ['format' => 'json', 'version' => 1];\n    private string $host;\n    private int $port;\n    \/** @var Socket *\/\n    private $socket;\n    public function __construct(string $host = '127.0.0.1', int $port = 2000)\n    {\n        if (isset($_SERVER['AWS_XRAY_DAEMON_ADDRESS'])) {\n            [$host, $port] = explode(\":\", $_SERVER['AWS_XRAY_DAEMON_ADDRESS']);\n        }\n        $this->host = $_SERVER['_AWS_XRAY_DAEMON_ADDRESS'] ?? $host;\n        $this->port = (int) ($_SERVER['_AWS_XRAY_DAEMON_PORT'] ?? $port);\n        if (!($socket = socket_create(AF_INET, SOCK_DGRAM, SOL_UDP))) {\n            throw new Error('Can\\'t create socket: ' . socket_last_error());\n        }\n        $this->socket = $socket;\n    }\n    public function __destruct()\n    {\n        socket_close($this->socket);\n    }\n    public function submitSegment(Segment $segment) : void\n    {\n        $packet = $this->buildPacket($segment);\n        $packetLength = strlen($packet);\n        if ($packetLength > self::MAX_SEGMENT_SIZE) {\n            $this->submitFragmented($segment);\n            return;\n        }\n        $this->sendPacket($packet);\n    }\n    \/**\n     * @param Segment|array<string, mixed> $segment\n     *\/\n    private function buildPacket(Segment|array $segment) : string\n    {\n        return implode(\"\\n\", array_map('json_encode', [self::HEADER, $segment]));\n    }\n    private function sendPacket(string $packet) : void\n    {\n        socket_sendto($this->socket, $packet, strlen($packet), 0, $this->host, $this->port);\n    }\n    private function submitFragmented(Segment $segment) : void\n    {\n        $rawSegment = $segment->jsonSerialize();\n        \/** @var Segment[] $subsegments *\/\n        $subsegments = $rawSegment['subsegments'] ?? [];\n        unset($rawSegment['subsegments']);\n        $this->submitOpenSegment($rawSegment);\n        foreach ($subsegments as $subsegment) {\n            $subsegment = clone $subsegment;\n            $subsegment->setParentId($segment->getId())->setTraceId($segment->getTraceId())->setIndependent(true);\n            $this->submitSegment($subsegment);\n        }\n        $completePacket = $this->buildPacket($rawSegment);\n        $this->sendPacket($completePacket);\n    }\n    \/**\n     * @param array<string, mixed> $openSegment\n     *\/\n    private function submitOpenSegment(array $openSegment) : void\n    {\n        unset($openSegment['end_time']);\n        $openSegment['in_progress'] = true;\n        $this->sendPacket($this->buildPacket($openSegment));\n    }\n}","mutatedSourceCode":"<?php\n\nnamespace Fido\\PHPXray\\Submission;\n\nuse Error;\nuse Fido\\PHPXray\\Segment;\nuse Socket;\nuse function socket_create;\nuse function socket_last_error;\nclass DaemonSegmentSubmitter implements SegmentSubmitter\n{\n    protected const MAX_SEGMENT_SIZE = 64000;\n    \/**\n     * @var array<string, mixed>\n     *\/\n    public const HEADER = ['format' => 'json', 'version' => 1];\n    private string $host;\n    private int $port;\n    \/** @var Socket *\/\n    private $socket;\n    public function __construct(string $host = '127.0.0.1', int $port = 2000)\n    {\n        if (isset($_SERVER['AWS_XRAY_DAEMON_ADDRESS'])) {\n            [$host, $port] = explode(\":\", $_SERVER['AWS_XRAY_DAEMON_ADDRESS']);\n        }\n        $this->host = $_SERVER['_AWS_XRAY_DAEMON_ADDRESS'] ?? $host;\n        $this->port = (int) ($_SERVER['_AWS_XRAY_DAEMON_PORT'] ?? $port);\n        if (!($socket = socket_create(AF_INET, SOCK_DGRAM, SOL_UDP))) {\n            throw new Error('Can\\'t create socket: ' . socket_last_error());\n        }\n        $this->socket = $socket;\n    }\n    public function __destruct()\n    {\n        socket_close($this->socket);\n    }\n    public function submitSegment(Segment $segment) : void\n    {\n        $packet = $this->buildPacket($segment);\n        $packetLength = strlen($packet);\n        if ($packetLength > self::MAX_SEGMENT_SIZE) {\n            $this->submitFragmented($segment);\n            return;\n        }\n        $this->sendPacket($packet);\n    }\n    \/**\n     * @param Segment|array<string, mixed> $segment\n     *\/\n    private function buildPacket(Segment|array $segment) : string\n    {\n        return implode(\"\\n\", array_map('json_encode', [self::HEADER, $segment]));\n    }\n    private function sendPacket(string $packet) : void\n    {\n        socket_sendto($this->socket, $packet, strlen($packet), 0, $this->host, $this->port);\n    }\n    private function submitFragmented(Segment $segment) : void\n    {\n        $rawSegment = $segment->jsonSerialize();\n        \/** @var Segment[] $subsegments *\/\n        $subsegments = $rawSegment['subsegments'] ?? [];\n        unset($rawSegment['subsegments']);\n        $this->submitOpenSegment($rawSegment);\n        foreach (array() as $subsegment) {\n            $subsegment = clone $subsegment;\n            $subsegment->setParentId($segment->getId())->setTraceId($segment->getTraceId())->setIndependent(true);\n            $this->submitSegment($subsegment);\n        }\n        $completePacket = $this->buildPacket($rawSegment);\n        $this->sendPacket($completePacket);\n    }\n    \/**\n     * @param array<string, mixed> $openSegment\n     *\/\n    private function submitOpenSegment(array $openSegment) : void\n    {\n        unset($openSegment['end_time']);\n        $openSegment['in_progress'] = true;\n        $this->sendPacket($this->buildPacket($openSegment));\n    }\n}","originalFilePath":"\/home\/ranpafin\/php-xray\/src\/Submission\/DaemonSegmentSubmitter.php","originalStartLine":82},"diff":"--- Original\n+++ New\n@@ @@\n         $subsegments = $rawSegment['subsegments'] ?? [];\n         unset($rawSegment['subsegments']);\n         $this->submitOpenSegment($rawSegment);\n-        foreach ($subsegments as $subsegment) {\n+        foreach (array() as $subsegment) {\n             $subsegment = clone $subsegment;\n             $subsegment->setParentId($segment->getId())->setTraceId($segment->getTraceId())->setIndependent(true);\n             $this->submitSegment($subsegment);","processOutput":"PHPUnit 9.5.10 by Sebastian Bergmann and contributors.\n\nRuntime:       PHP 8.0.13\nConfiguration: \/tmp\/tmp-folder\/infection\/phpunitConfiguration.ebfb8b6dbd817554aba9e8048ad27989.infection.xml\n\nE\n\nTime: 00:00.003, Memory: 8.00 MB\n\nThere was 1 error:\n\n1) Fido\\PHPXray\\DaemonSegmentSubmitterTest::testSubmitsToDaemon\nsocket_bind(): Unable to bind address [98]: Address already in use\n\n\/home\/ranpafin\/php-xray\/tests\/DaemonSegmentSubmitterTest.php:18\n\nERRORS!\nTests: 1, Assertions: 0, Errors: 1."},{"mutator":{"mutatorName":"CloneRemoval","originalSourceCode":"<?php\n\nnamespace Fido\\PHPXray\\Submission;\n\nuse Error;\nuse Fido\\PHPXray\\Segment;\nuse Socket;\nuse function socket_create;\nuse function socket_last_error;\nclass DaemonSegmentSubmitter implements SegmentSubmitter\n{\n    protected const MAX_SEGMENT_SIZE = 64000;\n    \/**\n     * @var array<string, mixed>\n     *\/\n    public const HEADER = ['format' => 'json', 'version' => 1];\n    private string $host;\n    private int $port;\n    \/** @var Socket *\/\n    private $socket;\n    public function __construct(string $host = '127.0.0.1', int $port = 2000)\n    {\n        if (isset($_SERVER['AWS_XRAY_DAEMON_ADDRESS'])) {\n            [$host, $port] = explode(\":\", $_SERVER['AWS_XRAY_DAEMON_ADDRESS']);\n        }\n        $this->host = $_SERVER['_AWS_XRAY_DAEMON_ADDRESS'] ?? $host;\n        $this->port = (int) ($_SERVER['_AWS_XRAY_DAEMON_PORT'] ?? $port);\n        if (!($socket = socket_create(AF_INET, SOCK_DGRAM, SOL_UDP))) {\n            throw new Error('Can\\'t create socket: ' . socket_last_error());\n        }\n        $this->socket = $socket;\n    }\n    public function __destruct()\n    {\n        socket_close($this->socket);\n    }\n    public function submitSegment(Segment $segment) : void\n    {\n        $packet = $this->buildPacket($segment);\n        $packetLength = strlen($packet);\n        if ($packetLength > self::MAX_SEGMENT_SIZE) {\n            $this->submitFragmented($segment);\n            return;\n        }\n        $this->sendPacket($packet);\n    }\n    \/**\n     * @param Segment|array<string, mixed> $segment\n     *\/\n    private function buildPacket(Segment|array $segment) : string\n    {\n        return implode(\"\\n\", array_map('json_encode', [self::HEADER, $segment]));\n    }\n    private function sendPacket(string $packet) : void\n    {\n        socket_sendto($this->socket, $packet, strlen($packet), 0, $this->host, $this->port);\n    }\n    private function submitFragmented(Segment $segment) : void\n    {\n        $rawSegment = $segment->jsonSerialize();\n        \/** @var Segment[] $subsegments *\/\n        $subsegments = $rawSegment['subsegments'] ?? [];\n        unset($rawSegment['subsegments']);\n        $this->submitOpenSegment($rawSegment);\n        foreach ($subsegments as $subsegment) {\n            $subsegment = clone $subsegment;\n            $subsegment->setParentId($segment->getId())->setTraceId($segment->getTraceId())->setIndependent(true);\n            $this->submitSegment($subsegment);\n        }\n        $completePacket = $this->buildPacket($rawSegment);\n        $this->sendPacket($completePacket);\n    }\n    \/**\n     * @param array<string, mixed> $openSegment\n     *\/\n    private function submitOpenSegment(array $openSegment) : void\n    {\n        unset($openSegment['end_time']);\n        $openSegment['in_progress'] = true;\n        $this->sendPacket($this->buildPacket($openSegment));\n    }\n}","mutatedSourceCode":"<?php\n\nnamespace Fido\\PHPXray\\Submission;\n\nuse Error;\nuse Fido\\PHPXray\\Segment;\nuse Socket;\nuse function socket_create;\nuse function socket_last_error;\nclass DaemonSegmentSubmitter implements SegmentSubmitter\n{\n    protected const MAX_SEGMENT_SIZE = 64000;\n    \/**\n     * @var array<string, mixed>\n     *\/\n    public const HEADER = ['format' => 'json', 'version' => 1];\n    private string $host;\n    private int $port;\n    \/** @var Socket *\/\n    private $socket;\n    public function __construct(string $host = '127.0.0.1', int $port = 2000)\n    {\n        if (isset($_SERVER['AWS_XRAY_DAEMON_ADDRESS'])) {\n            [$host, $port] = explode(\":\", $_SERVER['AWS_XRAY_DAEMON_ADDRESS']);\n        }\n        $this->host = $_SERVER['_AWS_XRAY_DAEMON_ADDRESS'] ?? $host;\n        $this->port = (int) ($_SERVER['_AWS_XRAY_DAEMON_PORT'] ?? $port);\n        if (!($socket = socket_create(AF_INET, SOCK_DGRAM, SOL_UDP))) {\n            throw new Error('Can\\'t create socket: ' . socket_last_error());\n        }\n        $this->socket = $socket;\n    }\n    public function __destruct()\n    {\n        socket_close($this->socket);\n    }\n    public function submitSegment(Segment $segment) : void\n    {\n        $packet = $this->buildPacket($segment);\n        $packetLength = strlen($packet);\n        if ($packetLength > self::MAX_SEGMENT_SIZE) {\n            $this->submitFragmented($segment);\n            return;\n        }\n        $this->sendPacket($packet);\n    }\n    \/**\n     * @param Segment|array<string, mixed> $segment\n     *\/\n    private function buildPacket(Segment|array $segment) : string\n    {\n        return implode(\"\\n\", array_map('json_encode', [self::HEADER, $segment]));\n    }\n    private function sendPacket(string $packet) : void\n    {\n        socket_sendto($this->socket, $packet, strlen($packet), 0, $this->host, $this->port);\n    }\n    private function submitFragmented(Segment $segment) : void\n    {\n        $rawSegment = $segment->jsonSerialize();\n        \/** @var Segment[] $subsegments *\/\n        $subsegments = $rawSegment['subsegments'] ?? [];\n        unset($rawSegment['subsegments']);\n        $this->submitOpenSegment($rawSegment);\n        foreach ($subsegments as $subsegment) {\n            $subsegment = $subsegment;\n            $subsegment->setParentId($segment->getId())->setTraceId($segment->getTraceId())->setIndependent(true);\n            $this->submitSegment($subsegment);\n        }\n        $completePacket = $this->buildPacket($rawSegment);\n        $this->sendPacket($completePacket);\n    }\n    \/**\n     * @param array<string, mixed> $openSegment\n     *\/\n    private function submitOpenSegment(array $openSegment) : void\n    {\n        unset($openSegment['end_time']);\n        $openSegment['in_progress'] = true;\n        $this->sendPacket($this->buildPacket($openSegment));\n    }\n}","originalFilePath":"\/home\/ranpafin\/php-xray\/src\/Submission\/DaemonSegmentSubmitter.php","originalStartLine":83},"diff":"--- Original\n+++ New\n@@ @@\n         unset($rawSegment['subsegments']);\n         $this->submitOpenSegment($rawSegment);\n         foreach ($subsegments as $subsegment) {\n-            $subsegment = clone $subsegment;\n+            $subsegment = $subsegment;\n             $subsegment->setParentId($segment->getId())->setTraceId($segment->getTraceId())->setIndependent(true);\n             $this->submitSegment($subsegment);\n         }","processOutput":"PHPUnit 9.5.10 by Sebastian Bergmann and contributors.\n\nRuntime:       PHP 8.0.13\nConfiguration: \/tmp\/tmp-folder\/infection\/phpunitConfiguration.6ff0cc43be93f2e492f996e07cfb30e1.infection.xml\n\nE\n\nTime: 00:00.003, Memory: 8.00 MB\n\nThere was 1 error:\n\n1) Fido\\PHPXray\\DaemonSegmentSubmitterTest::testSubmitsToDaemon\nsocket_bind(): Unable to bind address [98]: Address already in use\n\n\/home\/ranpafin\/php-xray\/tests\/DaemonSegmentSubmitterTest.php:18\n\nERRORS!\nTests: 1, Assertions: 0, Errors: 1."},{"mutator":{"mutatorName":"MethodCallRemoval","originalSourceCode":"<?php\n\nnamespace Fido\\PHPXray\\Submission;\n\nuse Error;\nuse Fido\\PHPXray\\Segment;\nuse Socket;\nuse function socket_create;\nuse function socket_last_error;\nclass DaemonSegmentSubmitter implements SegmentSubmitter\n{\n    protected const MAX_SEGMENT_SIZE = 64000;\n    \/**\n     * @var array<string, mixed>\n     *\/\n    public const HEADER = ['format' => 'json', 'version' => 1];\n    private string $host;\n    private int $port;\n    \/** @var Socket *\/\n    private $socket;\n    public function __construct(string $host = '127.0.0.1', int $port = 2000)\n    {\n        if (isset($_SERVER['AWS_XRAY_DAEMON_ADDRESS'])) {\n            [$host, $port] = explode(\":\", $_SERVER['AWS_XRAY_DAEMON_ADDRESS']);\n        }\n        $this->host = $_SERVER['_AWS_XRAY_DAEMON_ADDRESS'] ?? $host;\n        $this->port = (int) ($_SERVER['_AWS_XRAY_DAEMON_PORT'] ?? $port);\n        if (!($socket = socket_create(AF_INET, SOCK_DGRAM, SOL_UDP))) {\n            throw new Error('Can\\'t create socket: ' . socket_last_error());\n        }\n        $this->socket = $socket;\n    }\n    public function __destruct()\n    {\n        socket_close($this->socket);\n    }\n    public function submitSegment(Segment $segment) : void\n    {\n        $packet = $this->buildPacket($segment);\n        $packetLength = strlen($packet);\n        if ($packetLength > self::MAX_SEGMENT_SIZE) {\n            $this->submitFragmented($segment);\n            return;\n        }\n        $this->sendPacket($packet);\n    }\n    \/**\n     * @param Segment|array<string, mixed> $segment\n     *\/\n    private function buildPacket(Segment|array $segment) : string\n    {\n        return implode(\"\\n\", array_map('json_encode', [self::HEADER, $segment]));\n    }\n    private function sendPacket(string $packet) : void\n    {\n        socket_sendto($this->socket, $packet, strlen($packet), 0, $this->host, $this->port);\n    }\n    private function submitFragmented(Segment $segment) : void\n    {\n        $rawSegment = $segment->jsonSerialize();\n        \/** @var Segment[] $subsegments *\/\n        $subsegments = $rawSegment['subsegments'] ?? [];\n        unset($rawSegment['subsegments']);\n        $this->submitOpenSegment($rawSegment);\n        foreach ($subsegments as $subsegment) {\n            $subsegment = clone $subsegment;\n            $subsegment->setParentId($segment->getId())->setTraceId($segment->getTraceId())->setIndependent(true);\n            $this->submitSegment($subsegment);\n        }\n        $completePacket = $this->buildPacket($rawSegment);\n        $this->sendPacket($completePacket);\n    }\n    \/**\n     * @param array<string, mixed> $openSegment\n     *\/\n    private function submitOpenSegment(array $openSegment) : void\n    {\n        unset($openSegment['end_time']);\n        $openSegment['in_progress'] = true;\n        $this->sendPacket($this->buildPacket($openSegment));\n    }\n}","mutatedSourceCode":"<?php\n\nnamespace Fido\\PHPXray\\Submission;\n\nuse Error;\nuse Fido\\PHPXray\\Segment;\nuse Socket;\nuse function socket_create;\nuse function socket_last_error;\nclass DaemonSegmentSubmitter implements SegmentSubmitter\n{\n    protected const MAX_SEGMENT_SIZE = 64000;\n    \/**\n     * @var array<string, mixed>\n     *\/\n    public const HEADER = ['format' => 'json', 'version' => 1];\n    private string $host;\n    private int $port;\n    \/** @var Socket *\/\n    private $socket;\n    public function __construct(string $host = '127.0.0.1', int $port = 2000)\n    {\n        if (isset($_SERVER['AWS_XRAY_DAEMON_ADDRESS'])) {\n            [$host, $port] = explode(\":\", $_SERVER['AWS_XRAY_DAEMON_ADDRESS']);\n        }\n        $this->host = $_SERVER['_AWS_XRAY_DAEMON_ADDRESS'] ?? $host;\n        $this->port = (int) ($_SERVER['_AWS_XRAY_DAEMON_PORT'] ?? $port);\n        if (!($socket = socket_create(AF_INET, SOCK_DGRAM, SOL_UDP))) {\n            throw new Error('Can\\'t create socket: ' . socket_last_error());\n        }\n        $this->socket = $socket;\n    }\n    public function __destruct()\n    {\n        socket_close($this->socket);\n    }\n    public function submitSegment(Segment $segment) : void\n    {\n        $packet = $this->buildPacket($segment);\n        $packetLength = strlen($packet);\n        if ($packetLength > self::MAX_SEGMENT_SIZE) {\n            $this->submitFragmented($segment);\n            return;\n        }\n        $this->sendPacket($packet);\n    }\n    \/**\n     * @param Segment|array<string, mixed> $segment\n     *\/\n    private function buildPacket(Segment|array $segment) : string\n    {\n        return implode(\"\\n\", array_map('json_encode', [self::HEADER, $segment]));\n    }\n    private function sendPacket(string $packet) : void\n    {\n        socket_sendto($this->socket, $packet, strlen($packet), 0, $this->host, $this->port);\n    }\n    private function submitFragmented(Segment $segment) : void\n    {\n        $rawSegment = $segment->jsonSerialize();\n        \/** @var Segment[] $subsegments *\/\n        $subsegments = $rawSegment['subsegments'] ?? [];\n        unset($rawSegment['subsegments']);\n        $this->submitOpenSegment($rawSegment);\n        foreach ($subsegments as $subsegment) {\n            $subsegment = clone $subsegment;\n            \n            $this->submitSegment($subsegment);\n        }\n        $completePacket = $this->buildPacket($rawSegment);\n        $this->sendPacket($completePacket);\n    }\n    \/**\n     * @param array<string, mixed> $openSegment\n     *\/\n    private function submitOpenSegment(array $openSegment) : void\n    {\n        unset($openSegment['end_time']);\n        $openSegment['in_progress'] = true;\n        $this->sendPacket($this->buildPacket($openSegment));\n    }\n}","originalFilePath":"\/home\/ranpafin\/php-xray\/src\/Submission\/DaemonSegmentSubmitter.php","originalStartLine":84},"diff":"--- Original\n+++ New\n@@ @@\n         $this->submitOpenSegment($rawSegment);\n         foreach ($subsegments as $subsegment) {\n             $subsegment = clone $subsegment;\n-            $subsegment->setParentId($segment->getId())->setTraceId($segment->getTraceId())->setIndependent(true);\n+            \n             $this->submitSegment($subsegment);\n         }\n         $completePacket = $this->buildPacket($rawSegment);","processOutput":"PHPUnit 9.5.10 by Sebastian Bergmann and contributors.\n\nRuntime:       PHP 8.0.13\nConfiguration: \/tmp\/tmp-folder\/infection\/phpunitConfiguration.40103f12c7b34e41d0be4c810edb8f74.infection.xml\n\nE\n\nTime: 00:00.003, Memory: 8.00 MB\n\nThere was 1 error:\n\n1) Fido\\PHPXray\\DaemonSegmentSubmitterTest::testSubmitsToDaemon\nsocket_bind(): Unable to bind address [98]: Address already in use\n\n\/home\/ranpafin\/php-xray\/tests\/DaemonSegmentSubmitterTest.php:18\n\nERRORS!\nTests: 1, Assertions: 0, Errors: 1."},{"mutator":{"mutatorName":"TrueValue","originalSourceCode":"<?php\n\nnamespace Fido\\PHPXray\\Submission;\n\nuse Error;\nuse Fido\\PHPXray\\Segment;\nuse Socket;\nuse function socket_create;\nuse function socket_last_error;\nclass DaemonSegmentSubmitter implements SegmentSubmitter\n{\n    protected const MAX_SEGMENT_SIZE = 64000;\n    \/**\n     * @var array<string, mixed>\n     *\/\n    public const HEADER = ['format' => 'json', 'version' => 1];\n    private string $host;\n    private int $port;\n    \/** @var Socket *\/\n    private $socket;\n    public function __construct(string $host = '127.0.0.1', int $port = 2000)\n    {\n        if (isset($_SERVER['AWS_XRAY_DAEMON_ADDRESS'])) {\n            [$host, $port] = explode(\":\", $_SERVER['AWS_XRAY_DAEMON_ADDRESS']);\n        }\n        $this->host = $_SERVER['_AWS_XRAY_DAEMON_ADDRESS'] ?? $host;\n        $this->port = (int) ($_SERVER['_AWS_XRAY_DAEMON_PORT'] ?? $port);\n        if (!($socket = socket_create(AF_INET, SOCK_DGRAM, SOL_UDP))) {\n            throw new Error('Can\\'t create socket: ' . socket_last_error());\n        }\n        $this->socket = $socket;\n    }\n    public function __destruct()\n    {\n        socket_close($this->socket);\n    }\n    public function submitSegment(Segment $segment) : void\n    {\n        $packet = $this->buildPacket($segment);\n        $packetLength = strlen($packet);\n        if ($packetLength > self::MAX_SEGMENT_SIZE) {\n            $this->submitFragmented($segment);\n            return;\n        }\n        $this->sendPacket($packet);\n    }\n    \/**\n     * @param Segment|array<string, mixed> $segment\n     *\/\n    private function buildPacket(Segment|array $segment) : string\n    {\n        return implode(\"\\n\", array_map('json_encode', [self::HEADER, $segment]));\n    }\n    private function sendPacket(string $packet) : void\n    {\n        socket_sendto($this->socket, $packet, strlen($packet), 0, $this->host, $this->port);\n    }\n    private function submitFragmented(Segment $segment) : void\n    {\n        $rawSegment = $segment->jsonSerialize();\n        \/** @var Segment[] $subsegments *\/\n        $subsegments = $rawSegment['subsegments'] ?? [];\n        unset($rawSegment['subsegments']);\n        $this->submitOpenSegment($rawSegment);\n        foreach ($subsegments as $subsegment) {\n            $subsegment = clone $subsegment;\n            $subsegment->setParentId($segment->getId())->setTraceId($segment->getTraceId())->setIndependent(true);\n            $this->submitSegment($subsegment);\n        }\n        $completePacket = $this->buildPacket($rawSegment);\n        $this->sendPacket($completePacket);\n    }\n    \/**\n     * @param array<string, mixed> $openSegment\n     *\/\n    private function submitOpenSegment(array $openSegment) : void\n    {\n        unset($openSegment['end_time']);\n        $openSegment['in_progress'] = true;\n        $this->sendPacket($this->buildPacket($openSegment));\n    }\n}","mutatedSourceCode":"<?php\n\nnamespace Fido\\PHPXray\\Submission;\n\nuse Error;\nuse Fido\\PHPXray\\Segment;\nuse Socket;\nuse function socket_create;\nuse function socket_last_error;\nclass DaemonSegmentSubmitter implements SegmentSubmitter\n{\n    protected const MAX_SEGMENT_SIZE = 64000;\n    \/**\n     * @var array<string, mixed>\n     *\/\n    public const HEADER = ['format' => 'json', 'version' => 1];\n    private string $host;\n    private int $port;\n    \/** @var Socket *\/\n    private $socket;\n    public function __construct(string $host = '127.0.0.1', int $port = 2000)\n    {\n        if (isset($_SERVER['AWS_XRAY_DAEMON_ADDRESS'])) {\n            [$host, $port] = explode(\":\", $_SERVER['AWS_XRAY_DAEMON_ADDRESS']);\n        }\n        $this->host = $_SERVER['_AWS_XRAY_DAEMON_ADDRESS'] ?? $host;\n        $this->port = (int) ($_SERVER['_AWS_XRAY_DAEMON_PORT'] ?? $port);\n        if (!($socket = socket_create(AF_INET, SOCK_DGRAM, SOL_UDP))) {\n            throw new Error('Can\\'t create socket: ' . socket_last_error());\n        }\n        $this->socket = $socket;\n    }\n    public function __destruct()\n    {\n        socket_close($this->socket);\n    }\n    public function submitSegment(Segment $segment) : void\n    {\n        $packet = $this->buildPacket($segment);\n        $packetLength = strlen($packet);\n        if ($packetLength > self::MAX_SEGMENT_SIZE) {\n            $this->submitFragmented($segment);\n            return;\n        }\n        $this->sendPacket($packet);\n    }\n    \/**\n     * @param Segment|array<string, mixed> $segment\n     *\/\n    private function buildPacket(Segment|array $segment) : string\n    {\n        return implode(\"\\n\", array_map('json_encode', [self::HEADER, $segment]));\n    }\n    private function sendPacket(string $packet) : void\n    {\n        socket_sendto($this->socket, $packet, strlen($packet), 0, $this->host, $this->port);\n    }\n    private function submitFragmented(Segment $segment) : void\n    {\n        $rawSegment = $segment->jsonSerialize();\n        \/** @var Segment[] $subsegments *\/\n        $subsegments = $rawSegment['subsegments'] ?? [];\n        unset($rawSegment['subsegments']);\n        $this->submitOpenSegment($rawSegment);\n        foreach ($subsegments as $subsegment) {\n            $subsegment = clone $subsegment;\n            $subsegment->setParentId($segment->getId())->setTraceId($segment->getTraceId())->setIndependent(false);\n            $this->submitSegment($subsegment);\n        }\n        $completePacket = $this->buildPacket($rawSegment);\n        $this->sendPacket($completePacket);\n    }\n    \/**\n     * @param array<string, mixed> $openSegment\n     *\/\n    private function submitOpenSegment(array $openSegment) : void\n    {\n        unset($openSegment['end_time']);\n        $openSegment['in_progress'] = true;\n        $this->sendPacket($this->buildPacket($openSegment));\n    }\n}","originalFilePath":"\/home\/ranpafin\/php-xray\/src\/Submission\/DaemonSegmentSubmitter.php","originalStartLine":87},"diff":"--- Original\n+++ New\n@@ @@\n         $this->submitOpenSegment($rawSegment);\n         foreach ($subsegments as $subsegment) {\n             $subsegment = clone $subsegment;\n-            $subsegment->setParentId($segment->getId())->setTraceId($segment->getTraceId())->setIndependent(true);\n+            $subsegment->setParentId($segment->getId())->setTraceId($segment->getTraceId())->setIndependent(false);\n             $this->submitSegment($subsegment);\n         }\n         $completePacket = $this->buildPacket($rawSegment);","processOutput":"PHPUnit 9.5.10 by Sebastian Bergmann and contributors.\n\nRuntime:       PHP 8.0.13\nConfiguration: \/tmp\/tmp-folder\/infection\/phpunitConfiguration.7ea67f4060c535b392882ef4e5276382.infection.xml\n\nE\n\nTime: 00:00.003, Memory: 8.00 MB\n\nThere was 1 error:\n\n1) Fido\\PHPXray\\DaemonSegmentSubmitterTest::testSubmitsToDaemon\nsocket_bind(): Unable to bind address [98]: Address already in use\n\n\/home\/ranpafin\/php-xray\/tests\/DaemonSegmentSubmitterTest.php:18\n\nERRORS!\nTests: 1, Assertions: 0, Errors: 1."},{"mutator":{"mutatorName":"MethodCallRemoval","originalSourceCode":"<?php\n\nnamespace Fido\\PHPXray\\Submission;\n\nuse Error;\nuse Fido\\PHPXray\\Segment;\nuse Socket;\nuse function socket_create;\nuse function socket_last_error;\nclass DaemonSegmentSubmitter implements SegmentSubmitter\n{\n    protected const MAX_SEGMENT_SIZE = 64000;\n    \/**\n     * @var array<string, mixed>\n     *\/\n    public const HEADER = ['format' => 'json', 'version' => 1];\n    private string $host;\n    private int $port;\n    \/** @var Socket *\/\n    private $socket;\n    public function __construct(string $host = '127.0.0.1', int $port = 2000)\n    {\n        if (isset($_SERVER['AWS_XRAY_DAEMON_ADDRESS'])) {\n            [$host, $port] = explode(\":\", $_SERVER['AWS_XRAY_DAEMON_ADDRESS']);\n        }\n        $this->host = $_SERVER['_AWS_XRAY_DAEMON_ADDRESS'] ?? $host;\n        $this->port = (int) ($_SERVER['_AWS_XRAY_DAEMON_PORT'] ?? $port);\n        if (!($socket = socket_create(AF_INET, SOCK_DGRAM, SOL_UDP))) {\n            throw new Error('Can\\'t create socket: ' . socket_last_error());\n        }\n        $this->socket = $socket;\n    }\n    public function __destruct()\n    {\n        socket_close($this->socket);\n    }\n    public function submitSegment(Segment $segment) : void\n    {\n        $packet = $this->buildPacket($segment);\n        $packetLength = strlen($packet);\n        if ($packetLength > self::MAX_SEGMENT_SIZE) {\n            $this->submitFragmented($segment);\n            return;\n        }\n        $this->sendPacket($packet);\n    }\n    \/**\n     * @param Segment|array<string, mixed> $segment\n     *\/\n    private function buildPacket(Segment|array $segment) : string\n    {\n        return implode(\"\\n\", array_map('json_encode', [self::HEADER, $segment]));\n    }\n    private function sendPacket(string $packet) : void\n    {\n        socket_sendto($this->socket, $packet, strlen($packet), 0, $this->host, $this->port);\n    }\n    private function submitFragmented(Segment $segment) : void\n    {\n        $rawSegment = $segment->jsonSerialize();\n        \/** @var Segment[] $subsegments *\/\n        $subsegments = $rawSegment['subsegments'] ?? [];\n        unset($rawSegment['subsegments']);\n        $this->submitOpenSegment($rawSegment);\n        foreach ($subsegments as $subsegment) {\n            $subsegment = clone $subsegment;\n            $subsegment->setParentId($segment->getId())->setTraceId($segment->getTraceId())->setIndependent(true);\n            $this->submitSegment($subsegment);\n        }\n        $completePacket = $this->buildPacket($rawSegment);\n        $this->sendPacket($completePacket);\n    }\n    \/**\n     * @param array<string, mixed> $openSegment\n     *\/\n    private function submitOpenSegment(array $openSegment) : void\n    {\n        unset($openSegment['end_time']);\n        $openSegment['in_progress'] = true;\n        $this->sendPacket($this->buildPacket($openSegment));\n    }\n}","mutatedSourceCode":"<?php\n\nnamespace Fido\\PHPXray\\Submission;\n\nuse Error;\nuse Fido\\PHPXray\\Segment;\nuse Socket;\nuse function socket_create;\nuse function socket_last_error;\nclass DaemonSegmentSubmitter implements SegmentSubmitter\n{\n    protected const MAX_SEGMENT_SIZE = 64000;\n    \/**\n     * @var array<string, mixed>\n     *\/\n    public const HEADER = ['format' => 'json', 'version' => 1];\n    private string $host;\n    private int $port;\n    \/** @var Socket *\/\n    private $socket;\n    public function __construct(string $host = '127.0.0.1', int $port = 2000)\n    {\n        if (isset($_SERVER['AWS_XRAY_DAEMON_ADDRESS'])) {\n            [$host, $port] = explode(\":\", $_SERVER['AWS_XRAY_DAEMON_ADDRESS']);\n        }\n        $this->host = $_SERVER['_AWS_XRAY_DAEMON_ADDRESS'] ?? $host;\n        $this->port = (int) ($_SERVER['_AWS_XRAY_DAEMON_PORT'] ?? $port);\n        if (!($socket = socket_create(AF_INET, SOCK_DGRAM, SOL_UDP))) {\n            throw new Error('Can\\'t create socket: ' . socket_last_error());\n        }\n        $this->socket = $socket;\n    }\n    public function __destruct()\n    {\n        socket_close($this->socket);\n    }\n    public function submitSegment(Segment $segment) : void\n    {\n        $packet = $this->buildPacket($segment);\n        $packetLength = strlen($packet);\n        if ($packetLength > self::MAX_SEGMENT_SIZE) {\n            $this->submitFragmented($segment);\n            return;\n        }\n        $this->sendPacket($packet);\n    }\n    \/**\n     * @param Segment|array<string, mixed> $segment\n     *\/\n    private function buildPacket(Segment|array $segment) : string\n    {\n        return implode(\"\\n\", array_map('json_encode', [self::HEADER, $segment]));\n    }\n    private function sendPacket(string $packet) : void\n    {\n        socket_sendto($this->socket, $packet, strlen($packet), 0, $this->host, $this->port);\n    }\n    private function submitFragmented(Segment $segment) : void\n    {\n        $rawSegment = $segment->jsonSerialize();\n        \/** @var Segment[] $subsegments *\/\n        $subsegments = $rawSegment['subsegments'] ?? [];\n        unset($rawSegment['subsegments']);\n        $this->submitOpenSegment($rawSegment);\n        foreach ($subsegments as $subsegment) {\n            $subsegment = clone $subsegment;\n            $subsegment->setParentId($segment->getId())->setTraceId($segment->getTraceId())->setIndependent(true);\n            \n        }\n        $completePacket = $this->buildPacket($rawSegment);\n        $this->sendPacket($completePacket);\n    }\n    \/**\n     * @param array<string, mixed> $openSegment\n     *\/\n    private function submitOpenSegment(array $openSegment) : void\n    {\n        unset($openSegment['end_time']);\n        $openSegment['in_progress'] = true;\n        $this->sendPacket($this->buildPacket($openSegment));\n    }\n}","originalFilePath":"\/home\/ranpafin\/php-xray\/src\/Submission\/DaemonSegmentSubmitter.php","originalStartLine":89},"diff":"--- Original\n+++ New\n@@ @@\n         foreach ($subsegments as $subsegment) {\n             $subsegment = clone $subsegment;\n             $subsegment->setParentId($segment->getId())->setTraceId($segment->getTraceId())->setIndependent(true);\n-            $this->submitSegment($subsegment);\n+            \n         }\n         $completePacket = $this->buildPacket($rawSegment);\n         $this->sendPacket($completePacket);","processOutput":"PHPUnit 9.5.10 by Sebastian Bergmann and contributors.\n\nRuntime:       PHP 8.0.13\nConfiguration: \/tmp\/tmp-folder\/infection\/phpunitConfiguration.2c81aae0e0c84e60917d6ec6c67d7743.infection.xml\n\nE\n\nTime: 00:00.003, Memory: 8.00 MB\n\nThere was 1 error:\n\n1) Fido\\PHPXray\\DaemonSegmentSubmitterTest::testSubmitsToDaemon\nsocket_bind(): Unable to bind address [98]: Address already in use\n\n\/home\/ranpafin\/php-xray\/tests\/DaemonSegmentSubmitterTest.php:18\n\nERRORS!\nTests: 1, Assertions: 0, Errors: 1."},{"mutator":{"mutatorName":"MethodCallRemoval","originalSourceCode":"<?php\n\nnamespace Fido\\PHPXray\\Submission;\n\nuse Error;\nuse Fido\\PHPXray\\Segment;\nuse Socket;\nuse function socket_create;\nuse function socket_last_error;\nclass DaemonSegmentSubmitter implements SegmentSubmitter\n{\n    protected const MAX_SEGMENT_SIZE = 64000;\n    \/**\n     * @var array<string, mixed>\n     *\/\n    public const HEADER = ['format' => 'json', 'version' => 1];\n    private string $host;\n    private int $port;\n    \/** @var Socket *\/\n    private $socket;\n    public function __construct(string $host = '127.0.0.1', int $port = 2000)\n    {\n        if (isset($_SERVER['AWS_XRAY_DAEMON_ADDRESS'])) {\n            [$host, $port] = explode(\":\", $_SERVER['AWS_XRAY_DAEMON_ADDRESS']);\n        }\n        $this->host = $_SERVER['_AWS_XRAY_DAEMON_ADDRESS'] ?? $host;\n        $this->port = (int) ($_SERVER['_AWS_XRAY_DAEMON_PORT'] ?? $port);\n        if (!($socket = socket_create(AF_INET, SOCK_DGRAM, SOL_UDP))) {\n            throw new Error('Can\\'t create socket: ' . socket_last_error());\n        }\n        $this->socket = $socket;\n    }\n    public function __destruct()\n    {\n        socket_close($this->socket);\n    }\n    public function submitSegment(Segment $segment) : void\n    {\n        $packet = $this->buildPacket($segment);\n        $packetLength = strlen($packet);\n        if ($packetLength > self::MAX_SEGMENT_SIZE) {\n            $this->submitFragmented($segment);\n            return;\n        }\n        $this->sendPacket($packet);\n    }\n    \/**\n     * @param Segment|array<string, mixed> $segment\n     *\/\n    private function buildPacket(Segment|array $segment) : string\n    {\n        return implode(\"\\n\", array_map('json_encode', [self::HEADER, $segment]));\n    }\n    private function sendPacket(string $packet) : void\n    {\n        socket_sendto($this->socket, $packet, strlen($packet), 0, $this->host, $this->port);\n    }\n    private function submitFragmented(Segment $segment) : void\n    {\n        $rawSegment = $segment->jsonSerialize();\n        \/** @var Segment[] $subsegments *\/\n        $subsegments = $rawSegment['subsegments'] ?? [];\n        unset($rawSegment['subsegments']);\n        $this->submitOpenSegment($rawSegment);\n        foreach ($subsegments as $subsegment) {\n            $subsegment = clone $subsegment;\n            $subsegment->setParentId($segment->getId())->setTraceId($segment->getTraceId())->setIndependent(true);\n            $this->submitSegment($subsegment);\n        }\n        $completePacket = $this->buildPacket($rawSegment);\n        $this->sendPacket($completePacket);\n    }\n    \/**\n     * @param array<string, mixed> $openSegment\n     *\/\n    private function submitOpenSegment(array $openSegment) : void\n    {\n        unset($openSegment['end_time']);\n        $openSegment['in_progress'] = true;\n        $this->sendPacket($this->buildPacket($openSegment));\n    }\n}","mutatedSourceCode":"<?php\n\nnamespace Fido\\PHPXray\\Submission;\n\nuse Error;\nuse Fido\\PHPXray\\Segment;\nuse Socket;\nuse function socket_create;\nuse function socket_last_error;\nclass DaemonSegmentSubmitter implements SegmentSubmitter\n{\n    protected const MAX_SEGMENT_SIZE = 64000;\n    \/**\n     * @var array<string, mixed>\n     *\/\n    public const HEADER = ['format' => 'json', 'version' => 1];\n    private string $host;\n    private int $port;\n    \/** @var Socket *\/\n    private $socket;\n    public function __construct(string $host = '127.0.0.1', int $port = 2000)\n    {\n        if (isset($_SERVER['AWS_XRAY_DAEMON_ADDRESS'])) {\n            [$host, $port] = explode(\":\", $_SERVER['AWS_XRAY_DAEMON_ADDRESS']);\n        }\n        $this->host = $_SERVER['_AWS_XRAY_DAEMON_ADDRESS'] ?? $host;\n        $this->port = (int) ($_SERVER['_AWS_XRAY_DAEMON_PORT'] ?? $port);\n        if (!($socket = socket_create(AF_INET, SOCK_DGRAM, SOL_UDP))) {\n            throw new Error('Can\\'t create socket: ' . socket_last_error());\n        }\n        $this->socket = $socket;\n    }\n    public function __destruct()\n    {\n        socket_close($this->socket);\n    }\n    public function submitSegment(Segment $segment) : void\n    {\n        $packet = $this->buildPacket($segment);\n        $packetLength = strlen($packet);\n        if ($packetLength > self::MAX_SEGMENT_SIZE) {\n            $this->submitFragmented($segment);\n            return;\n        }\n        $this->sendPacket($packet);\n    }\n    \/**\n     * @param Segment|array<string, mixed> $segment\n     *\/\n    private function buildPacket(Segment|array $segment) : string\n    {\n        return implode(\"\\n\", array_map('json_encode', [self::HEADER, $segment]));\n    }\n    private function sendPacket(string $packet) : void\n    {\n        socket_sendto($this->socket, $packet, strlen($packet), 0, $this->host, $this->port);\n    }\n    private function submitFragmented(Segment $segment) : void\n    {\n        $rawSegment = $segment->jsonSerialize();\n        \/** @var Segment[] $subsegments *\/\n        $subsegments = $rawSegment['subsegments'] ?? [];\n        unset($rawSegment['subsegments']);\n        $this->submitOpenSegment($rawSegment);\n        foreach ($subsegments as $subsegment) {\n            $subsegment = clone $subsegment;\n            $subsegment->setParentId($segment->getId())->setTraceId($segment->getTraceId())->setIndependent(true);\n            $this->submitSegment($subsegment);\n        }\n        $completePacket = $this->buildPacket($rawSegment);\n        \n    }\n    \/**\n     * @param array<string, mixed> $openSegment\n     *\/\n    private function submitOpenSegment(array $openSegment) : void\n    {\n        unset($openSegment['end_time']);\n        $openSegment['in_progress'] = true;\n        $this->sendPacket($this->buildPacket($openSegment));\n    }\n}","originalFilePath":"\/home\/ranpafin\/php-xray\/src\/Submission\/DaemonSegmentSubmitter.php","originalStartLine":93},"diff":"--- Original\n+++ New\n@@ @@\n             $this->submitSegment($subsegment);\n         }\n         $completePacket = $this->buildPacket($rawSegment);\n-        $this->sendPacket($completePacket);\n+        \n     }\n     \/**\n      * @param array<string, mixed> $openSegment","processOutput":"PHPUnit 9.5.10 by Sebastian Bergmann and contributors.\n\nRuntime:       PHP 8.0.13\nConfiguration: \/tmp\/tmp-folder\/infection\/phpunitConfiguration.bfc6d1bb52255aaa7773a0315a87d06d.infection.xml\n\nE\n\nTime: 00:00.003, Memory: 8.00 MB\n\nThere was 1 error:\n\n1) Fido\\PHPXray\\DaemonSegmentSubmitterTest::testSubmitsToDaemon\nsocket_bind(): Unable to bind address [98]: Address already in use\n\n\/home\/ranpafin\/php-xray\/tests\/DaemonSegmentSubmitterTest.php:18\n\nERRORS!\nTests: 1, Assertions: 0, Errors: 1."},{"mutator":{"mutatorName":"TrueValue","originalSourceCode":"<?php\n\nnamespace Fido\\PHPXray\\Submission;\n\nuse Error;\nuse Fido\\PHPXray\\Segment;\nuse Socket;\nuse function socket_create;\nuse function socket_last_error;\nclass DaemonSegmentSubmitter implements SegmentSubmitter\n{\n    protected const MAX_SEGMENT_SIZE = 64000;\n    \/**\n     * @var array<string, mixed>\n     *\/\n    public const HEADER = ['format' => 'json', 'version' => 1];\n    private string $host;\n    private int $port;\n    \/** @var Socket *\/\n    private $socket;\n    public function __construct(string $host = '127.0.0.1', int $port = 2000)\n    {\n        if (isset($_SERVER['AWS_XRAY_DAEMON_ADDRESS'])) {\n            [$host, $port] = explode(\":\", $_SERVER['AWS_XRAY_DAEMON_ADDRESS']);\n        }\n        $this->host = $_SERVER['_AWS_XRAY_DAEMON_ADDRESS'] ?? $host;\n        $this->port = (int) ($_SERVER['_AWS_XRAY_DAEMON_PORT'] ?? $port);\n        if (!($socket = socket_create(AF_INET, SOCK_DGRAM, SOL_UDP))) {\n            throw new Error('Can\\'t create socket: ' . socket_last_error());\n        }\n        $this->socket = $socket;\n    }\n    public function __destruct()\n    {\n        socket_close($this->socket);\n    }\n    public function submitSegment(Segment $segment) : void\n    {\n        $packet = $this->buildPacket($segment);\n        $packetLength = strlen($packet);\n        if ($packetLength > self::MAX_SEGMENT_SIZE) {\n            $this->submitFragmented($segment);\n            return;\n        }\n        $this->sendPacket($packet);\n    }\n    \/**\n     * @param Segment|array<string, mixed> $segment\n     *\/\n    private function buildPacket(Segment|array $segment) : string\n    {\n        return implode(\"\\n\", array_map('json_encode', [self::HEADER, $segment]));\n    }\n    private function sendPacket(string $packet) : void\n    {\n        socket_sendto($this->socket, $packet, strlen($packet), 0, $this->host, $this->port);\n    }\n    private function submitFragmented(Segment $segment) : void\n    {\n        $rawSegment = $segment->jsonSerialize();\n        \/** @var Segment[] $subsegments *\/\n        $subsegments = $rawSegment['subsegments'] ?? [];\n        unset($rawSegment['subsegments']);\n        $this->submitOpenSegment($rawSegment);\n        foreach ($subsegments as $subsegment) {\n            $subsegment = clone $subsegment;\n            $subsegment->setParentId($segment->getId())->setTraceId($segment->getTraceId())->setIndependent(true);\n            $this->submitSegment($subsegment);\n        }\n        $completePacket = $this->buildPacket($rawSegment);\n        $this->sendPacket($completePacket);\n    }\n    \/**\n     * @param array<string, mixed> $openSegment\n     *\/\n    private function submitOpenSegment(array $openSegment) : void\n    {\n        unset($openSegment['end_time']);\n        $openSegment['in_progress'] = true;\n        $this->sendPacket($this->buildPacket($openSegment));\n    }\n}","mutatedSourceCode":"<?php\n\nnamespace Fido\\PHPXray\\Submission;\n\nuse Error;\nuse Fido\\PHPXray\\Segment;\nuse Socket;\nuse function socket_create;\nuse function socket_last_error;\nclass DaemonSegmentSubmitter implements SegmentSubmitter\n{\n    protected const MAX_SEGMENT_SIZE = 64000;\n    \/**\n     * @var array<string, mixed>\n     *\/\n    public const HEADER = ['format' => 'json', 'version' => 1];\n    private string $host;\n    private int $port;\n    \/** @var Socket *\/\n    private $socket;\n    public function __construct(string $host = '127.0.0.1', int $port = 2000)\n    {\n        if (isset($_SERVER['AWS_XRAY_DAEMON_ADDRESS'])) {\n            [$host, $port] = explode(\":\", $_SERVER['AWS_XRAY_DAEMON_ADDRESS']);\n        }\n        $this->host = $_SERVER['_AWS_XRAY_DAEMON_ADDRESS'] ?? $host;\n        $this->port = (int) ($_SERVER['_AWS_XRAY_DAEMON_PORT'] ?? $port);\n        if (!($socket = socket_create(AF_INET, SOCK_DGRAM, SOL_UDP))) {\n            throw new Error('Can\\'t create socket: ' . socket_last_error());\n        }\n        $this->socket = $socket;\n    }\n    public function __destruct()\n    {\n        socket_close($this->socket);\n    }\n    public function submitSegment(Segment $segment) : void\n    {\n        $packet = $this->buildPacket($segment);\n        $packetLength = strlen($packet);\n        if ($packetLength > self::MAX_SEGMENT_SIZE) {\n            $this->submitFragmented($segment);\n            return;\n        }\n        $this->sendPacket($packet);\n    }\n    \/**\n     * @param Segment|array<string, mixed> $segment\n     *\/\n    private function buildPacket(Segment|array $segment) : string\n    {\n        return implode(\"\\n\", array_map('json_encode', [self::HEADER, $segment]));\n    }\n    private function sendPacket(string $packet) : void\n    {\n        socket_sendto($this->socket, $packet, strlen($packet), 0, $this->host, $this->port);\n    }\n    private function submitFragmented(Segment $segment) : void\n    {\n        $rawSegment = $segment->jsonSerialize();\n        \/** @var Segment[] $subsegments *\/\n        $subsegments = $rawSegment['subsegments'] ?? [];\n        unset($rawSegment['subsegments']);\n        $this->submitOpenSegment($rawSegment);\n        foreach ($subsegments as $subsegment) {\n            $subsegment = clone $subsegment;\n            $subsegment->setParentId($segment->getId())->setTraceId($segment->getTraceId())->setIndependent(true);\n            $this->submitSegment($subsegment);\n        }\n        $completePacket = $this->buildPacket($rawSegment);\n        $this->sendPacket($completePacket);\n    }\n    \/**\n     * @param array<string, mixed> $openSegment\n     *\/\n    private function submitOpenSegment(array $openSegment) : void\n    {\n        unset($openSegment['end_time']);\n        $openSegment['in_progress'] = false;\n        $this->sendPacket($this->buildPacket($openSegment));\n    }\n}","originalFilePath":"\/home\/ranpafin\/php-xray\/src\/Submission\/DaemonSegmentSubmitter.php","originalStartLine":102},"diff":"--- Original\n+++ New\n@@ @@\n     private function submitOpenSegment(array $openSegment) : void\n     {\n         unset($openSegment['end_time']);\n-        $openSegment['in_progress'] = true;\n+        $openSegment['in_progress'] = false;\n         $this->sendPacket($this->buildPacket($openSegment));\n     }\n }","processOutput":"PHPUnit 9.5.10 by Sebastian Bergmann and contributors.\n\nRuntime:       PHP 8.0.13\nConfiguration: \/tmp\/tmp-folder\/infection\/phpunitConfiguration.09948ec9f0ea1cb22f9f8481afd1fc86.infection.xml\n\nE\n\nTime: 00:00.002, Memory: 8.00 MB\n\nThere was 1 error:\n\n1) Fido\\PHPXray\\DaemonSegmentSubmitterTest::testSubmitsToDaemon\nsocket_bind(): Unable to bind address [98]: Address already in use\n\n\/home\/ranpafin\/php-xray\/tests\/DaemonSegmentSubmitterTest.php:18\n\nERRORS!\nTests: 1, Assertions: 0, Errors: 1."},{"mutator":{"mutatorName":"MethodCallRemoval","originalSourceCode":"<?php\n\nnamespace Fido\\PHPXray\\Submission;\n\nuse Error;\nuse Fido\\PHPXray\\Segment;\nuse Socket;\nuse function socket_create;\nuse function socket_last_error;\nclass DaemonSegmentSubmitter implements SegmentSubmitter\n{\n    protected const MAX_SEGMENT_SIZE = 64000;\n    \/**\n     * @var array<string, mixed>\n     *\/\n    public const HEADER = ['format' => 'json', 'version' => 1];\n    private string $host;\n    private int $port;\n    \/** @var Socket *\/\n    private $socket;\n    public function __construct(string $host = '127.0.0.1', int $port = 2000)\n    {\n        if (isset($_SERVER['AWS_XRAY_DAEMON_ADDRESS'])) {\n            [$host, $port] = explode(\":\", $_SERVER['AWS_XRAY_DAEMON_ADDRESS']);\n        }\n        $this->host = $_SERVER['_AWS_XRAY_DAEMON_ADDRESS'] ?? $host;\n        $this->port = (int) ($_SERVER['_AWS_XRAY_DAEMON_PORT'] ?? $port);\n        if (!($socket = socket_create(AF_INET, SOCK_DGRAM, SOL_UDP))) {\n            throw new Error('Can\\'t create socket: ' . socket_last_error());\n        }\n        $this->socket = $socket;\n    }\n    public function __destruct()\n    {\n        socket_close($this->socket);\n    }\n    public function submitSegment(Segment $segment) : void\n    {\n        $packet = $this->buildPacket($segment);\n        $packetLength = strlen($packet);\n        if ($packetLength > self::MAX_SEGMENT_SIZE) {\n            $this->submitFragmented($segment);\n            return;\n        }\n        $this->sendPacket($packet);\n    }\n    \/**\n     * @param Segment|array<string, mixed> $segment\n     *\/\n    private function buildPacket(Segment|array $segment) : string\n    {\n        return implode(\"\\n\", array_map('json_encode', [self::HEADER, $segment]));\n    }\n    private function sendPacket(string $packet) : void\n    {\n        socket_sendto($this->socket, $packet, strlen($packet), 0, $this->host, $this->port);\n    }\n    private function submitFragmented(Segment $segment) : void\n    {\n        $rawSegment = $segment->jsonSerialize();\n        \/** @var Segment[] $subsegments *\/\n        $subsegments = $rawSegment['subsegments'] ?? [];\n        unset($rawSegment['subsegments']);\n        $this->submitOpenSegment($rawSegment);\n        foreach ($subsegments as $subsegment) {\n            $subsegment = clone $subsegment;\n            $subsegment->setParentId($segment->getId())->setTraceId($segment->getTraceId())->setIndependent(true);\n            $this->submitSegment($subsegment);\n        }\n        $completePacket = $this->buildPacket($rawSegment);\n        $this->sendPacket($completePacket);\n    }\n    \/**\n     * @param array<string, mixed> $openSegment\n     *\/\n    private function submitOpenSegment(array $openSegment) : void\n    {\n        unset($openSegment['end_time']);\n        $openSegment['in_progress'] = true;\n        $this->sendPacket($this->buildPacket($openSegment));\n    }\n}","mutatedSourceCode":"<?php\n\nnamespace Fido\\PHPXray\\Submission;\n\nuse Error;\nuse Fido\\PHPXray\\Segment;\nuse Socket;\nuse function socket_create;\nuse function socket_last_error;\nclass DaemonSegmentSubmitter implements SegmentSubmitter\n{\n    protected const MAX_SEGMENT_SIZE = 64000;\n    \/**\n     * @var array<string, mixed>\n     *\/\n    public const HEADER = ['format' => 'json', 'version' => 1];\n    private string $host;\n    private int $port;\n    \/** @var Socket *\/\n    private $socket;\n    public function __construct(string $host = '127.0.0.1', int $port = 2000)\n    {\n        if (isset($_SERVER['AWS_XRAY_DAEMON_ADDRESS'])) {\n            [$host, $port] = explode(\":\", $_SERVER['AWS_XRAY_DAEMON_ADDRESS']);\n        }\n        $this->host = $_SERVER['_AWS_XRAY_DAEMON_ADDRESS'] ?? $host;\n        $this->port = (int) ($_SERVER['_AWS_XRAY_DAEMON_PORT'] ?? $port);\n        if (!($socket = socket_create(AF_INET, SOCK_DGRAM, SOL_UDP))) {\n            throw new Error('Can\\'t create socket: ' . socket_last_error());\n        }\n        $this->socket = $socket;\n    }\n    public function __destruct()\n    {\n        socket_close($this->socket);\n    }\n    public function submitSegment(Segment $segment) : void\n    {\n        $packet = $this->buildPacket($segment);\n        $packetLength = strlen($packet);\n        if ($packetLength > self::MAX_SEGMENT_SIZE) {\n            $this->submitFragmented($segment);\n            return;\n        }\n        $this->sendPacket($packet);\n    }\n    \/**\n     * @param Segment|array<string, mixed> $segment\n     *\/\n    private function buildPacket(Segment|array $segment) : string\n    {\n        return implode(\"\\n\", array_map('json_encode', [self::HEADER, $segment]));\n    }\n    private function sendPacket(string $packet) : void\n    {\n        socket_sendto($this->socket, $packet, strlen($packet), 0, $this->host, $this->port);\n    }\n    private function submitFragmented(Segment $segment) : void\n    {\n        $rawSegment = $segment->jsonSerialize();\n        \/** @var Segment[] $subsegments *\/\n        $subsegments = $rawSegment['subsegments'] ?? [];\n        unset($rawSegment['subsegments']);\n        $this->submitOpenSegment($rawSegment);\n        foreach ($subsegments as $subsegment) {\n            $subsegment = clone $subsegment;\n            $subsegment->setParentId($segment->getId())->setTraceId($segment->getTraceId())->setIndependent(true);\n            $this->submitSegment($subsegment);\n        }\n        $completePacket = $this->buildPacket($rawSegment);\n        $this->sendPacket($completePacket);\n    }\n    \/**\n     * @param array<string, mixed> $openSegment\n     *\/\n    private function submitOpenSegment(array $openSegment) : void\n    {\n        unset($openSegment['end_time']);\n        $openSegment['in_progress'] = true;\n        \n    }\n}","originalFilePath":"\/home\/ranpafin\/php-xray\/src\/Submission\/DaemonSegmentSubmitter.php","originalStartLine":104},"diff":"--- Original\n+++ New\n@@ @@\n     {\n         unset($openSegment['end_time']);\n         $openSegment['in_progress'] = true;\n-        $this->sendPacket($this->buildPacket($openSegment));\n+        \n     }\n }","processOutput":"PHPUnit 9.5.10 by Sebastian Bergmann and contributors.\n\nRuntime:       PHP 8.0.13\nConfiguration: \/tmp\/tmp-folder\/infection\/phpunitConfiguration.bb7eff3ad01d1f020c8ab43779d0c600.infection.xml\n\nE\n\nTime: 00:00.003, Memory: 8.00 MB\n\nThere was 1 error:\n\n1) Fido\\PHPXray\\DaemonSegmentSubmitterTest::testSubmitsToDaemon\nsocket_bind(): Unable to bind address [98]: Address already in use\n\n\/home\/ranpafin\/php-xray\/tests\/DaemonSegmentSubmitterTest.php:18\n\nERRORS!\nTests: 1, Assertions: 0, Errors: 1."},{"mutator":{"mutatorName":"PublicVisibility","originalSourceCode":"<?php\n\nnamespace Fido\\PHPXray;\n\nuse Exception;\nclass Trace extends Segment\n{\n    use HttpTrait;\n    private static self $instance;\n    private string $serviceVersion;\n    private string $user;\n    public static function getInstance() : self\n    {\n        if (!isset(self::$instance)) {\n            self::$instance = new self();\n        }\n        return self::$instance;\n    }\n    public function setServiceVersion(string $serviceVersion) : self\n    {\n        $this->serviceVersion = $serviceVersion;\n        return $this;\n    }\n    public function setUser(string $user) : self\n    {\n        $this->user = $user;\n        return $this;\n    }\n    public function setClientIpAddress(string $clientIpAddress) : self\n    {\n        $this->clientIpAddress = $clientIpAddress;\n        return $this;\n    }\n    public function setUserAgent(string $userAgent) : self\n    {\n        $this->userAgent = $userAgent;\n        return $this;\n    }\n    \/**\n     * @throws Exception\n     *\/\n    public function begin(int $samplePercentage = 10) : Segment\n    {\n        parent::begin();\n        if (!isset($this->traceId)) {\n            $this->generateTraceId();\n        }\n        if (!$this->isSampled()) {\n            $this->sampled = random_int(0, 99) < $samplePercentage;\n        }\n        return $this;\n    }\n    \/**\n     * @inheritdoc\n     *\/\n    public function jsonSerialize() : array\n    {\n        $data = parent::jsonSerialize();\n        $data['http'] = $this->serialiseHttpData();\n        $data['service'] = empty($this->serviceVersion) ? null : ['version' => $this->serviceVersion];\n        $data['user'] = $this->user ?? null;\n        return array_filter($data);\n    }\n    \/**\n     * @throws Exception if an appropriate source of randomness cannot be found.\n     *\/\n    private function generateTraceId() : void\n    {\n        $startHex = dechex((int) $this->startTime);\n        $uuid = bin2hex(random_bytes(12));\n        $this->setTraceId(\"1-{$startHex}-{$uuid}\");\n    }\n}","mutatedSourceCode":"<?php\n\nnamespace Fido\\PHPXray;\n\nuse Exception;\nclass Trace extends Segment\n{\n    use HttpTrait;\n    private static self $instance;\n    private string $serviceVersion;\n    private string $user;\n    protected static function getInstance() : self\n    {\n        if (!isset(self::$instance)) {\n            self::$instance = new self();\n        }\n        return self::$instance;\n    }\n    public function setServiceVersion(string $serviceVersion) : self\n    {\n        $this->serviceVersion = $serviceVersion;\n        return $this;\n    }\n    public function setUser(string $user) : self\n    {\n        $this->user = $user;\n        return $this;\n    }\n    public function setClientIpAddress(string $clientIpAddress) : self\n    {\n        $this->clientIpAddress = $clientIpAddress;\n        return $this;\n    }\n    public function setUserAgent(string $userAgent) : self\n    {\n        $this->userAgent = $userAgent;\n        return $this;\n    }\n    \/**\n     * @throws Exception\n     *\/\n    public function begin(int $samplePercentage = 10) : Segment\n    {\n        parent::begin();\n        if (!isset($this->traceId)) {\n            $this->generateTraceId();\n        }\n        if (!$this->isSampled()) {\n            $this->sampled = random_int(0, 99) < $samplePercentage;\n        }\n        return $this;\n    }\n    \/**\n     * @inheritdoc\n     *\/\n    public function jsonSerialize() : array\n    {\n        $data = parent::jsonSerialize();\n        $data['http'] = $this->serialiseHttpData();\n        $data['service'] = empty($this->serviceVersion) ? null : ['version' => $this->serviceVersion];\n        $data['user'] = $this->user ?? null;\n        return array_filter($data);\n    }\n    \/**\n     * @throws Exception if an appropriate source of randomness cannot be found.\n     *\/\n    private function generateTraceId() : void\n    {\n        $startHex = dechex((int) $this->startTime);\n        $uuid = bin2hex(random_bytes(12));\n        $this->setTraceId(\"1-{$startHex}-{$uuid}\");\n    }\n}","originalFilePath":"\/home\/ranpafin\/php-xray\/src\/Trace.php","originalStartLine":15},"diff":"--- Original\n+++ New\n@@ @@\n     private static self $instance;\n     private string $serviceVersion;\n     private string $user;\n-    public static function getInstance() : self\n+    protected static function getInstance() : self\n     {\n         if (!isset(self::$instance)) {\n             self::$instance = new self();","processOutput":"PHPUnit 9.5.10 by Sebastian Bergmann and contributors.\n\nRuntime:       PHP 8.0.13\nConfiguration: \/tmp\/tmp-folder\/infection\/phpunitConfiguration.e66a737f4346551141243545576d4e18.infection.xml\n\nE\n\nTime: 00:00.005, Memory: 8.00 MB\n\nThere was 1 error:\n\n1) Fido\\PHPXray\\TraceTest::testGetInstanceReturnsSingleton\nError: Call to protected method Fido\\PHPXray\\Trace::getInstance() from scope Fido\\PHPXray\\TraceTest\n\n\/home\/ranpafin\/php-xray\/tests\/TraceTest.php:11\n\nERRORS!\nTests: 1, Assertions: 0, Errors: 1."},{"mutator":{"mutatorName":"LogicalNot","originalSourceCode":"<?php\n\nnamespace Fido\\PHPXray;\n\nuse Exception;\nclass Trace extends Segment\n{\n    use HttpTrait;\n    private static self $instance;\n    private string $serviceVersion;\n    private string $user;\n    public static function getInstance() : self\n    {\n        if (!isset(self::$instance)) {\n            self::$instance = new self();\n        }\n        return self::$instance;\n    }\n    public function setServiceVersion(string $serviceVersion) : self\n    {\n        $this->serviceVersion = $serviceVersion;\n        return $this;\n    }\n    public function setUser(string $user) : self\n    {\n        $this->user = $user;\n        return $this;\n    }\n    public function setClientIpAddress(string $clientIpAddress) : self\n    {\n        $this->clientIpAddress = $clientIpAddress;\n        return $this;\n    }\n    public function setUserAgent(string $userAgent) : self\n    {\n        $this->userAgent = $userAgent;\n        return $this;\n    }\n    \/**\n     * @throws Exception\n     *\/\n    public function begin(int $samplePercentage = 10) : Segment\n    {\n        parent::begin();\n        if (!isset($this->traceId)) {\n            $this->generateTraceId();\n        }\n        if (!$this->isSampled()) {\n            $this->sampled = random_int(0, 99) < $samplePercentage;\n        }\n        return $this;\n    }\n    \/**\n     * @inheritdoc\n     *\/\n    public function jsonSerialize() : array\n    {\n        $data = parent::jsonSerialize();\n        $data['http'] = $this->serialiseHttpData();\n        $data['service'] = empty($this->serviceVersion) ? null : ['version' => $this->serviceVersion];\n        $data['user'] = $this->user ?? null;\n        return array_filter($data);\n    }\n    \/**\n     * @throws Exception if an appropriate source of randomness cannot be found.\n     *\/\n    private function generateTraceId() : void\n    {\n        $startHex = dechex((int) $this->startTime);\n        $uuid = bin2hex(random_bytes(12));\n        $this->setTraceId(\"1-{$startHex}-{$uuid}\");\n    }\n}","mutatedSourceCode":"<?php\n\nnamespace Fido\\PHPXray;\n\nuse Exception;\nclass Trace extends Segment\n{\n    use HttpTrait;\n    private static self $instance;\n    private string $serviceVersion;\n    private string $user;\n    public static function getInstance() : self\n    {\n        if (isset(self::$instance)) {\n            self::$instance = new self();\n        }\n        return self::$instance;\n    }\n    public function setServiceVersion(string $serviceVersion) : self\n    {\n        $this->serviceVersion = $serviceVersion;\n        return $this;\n    }\n    public function setUser(string $user) : self\n    {\n        $this->user = $user;\n        return $this;\n    }\n    public function setClientIpAddress(string $clientIpAddress) : self\n    {\n        $this->clientIpAddress = $clientIpAddress;\n        return $this;\n    }\n    public function setUserAgent(string $userAgent) : self\n    {\n        $this->userAgent = $userAgent;\n        return $this;\n    }\n    \/**\n     * @throws Exception\n     *\/\n    public function begin(int $samplePercentage = 10) : Segment\n    {\n        parent::begin();\n        if (!isset($this->traceId)) {\n            $this->generateTraceId();\n        }\n        if (!$this->isSampled()) {\n            $this->sampled = random_int(0, 99) < $samplePercentage;\n        }\n        return $this;\n    }\n    \/**\n     * @inheritdoc\n     *\/\n    public function jsonSerialize() : array\n    {\n        $data = parent::jsonSerialize();\n        $data['http'] = $this->serialiseHttpData();\n        $data['service'] = empty($this->serviceVersion) ? null : ['version' => $this->serviceVersion];\n        $data['user'] = $this->user ?? null;\n        return array_filter($data);\n    }\n    \/**\n     * @throws Exception if an appropriate source of randomness cannot be found.\n     *\/\n    private function generateTraceId() : void\n    {\n        $startHex = dechex((int) $this->startTime);\n        $uuid = bin2hex(random_bytes(12));\n        $this->setTraceId(\"1-{$startHex}-{$uuid}\");\n    }\n}","originalFilePath":"\/home\/ranpafin\/php-xray\/src\/Trace.php","originalStartLine":17},"diff":"--- Original\n+++ New\n@@ @@\n     private string $user;\n     public static function getInstance() : self\n     {\n-        if (!isset(self::$instance)) {\n+        if (isset(self::$instance)) {\n             self::$instance = new self();\n         }\n         return self::$instance;","processOutput":"PHPUnit 9.5.10 by Sebastian Bergmann and contributors.\n\nRuntime:       PHP 8.0.13\nConfiguration: \/tmp\/tmp-folder\/infection\/phpunitConfiguration.d67328dd013c0637adcdc425f1702197.infection.xml\n\nE\n\nTime: 00:00.004, Memory: 8.00 MB\n\nThere was 1 error:\n\n1) Fido\\PHPXray\\TraceTest::testGetInstanceReturnsSingleton\nError: Typed static property Fido\\PHPXray\\Trace::$instance must not be accessed before initialization\n\n\/home\/ranpafin\/php-xray\/src\/Trace.php:17\n\/home\/ranpafin\/php-xray\/tests\/TraceTest.php:11\n\nERRORS!\nTests: 1, Assertions: 0, Errors: 1."},{"mutator":{"mutatorName":"PublicVisibility","originalSourceCode":"<?php\n\nnamespace Fido\\PHPXray;\n\nuse Exception;\nclass Trace extends Segment\n{\n    use HttpTrait;\n    private static self $instance;\n    private string $serviceVersion;\n    private string $user;\n    public static function getInstance() : self\n    {\n        if (!isset(self::$instance)) {\n            self::$instance = new self();\n        }\n        return self::$instance;\n    }\n    public function setServiceVersion(string $serviceVersion) : self\n    {\n        $this->serviceVersion = $serviceVersion;\n        return $this;\n    }\n    public function setUser(string $user) : self\n    {\n        $this->user = $user;\n        return $this;\n    }\n    public function setClientIpAddress(string $clientIpAddress) : self\n    {\n        $this->clientIpAddress = $clientIpAddress;\n        return $this;\n    }\n    public function setUserAgent(string $userAgent) : self\n    {\n        $this->userAgent = $userAgent;\n        return $this;\n    }\n    \/**\n     * @throws Exception\n     *\/\n    public function begin(int $samplePercentage = 10) : Segment\n    {\n        parent::begin();\n        if (!isset($this->traceId)) {\n            $this->generateTraceId();\n        }\n        if (!$this->isSampled()) {\n            $this->sampled = random_int(0, 99) < $samplePercentage;\n        }\n        return $this;\n    }\n    \/**\n     * @inheritdoc\n     *\/\n    public function jsonSerialize() : array\n    {\n        $data = parent::jsonSerialize();\n        $data['http'] = $this->serialiseHttpData();\n        $data['service'] = empty($this->serviceVersion) ? null : ['version' => $this->serviceVersion];\n        $data['user'] = $this->user ?? null;\n        return array_filter($data);\n    }\n    \/**\n     * @throws Exception if an appropriate source of randomness cannot be found.\n     *\/\n    private function generateTraceId() : void\n    {\n        $startHex = dechex((int) $this->startTime);\n        $uuid = bin2hex(random_bytes(12));\n        $this->setTraceId(\"1-{$startHex}-{$uuid}\");\n    }\n}","mutatedSourceCode":"<?php\n\nnamespace Fido\\PHPXray;\n\nuse Exception;\nclass Trace extends Segment\n{\n    use HttpTrait;\n    private static self $instance;\n    private string $serviceVersion;\n    private string $user;\n    public static function getInstance() : self\n    {\n        if (!isset(self::$instance)) {\n            self::$instance = new self();\n        }\n        return self::$instance;\n    }\n    protected function setServiceVersion(string $serviceVersion) : self\n    {\n        $this->serviceVersion = $serviceVersion;\n        return $this;\n    }\n    public function setUser(string $user) : self\n    {\n        $this->user = $user;\n        return $this;\n    }\n    public function setClientIpAddress(string $clientIpAddress) : self\n    {\n        $this->clientIpAddress = $clientIpAddress;\n        return $this;\n    }\n    public function setUserAgent(string $userAgent) : self\n    {\n        $this->userAgent = $userAgent;\n        return $this;\n    }\n    \/**\n     * @throws Exception\n     *\/\n    public function begin(int $samplePercentage = 10) : Segment\n    {\n        parent::begin();\n        if (!isset($this->traceId)) {\n            $this->generateTraceId();\n        }\n        if (!$this->isSampled()) {\n            $this->sampled = random_int(0, 99) < $samplePercentage;\n        }\n        return $this;\n    }\n    \/**\n     * @inheritdoc\n     *\/\n    public function jsonSerialize() : array\n    {\n        $data = parent::jsonSerialize();\n        $data['http'] = $this->serialiseHttpData();\n        $data['service'] = empty($this->serviceVersion) ? null : ['version' => $this->serviceVersion];\n        $data['user'] = $this->user ?? null;\n        return array_filter($data);\n    }\n    \/**\n     * @throws Exception if an appropriate source of randomness cannot be found.\n     *\/\n    private function generateTraceId() : void\n    {\n        $startHex = dechex((int) $this->startTime);\n        $uuid = bin2hex(random_bytes(12));\n        $this->setTraceId(\"1-{$startHex}-{$uuid}\");\n    }\n}","originalFilePath":"\/home\/ranpafin\/php-xray\/src\/Trace.php","originalStartLine":24},"diff":"--- Original\n+++ New\n@@ @@\n         }\n         return self::$instance;\n     }\n-    public function setServiceVersion(string $serviceVersion) : self\n+    protected function setServiceVersion(string $serviceVersion) : self\n     {\n         $this->serviceVersion = $serviceVersion;\n         return $this;","processOutput":"PHPUnit 9.5.10 by Sebastian Bergmann and contributors.\n\nRuntime:       PHP 8.0.13\nConfiguration: \/tmp\/tmp-folder\/infection\/phpunitConfiguration.84c787c2199f4a9445d1872bbe1ed3a8.infection.xml\n\nE\n\nTime: 00:00.005, Memory: 8.00 MB\n\nThere was 1 error:\n\n1) Fido\\PHPXray\\TraceTest::testSerialisesCorrectly\nError: Call to protected method Fido\\PHPXray\\Trace::setServiceVersion() from scope Fido\\PHPXray\\TraceTest\n\n\/home\/ranpafin\/php-xray\/tests\/TraceTest.php:20\n\nERRORS!\nTests: 1, Assertions: 0, Errors: 1."},{"mutator":{"mutatorName":"PublicVisibility","originalSourceCode":"<?php\n\nnamespace Fido\\PHPXray;\n\nuse Exception;\nclass Trace extends Segment\n{\n    use HttpTrait;\n    private static self $instance;\n    private string $serviceVersion;\n    private string $user;\n    public static function getInstance() : self\n    {\n        if (!isset(self::$instance)) {\n            self::$instance = new self();\n        }\n        return self::$instance;\n    }\n    public function setServiceVersion(string $serviceVersion) : self\n    {\n        $this->serviceVersion = $serviceVersion;\n        return $this;\n    }\n    public function setUser(string $user) : self\n    {\n        $this->user = $user;\n        return $this;\n    }\n    public function setClientIpAddress(string $clientIpAddress) : self\n    {\n        $this->clientIpAddress = $clientIpAddress;\n        return $this;\n    }\n    public function setUserAgent(string $userAgent) : self\n    {\n        $this->userAgent = $userAgent;\n        return $this;\n    }\n    \/**\n     * @throws Exception\n     *\/\n    public function begin(int $samplePercentage = 10) : Segment\n    {\n        parent::begin();\n        if (!isset($this->traceId)) {\n            $this->generateTraceId();\n        }\n        if (!$this->isSampled()) {\n            $this->sampled = random_int(0, 99) < $samplePercentage;\n        }\n        return $this;\n    }\n    \/**\n     * @inheritdoc\n     *\/\n    public function jsonSerialize() : array\n    {\n        $data = parent::jsonSerialize();\n        $data['http'] = $this->serialiseHttpData();\n        $data['service'] = empty($this->serviceVersion) ? null : ['version' => $this->serviceVersion];\n        $data['user'] = $this->user ?? null;\n        return array_filter($data);\n    }\n    \/**\n     * @throws Exception if an appropriate source of randomness cannot be found.\n     *\/\n    private function generateTraceId() : void\n    {\n        $startHex = dechex((int) $this->startTime);\n        $uuid = bin2hex(random_bytes(12));\n        $this->setTraceId(\"1-{$startHex}-{$uuid}\");\n    }\n}","mutatedSourceCode":"<?php\n\nnamespace Fido\\PHPXray;\n\nuse Exception;\nclass Trace extends Segment\n{\n    use HttpTrait;\n    private static self $instance;\n    private string $serviceVersion;\n    private string $user;\n    public static function getInstance() : self\n    {\n        if (!isset(self::$instance)) {\n            self::$instance = new self();\n        }\n        return self::$instance;\n    }\n    public function setServiceVersion(string $serviceVersion) : self\n    {\n        $this->serviceVersion = $serviceVersion;\n        return $this;\n    }\n    protected function setUser(string $user) : self\n    {\n        $this->user = $user;\n        return $this;\n    }\n    public function setClientIpAddress(string $clientIpAddress) : self\n    {\n        $this->clientIpAddress = $clientIpAddress;\n        return $this;\n    }\n    public function setUserAgent(string $userAgent) : self\n    {\n        $this->userAgent = $userAgent;\n        return $this;\n    }\n    \/**\n     * @throws Exception\n     *\/\n    public function begin(int $samplePercentage = 10) : Segment\n    {\n        parent::begin();\n        if (!isset($this->traceId)) {\n            $this->generateTraceId();\n        }\n        if (!$this->isSampled()) {\n            $this->sampled = random_int(0, 99) < $samplePercentage;\n        }\n        return $this;\n    }\n    \/**\n     * @inheritdoc\n     *\/\n    public function jsonSerialize() : array\n    {\n        $data = parent::jsonSerialize();\n        $data['http'] = $this->serialiseHttpData();\n        $data['service'] = empty($this->serviceVersion) ? null : ['version' => $this->serviceVersion];\n        $data['user'] = $this->user ?? null;\n        return array_filter($data);\n    }\n    \/**\n     * @throws Exception if an appropriate source of randomness cannot be found.\n     *\/\n    private function generateTraceId() : void\n    {\n        $startHex = dechex((int) $this->startTime);\n        $uuid = bin2hex(random_bytes(12));\n        $this->setTraceId(\"1-{$startHex}-{$uuid}\");\n    }\n}","originalFilePath":"\/home\/ranpafin\/php-xray\/src\/Trace.php","originalStartLine":31},"diff":"--- Original\n+++ New\n@@ @@\n         $this->serviceVersion = $serviceVersion;\n         return $this;\n     }\n-    public function setUser(string $user) : self\n+    protected function setUser(string $user) : self\n     {\n         $this->user = $user;\n         return $this;","processOutput":"PHPUnit 9.5.10 by Sebastian Bergmann and contributors.\n\nRuntime:       PHP 8.0.13\nConfiguration: \/tmp\/tmp-folder\/infection\/phpunitConfiguration.df69de295925fd0b3942862b83193ef0.infection.xml\n\nE\n\nTime: 00:00.004, Memory: 8.00 MB\n\nThere was 1 error:\n\n1) Fido\\PHPXray\\TraceTest::testSerialisesCorrectly\nError: Call to protected method Fido\\PHPXray\\Trace::setUser() from scope Fido\\PHPXray\\TraceTest\n\n\/home\/ranpafin\/php-xray\/tests\/TraceTest.php:21\n\nERRORS!\nTests: 1, Assertions: 0, Errors: 1."},{"mutator":{"mutatorName":"PublicVisibility","originalSourceCode":"<?php\n\nnamespace Fido\\PHPXray;\n\nuse Exception;\nclass Trace extends Segment\n{\n    use HttpTrait;\n    private static self $instance;\n    private string $serviceVersion;\n    private string $user;\n    public static function getInstance() : self\n    {\n        if (!isset(self::$instance)) {\n            self::$instance = new self();\n        }\n        return self::$instance;\n    }\n    public function setServiceVersion(string $serviceVersion) : self\n    {\n        $this->serviceVersion = $serviceVersion;\n        return $this;\n    }\n    public function setUser(string $user) : self\n    {\n        $this->user = $user;\n        return $this;\n    }\n    public function setClientIpAddress(string $clientIpAddress) : self\n    {\n        $this->clientIpAddress = $clientIpAddress;\n        return $this;\n    }\n    public function setUserAgent(string $userAgent) : self\n    {\n        $this->userAgent = $userAgent;\n        return $this;\n    }\n    \/**\n     * @throws Exception\n     *\/\n    public function begin(int $samplePercentage = 10) : Segment\n    {\n        parent::begin();\n        if (!isset($this->traceId)) {\n            $this->generateTraceId();\n        }\n        if (!$this->isSampled()) {\n            $this->sampled = random_int(0, 99) < $samplePercentage;\n        }\n        return $this;\n    }\n    \/**\n     * @inheritdoc\n     *\/\n    public function jsonSerialize() : array\n    {\n        $data = parent::jsonSerialize();\n        $data['http'] = $this->serialiseHttpData();\n        $data['service'] = empty($this->serviceVersion) ? null : ['version' => $this->serviceVersion];\n        $data['user'] = $this->user ?? null;\n        return array_filter($data);\n    }\n    \/**\n     * @throws Exception if an appropriate source of randomness cannot be found.\n     *\/\n    private function generateTraceId() : void\n    {\n        $startHex = dechex((int) $this->startTime);\n        $uuid = bin2hex(random_bytes(12));\n        $this->setTraceId(\"1-{$startHex}-{$uuid}\");\n    }\n}","mutatedSourceCode":"<?php\n\nnamespace Fido\\PHPXray;\n\nuse Exception;\nclass Trace extends Segment\n{\n    use HttpTrait;\n    private static self $instance;\n    private string $serviceVersion;\n    private string $user;\n    public static function getInstance() : self\n    {\n        if (!isset(self::$instance)) {\n            self::$instance = new self();\n        }\n        return self::$instance;\n    }\n    public function setServiceVersion(string $serviceVersion) : self\n    {\n        $this->serviceVersion = $serviceVersion;\n        return $this;\n    }\n    public function setUser(string $user) : self\n    {\n        $this->user = $user;\n        return $this;\n    }\n    protected function setClientIpAddress(string $clientIpAddress) : self\n    {\n        $this->clientIpAddress = $clientIpAddress;\n        return $this;\n    }\n    public function setUserAgent(string $userAgent) : self\n    {\n        $this->userAgent = $userAgent;\n        return $this;\n    }\n    \/**\n     * @throws Exception\n     *\/\n    public function begin(int $samplePercentage = 10) : Segment\n    {\n        parent::begin();\n        if (!isset($this->traceId)) {\n            $this->generateTraceId();\n        }\n        if (!$this->isSampled()) {\n            $this->sampled = random_int(0, 99) < $samplePercentage;\n        }\n        return $this;\n    }\n    \/**\n     * @inheritdoc\n     *\/\n    public function jsonSerialize() : array\n    {\n        $data = parent::jsonSerialize();\n        $data['http'] = $this->serialiseHttpData();\n        $data['service'] = empty($this->serviceVersion) ? null : ['version' => $this->serviceVersion];\n        $data['user'] = $this->user ?? null;\n        return array_filter($data);\n    }\n    \/**\n     * @throws Exception if an appropriate source of randomness cannot be found.\n     *\/\n    private function generateTraceId() : void\n    {\n        $startHex = dechex((int) $this->startTime);\n        $uuid = bin2hex(random_bytes(12));\n        $this->setTraceId(\"1-{$startHex}-{$uuid}\");\n    }\n}","originalFilePath":"\/home\/ranpafin\/php-xray\/src\/Trace.php","originalStartLine":38},"diff":"--- Original\n+++ New\n@@ @@\n         $this->user = $user;\n         return $this;\n     }\n-    public function setClientIpAddress(string $clientIpAddress) : self\n+    protected function setClientIpAddress(string $clientIpAddress) : self\n     {\n         $this->clientIpAddress = $clientIpAddress;\n         return $this;","processOutput":"PHPUnit 9.5.10 by Sebastian Bergmann and contributors.\n\nRuntime:       PHP 8.0.13\nConfiguration: \/tmp\/tmp-folder\/infection\/phpunitConfiguration.997705b980e89557c8b0929d04d33bea.infection.xml\n\nE\n\nTime: 00:00.004, Memory: 8.00 MB\n\nThere was 1 error:\n\n1) Fido\\PHPXray\\TraceTest::testSerialisesCorrectly\nError: Call to protected method Fido\\PHPXray\\Trace::setClientIpAddress() from scope Fido\\PHPXray\\TraceTest\n\n\/home\/ranpafin\/php-xray\/tests\/TraceTest.php:24\n\nERRORS!\nTests: 1, Assertions: 0, Errors: 1."},{"mutator":{"mutatorName":"PublicVisibility","originalSourceCode":"<?php\n\nnamespace Fido\\PHPXray;\n\nuse Exception;\nclass Trace extends Segment\n{\n    use HttpTrait;\n    private static self $instance;\n    private string $serviceVersion;\n    private string $user;\n    public static function getInstance() : self\n    {\n        if (!isset(self::$instance)) {\n            self::$instance = new self();\n        }\n        return self::$instance;\n    }\n    public function setServiceVersion(string $serviceVersion) : self\n    {\n        $this->serviceVersion = $serviceVersion;\n        return $this;\n    }\n    public function setUser(string $user) : self\n    {\n        $this->user = $user;\n        return $this;\n    }\n    public function setClientIpAddress(string $clientIpAddress) : self\n    {\n        $this->clientIpAddress = $clientIpAddress;\n        return $this;\n    }\n    public function setUserAgent(string $userAgent) : self\n    {\n        $this->userAgent = $userAgent;\n        return $this;\n    }\n    \/**\n     * @throws Exception\n     *\/\n    public function begin(int $samplePercentage = 10) : Segment\n    {\n        parent::begin();\n        if (!isset($this->traceId)) {\n            $this->generateTraceId();\n        }\n        if (!$this->isSampled()) {\n            $this->sampled = random_int(0, 99) < $samplePercentage;\n        }\n        return $this;\n    }\n    \/**\n     * @inheritdoc\n     *\/\n    public function jsonSerialize() : array\n    {\n        $data = parent::jsonSerialize();\n        $data['http'] = $this->serialiseHttpData();\n        $data['service'] = empty($this->serviceVersion) ? null : ['version' => $this->serviceVersion];\n        $data['user'] = $this->user ?? null;\n        return array_filter($data);\n    }\n    \/**\n     * @throws Exception if an appropriate source of randomness cannot be found.\n     *\/\n    private function generateTraceId() : void\n    {\n        $startHex = dechex((int) $this->startTime);\n        $uuid = bin2hex(random_bytes(12));\n        $this->setTraceId(\"1-{$startHex}-{$uuid}\");\n    }\n}","mutatedSourceCode":"<?php\n\nnamespace Fido\\PHPXray;\n\nuse Exception;\nclass Trace extends Segment\n{\n    use HttpTrait;\n    private static self $instance;\n    private string $serviceVersion;\n    private string $user;\n    public static function getInstance() : self\n    {\n        if (!isset(self::$instance)) {\n            self::$instance = new self();\n        }\n        return self::$instance;\n    }\n    public function setServiceVersion(string $serviceVersion) : self\n    {\n        $this->serviceVersion = $serviceVersion;\n        return $this;\n    }\n    public function setUser(string $user) : self\n    {\n        $this->user = $user;\n        return $this;\n    }\n    public function setClientIpAddress(string $clientIpAddress) : self\n    {\n        $this->clientIpAddress = $clientIpAddress;\n        return $this;\n    }\n    protected function setUserAgent(string $userAgent) : self\n    {\n        $this->userAgent = $userAgent;\n        return $this;\n    }\n    \/**\n     * @throws Exception\n     *\/\n    public function begin(int $samplePercentage = 10) : Segment\n    {\n        parent::begin();\n        if (!isset($this->traceId)) {\n            $this->generateTraceId();\n        }\n        if (!$this->isSampled()) {\n            $this->sampled = random_int(0, 99) < $samplePercentage;\n        }\n        return $this;\n    }\n    \/**\n     * @inheritdoc\n     *\/\n    public function jsonSerialize() : array\n    {\n        $data = parent::jsonSerialize();\n        $data['http'] = $this->serialiseHttpData();\n        $data['service'] = empty($this->serviceVersion) ? null : ['version' => $this->serviceVersion];\n        $data['user'] = $this->user ?? null;\n        return array_filter($data);\n    }\n    \/**\n     * @throws Exception if an appropriate source of randomness cannot be found.\n     *\/\n    private function generateTraceId() : void\n    {\n        $startHex = dechex((int) $this->startTime);\n        $uuid = bin2hex(random_bytes(12));\n        $this->setTraceId(\"1-{$startHex}-{$uuid}\");\n    }\n}","originalFilePath":"\/home\/ranpafin\/php-xray\/src\/Trace.php","originalStartLine":45},"diff":"--- Original\n+++ New\n@@ @@\n         $this->clientIpAddress = $clientIpAddress;\n         return $this;\n     }\n-    public function setUserAgent(string $userAgent) : self\n+    protected function setUserAgent(string $userAgent) : self\n     {\n         $this->userAgent = $userAgent;\n         return $this;","processOutput":"PHPUnit 9.5.10 by Sebastian Bergmann and contributors.\n\nRuntime:       PHP 8.0.13\nConfiguration: \/tmp\/tmp-folder\/infection\/phpunitConfiguration.1f23f4fbafe03af527e317588541e768.infection.xml\n\nE\n\nTime: 00:00.004, Memory: 8.00 MB\n\nThere was 1 error:\n\n1) Fido\\PHPXray\\TraceTest::testSerialisesCorrectly\nError: Call to protected method Fido\\PHPXray\\Trace::setUserAgent() from scope Fido\\PHPXray\\TraceTest\n\n\/home\/ranpafin\/php-xray\/tests\/TraceTest.php:25\n\nERRORS!\nTests: 1, Assertions: 0, Errors: 1."},{"mutator":{"mutatorName":"DecrementInteger","originalSourceCode":"<?php\n\nnamespace Fido\\PHPXray;\n\nuse Exception;\nclass Trace extends Segment\n{\n    use HttpTrait;\n    private static self $instance;\n    private string $serviceVersion;\n    private string $user;\n    public static function getInstance() : self\n    {\n        if (!isset(self::$instance)) {\n            self::$instance = new self();\n        }\n        return self::$instance;\n    }\n    public function setServiceVersion(string $serviceVersion) : self\n    {\n        $this->serviceVersion = $serviceVersion;\n        return $this;\n    }\n    public function setUser(string $user) : self\n    {\n        $this->user = $user;\n        return $this;\n    }\n    public function setClientIpAddress(string $clientIpAddress) : self\n    {\n        $this->clientIpAddress = $clientIpAddress;\n        return $this;\n    }\n    public function setUserAgent(string $userAgent) : self\n    {\n        $this->userAgent = $userAgent;\n        return $this;\n    }\n    \/**\n     * @throws Exception\n     *\/\n    public function begin(int $samplePercentage = 10) : Segment\n    {\n        parent::begin();\n        if (!isset($this->traceId)) {\n            $this->generateTraceId();\n        }\n        if (!$this->isSampled()) {\n            $this->sampled = random_int(0, 99) < $samplePercentage;\n        }\n        return $this;\n    }\n    \/**\n     * @inheritdoc\n     *\/\n    public function jsonSerialize() : array\n    {\n        $data = parent::jsonSerialize();\n        $data['http'] = $this->serialiseHttpData();\n        $data['service'] = empty($this->serviceVersion) ? null : ['version' => $this->serviceVersion];\n        $data['user'] = $this->user ?? null;\n        return array_filter($data);\n    }\n    \/**\n     * @throws Exception if an appropriate source of randomness cannot be found.\n     *\/\n    private function generateTraceId() : void\n    {\n        $startHex = dechex((int) $this->startTime);\n        $uuid = bin2hex(random_bytes(12));\n        $this->setTraceId(\"1-{$startHex}-{$uuid}\");\n    }\n}","mutatedSourceCode":"<?php\n\nnamespace Fido\\PHPXray;\n\nuse Exception;\nclass Trace extends Segment\n{\n    use HttpTrait;\n    private static self $instance;\n    private string $serviceVersion;\n    private string $user;\n    public static function getInstance() : self\n    {\n        if (!isset(self::$instance)) {\n            self::$instance = new self();\n        }\n        return self::$instance;\n    }\n    public function setServiceVersion(string $serviceVersion) : self\n    {\n        $this->serviceVersion = $serviceVersion;\n        return $this;\n    }\n    public function setUser(string $user) : self\n    {\n        $this->user = $user;\n        return $this;\n    }\n    public function setClientIpAddress(string $clientIpAddress) : self\n    {\n        $this->clientIpAddress = $clientIpAddress;\n        return $this;\n    }\n    public function setUserAgent(string $userAgent) : self\n    {\n        $this->userAgent = $userAgent;\n        return $this;\n    }\n    \/**\n     * @throws Exception\n     *\/\n    public function begin(int $samplePercentage = 9) : Segment\n    {\n        parent::begin();\n        if (!isset($this->traceId)) {\n            $this->generateTraceId();\n        }\n        if (!$this->isSampled()) {\n            $this->sampled = random_int(0, 99) < $samplePercentage;\n        }\n        return $this;\n    }\n    \/**\n     * @inheritdoc\n     *\/\n    public function jsonSerialize() : array\n    {\n        $data = parent::jsonSerialize();\n        $data['http'] = $this->serialiseHttpData();\n        $data['service'] = empty($this->serviceVersion) ? null : ['version' => $this->serviceVersion];\n        $data['user'] = $this->user ?? null;\n        return array_filter($data);\n    }\n    \/**\n     * @throws Exception if an appropriate source of randomness cannot be found.\n     *\/\n    private function generateTraceId() : void\n    {\n        $startHex = dechex((int) $this->startTime);\n        $uuid = bin2hex(random_bytes(12));\n        $this->setTraceId(\"1-{$startHex}-{$uuid}\");\n    }\n}","originalFilePath":"\/home\/ranpafin\/php-xray\/src\/Trace.php","originalStartLine":55},"diff":"--- Original\n+++ New\n@@ @@\n     \/**\n      * @throws Exception\n      *\/\n-    public function begin(int $samplePercentage = 10) : Segment\n+    public function begin(int $samplePercentage = 9) : Segment\n     {\n         parent::begin();\n         if (!isset($this->traceId)) {","processOutput":"PHPUnit 9.5.10 by Sebastian Bergmann and contributors.\n\nRuntime:       PHP 8.0.13\nConfiguration: \/tmp\/tmp-folder\/infection\/phpunitConfiguration.ad6c55852c1b5ff2d4ed76c0700e3e1d.infection.xml\n\nE\n\nTime: 00:00.003, Memory: 8.00 MB\n\nThere was 1 error:\n\n1) Fido\\PHPXray\\DaemonSegmentSubmitterTest::testSubmitsToDaemon\nsocket_bind(): Unable to bind address [98]: Address already in use\n\n\/home\/ranpafin\/php-xray\/tests\/DaemonSegmentSubmitterTest.php:18\n\nERRORS!\nTests: 1, Assertions: 0, Errors: 1."},{"mutator":{"mutatorName":"IncrementInteger","originalSourceCode":"<?php\n\nnamespace Fido\\PHPXray;\n\nuse Exception;\nclass Trace extends Segment\n{\n    use HttpTrait;\n    private static self $instance;\n    private string $serviceVersion;\n    private string $user;\n    public static function getInstance() : self\n    {\n        if (!isset(self::$instance)) {\n            self::$instance = new self();\n        }\n        return self::$instance;\n    }\n    public function setServiceVersion(string $serviceVersion) : self\n    {\n        $this->serviceVersion = $serviceVersion;\n        return $this;\n    }\n    public function setUser(string $user) : self\n    {\n        $this->user = $user;\n        return $this;\n    }\n    public function setClientIpAddress(string $clientIpAddress) : self\n    {\n        $this->clientIpAddress = $clientIpAddress;\n        return $this;\n    }\n    public function setUserAgent(string $userAgent) : self\n    {\n        $this->userAgent = $userAgent;\n        return $this;\n    }\n    \/**\n     * @throws Exception\n     *\/\n    public function begin(int $samplePercentage = 10) : Segment\n    {\n        parent::begin();\n        if (!isset($this->traceId)) {\n            $this->generateTraceId();\n        }\n        if (!$this->isSampled()) {\n            $this->sampled = random_int(0, 99) < $samplePercentage;\n        }\n        return $this;\n    }\n    \/**\n     * @inheritdoc\n     *\/\n    public function jsonSerialize() : array\n    {\n        $data = parent::jsonSerialize();\n        $data['http'] = $this->serialiseHttpData();\n        $data['service'] = empty($this->serviceVersion) ? null : ['version' => $this->serviceVersion];\n        $data['user'] = $this->user ?? null;\n        return array_filter($data);\n    }\n    \/**\n     * @throws Exception if an appropriate source of randomness cannot be found.\n     *\/\n    private function generateTraceId() : void\n    {\n        $startHex = dechex((int) $this->startTime);\n        $uuid = bin2hex(random_bytes(12));\n        $this->setTraceId(\"1-{$startHex}-{$uuid}\");\n    }\n}","mutatedSourceCode":"<?php\n\nnamespace Fido\\PHPXray;\n\nuse Exception;\nclass Trace extends Segment\n{\n    use HttpTrait;\n    private static self $instance;\n    private string $serviceVersion;\n    private string $user;\n    public static function getInstance() : self\n    {\n        if (!isset(self::$instance)) {\n            self::$instance = new self();\n        }\n        return self::$instance;\n    }\n    public function setServiceVersion(string $serviceVersion) : self\n    {\n        $this->serviceVersion = $serviceVersion;\n        return $this;\n    }\n    public function setUser(string $user) : self\n    {\n        $this->user = $user;\n        return $this;\n    }\n    public function setClientIpAddress(string $clientIpAddress) : self\n    {\n        $this->clientIpAddress = $clientIpAddress;\n        return $this;\n    }\n    public function setUserAgent(string $userAgent) : self\n    {\n        $this->userAgent = $userAgent;\n        return $this;\n    }\n    \/**\n     * @throws Exception\n     *\/\n    public function begin(int $samplePercentage = 11) : Segment\n    {\n        parent::begin();\n        if (!isset($this->traceId)) {\n            $this->generateTraceId();\n        }\n        if (!$this->isSampled()) {\n            $this->sampled = random_int(0, 99) < $samplePercentage;\n        }\n        return $this;\n    }\n    \/**\n     * @inheritdoc\n     *\/\n    public function jsonSerialize() : array\n    {\n        $data = parent::jsonSerialize();\n        $data['http'] = $this->serialiseHttpData();\n        $data['service'] = empty($this->serviceVersion) ? null : ['version' => $this->serviceVersion];\n        $data['user'] = $this->user ?? null;\n        return array_filter($data);\n    }\n    \/**\n     * @throws Exception if an appropriate source of randomness cannot be found.\n     *\/\n    private function generateTraceId() : void\n    {\n        $startHex = dechex((int) $this->startTime);\n        $uuid = bin2hex(random_bytes(12));\n        $this->setTraceId(\"1-{$startHex}-{$uuid}\");\n    }\n}","originalFilePath":"\/home\/ranpafin\/php-xray\/src\/Trace.php","originalStartLine":55},"diff":"--- Original\n+++ New\n@@ @@\n     \/**\n      * @throws Exception\n      *\/\n-    public function begin(int $samplePercentage = 10) : Segment\n+    public function begin(int $samplePercentage = 11) : Segment\n     {\n         parent::begin();\n         if (!isset($this->traceId)) {","processOutput":"PHPUnit 9.5.10 by Sebastian Bergmann and contributors.\n\nRuntime:       PHP 8.0.13\nConfiguration: \/tmp\/tmp-folder\/infection\/phpunitConfiguration.3e6aaf8feaf8f88f8f0475f233a615a7.infection.xml\n\nE\n\nTime: 00:00.003, Memory: 8.00 MB\n\nThere was 1 error:\n\n1) Fido\\PHPXray\\DaemonSegmentSubmitterTest::testSubmitsToDaemon\nsocket_bind(): Unable to bind address [98]: Address already in use\n\n\/home\/ranpafin\/php-xray\/tests\/DaemonSegmentSubmitterTest.php:18\n\nERRORS!\nTests: 1, Assertions: 0, Errors: 1."},{"mutator":{"mutatorName":"MethodCallRemoval","originalSourceCode":"<?php\n\nnamespace Fido\\PHPXray;\n\nuse Exception;\nclass Trace extends Segment\n{\n    use HttpTrait;\n    private static self $instance;\n    private string $serviceVersion;\n    private string $user;\n    public static function getInstance() : self\n    {\n        if (!isset(self::$instance)) {\n            self::$instance = new self();\n        }\n        return self::$instance;\n    }\n    public function setServiceVersion(string $serviceVersion) : self\n    {\n        $this->serviceVersion = $serviceVersion;\n        return $this;\n    }\n    public function setUser(string $user) : self\n    {\n        $this->user = $user;\n        return $this;\n    }\n    public function setClientIpAddress(string $clientIpAddress) : self\n    {\n        $this->clientIpAddress = $clientIpAddress;\n        return $this;\n    }\n    public function setUserAgent(string $userAgent) : self\n    {\n        $this->userAgent = $userAgent;\n        return $this;\n    }\n    \/**\n     * @throws Exception\n     *\/\n    public function begin(int $samplePercentage = 10) : Segment\n    {\n        parent::begin();\n        if (!isset($this->traceId)) {\n            $this->generateTraceId();\n        }\n        if (!$this->isSampled()) {\n            $this->sampled = random_int(0, 99) < $samplePercentage;\n        }\n        return $this;\n    }\n    \/**\n     * @inheritdoc\n     *\/\n    public function jsonSerialize() : array\n    {\n        $data = parent::jsonSerialize();\n        $data['http'] = $this->serialiseHttpData();\n        $data['service'] = empty($this->serviceVersion) ? null : ['version' => $this->serviceVersion];\n        $data['user'] = $this->user ?? null;\n        return array_filter($data);\n    }\n    \/**\n     * @throws Exception if an appropriate source of randomness cannot be found.\n     *\/\n    private function generateTraceId() : void\n    {\n        $startHex = dechex((int) $this->startTime);\n        $uuid = bin2hex(random_bytes(12));\n        $this->setTraceId(\"1-{$startHex}-{$uuid}\");\n    }\n}","mutatedSourceCode":"<?php\n\nnamespace Fido\\PHPXray;\n\nuse Exception;\nclass Trace extends Segment\n{\n    use HttpTrait;\n    private static self $instance;\n    private string $serviceVersion;\n    private string $user;\n    public static function getInstance() : self\n    {\n        if (!isset(self::$instance)) {\n            self::$instance = new self();\n        }\n        return self::$instance;\n    }\n    public function setServiceVersion(string $serviceVersion) : self\n    {\n        $this->serviceVersion = $serviceVersion;\n        return $this;\n    }\n    public function setUser(string $user) : self\n    {\n        $this->user = $user;\n        return $this;\n    }\n    public function setClientIpAddress(string $clientIpAddress) : self\n    {\n        $this->clientIpAddress = $clientIpAddress;\n        return $this;\n    }\n    public function setUserAgent(string $userAgent) : self\n    {\n        $this->userAgent = $userAgent;\n        return $this;\n    }\n    \/**\n     * @throws Exception\n     *\/\n    public function begin(int $samplePercentage = 10) : Segment\n    {\n        \n        if (!isset($this->traceId)) {\n            $this->generateTraceId();\n        }\n        if (!$this->isSampled()) {\n            $this->sampled = random_int(0, 99) < $samplePercentage;\n        }\n        return $this;\n    }\n    \/**\n     * @inheritdoc\n     *\/\n    public function jsonSerialize() : array\n    {\n        $data = parent::jsonSerialize();\n        $data['http'] = $this->serialiseHttpData();\n        $data['service'] = empty($this->serviceVersion) ? null : ['version' => $this->serviceVersion];\n        $data['user'] = $this->user ?? null;\n        return array_filter($data);\n    }\n    \/**\n     * @throws Exception if an appropriate source of randomness cannot be found.\n     *\/\n    private function generateTraceId() : void\n    {\n        $startHex = dechex((int) $this->startTime);\n        $uuid = bin2hex(random_bytes(12));\n        $this->setTraceId(\"1-{$startHex}-{$uuid}\");\n    }\n}","originalFilePath":"\/home\/ranpafin\/php-xray\/src\/Trace.php","originalStartLine":57},"diff":"--- Original\n+++ New\n@@ @@\n      *\/\n     public function begin(int $samplePercentage = 10) : Segment\n     {\n-        parent::begin();\n+        \n         if (!isset($this->traceId)) {\n             $this->generateTraceId();\n         }","processOutput":"PHPUnit 9.5.10 by Sebastian Bergmann and contributors.\n\nRuntime:       PHP 8.0.13\nConfiguration: \/tmp\/tmp-folder\/infection\/phpunitConfiguration.5c079db2ac3886e454cddf0718b2bcf5.infection.xml\n\nE\n\nTime: 00:00.003, Memory: 8.00 MB\n\nThere was 1 error:\n\n1) Fido\\PHPXray\\DaemonSegmentSubmitterTest::testSubmitsLongTraceAsFragmented\nsocket_bind(): Unable to bind address [98]: Address already in use\n\n\/home\/ranpafin\/php-xray\/tests\/DaemonSegmentSubmitterTest.php:18\n\nERRORS!\nTests: 1, Assertions: 0, Errors: 1."},{"mutator":{"mutatorName":"LogicalNot","originalSourceCode":"<?php\n\nnamespace Fido\\PHPXray;\n\nuse Exception;\nclass Trace extends Segment\n{\n    use HttpTrait;\n    private static self $instance;\n    private string $serviceVersion;\n    private string $user;\n    public static function getInstance() : self\n    {\n        if (!isset(self::$instance)) {\n            self::$instance = new self();\n        }\n        return self::$instance;\n    }\n    public function setServiceVersion(string $serviceVersion) : self\n    {\n        $this->serviceVersion = $serviceVersion;\n        return $this;\n    }\n    public function setUser(string $user) : self\n    {\n        $this->user = $user;\n        return $this;\n    }\n    public function setClientIpAddress(string $clientIpAddress) : self\n    {\n        $this->clientIpAddress = $clientIpAddress;\n        return $this;\n    }\n    public function setUserAgent(string $userAgent) : self\n    {\n        $this->userAgent = $userAgent;\n        return $this;\n    }\n    \/**\n     * @throws Exception\n     *\/\n    public function begin(int $samplePercentage = 10) : Segment\n    {\n        parent::begin();\n        if (!isset($this->traceId)) {\n            $this->generateTraceId();\n        }\n        if (!$this->isSampled()) {\n            $this->sampled = random_int(0, 99) < $samplePercentage;\n        }\n        return $this;\n    }\n    \/**\n     * @inheritdoc\n     *\/\n    public function jsonSerialize() : array\n    {\n        $data = parent::jsonSerialize();\n        $data['http'] = $this->serialiseHttpData();\n        $data['service'] = empty($this->serviceVersion) ? null : ['version' => $this->serviceVersion];\n        $data['user'] = $this->user ?? null;\n        return array_filter($data);\n    }\n    \/**\n     * @throws Exception if an appropriate source of randomness cannot be found.\n     *\/\n    private function generateTraceId() : void\n    {\n        $startHex = dechex((int) $this->startTime);\n        $uuid = bin2hex(random_bytes(12));\n        $this->setTraceId(\"1-{$startHex}-{$uuid}\");\n    }\n}","mutatedSourceCode":"<?php\n\nnamespace Fido\\PHPXray;\n\nuse Exception;\nclass Trace extends Segment\n{\n    use HttpTrait;\n    private static self $instance;\n    private string $serviceVersion;\n    private string $user;\n    public static function getInstance() : self\n    {\n        if (!isset(self::$instance)) {\n            self::$instance = new self();\n        }\n        return self::$instance;\n    }\n    public function setServiceVersion(string $serviceVersion) : self\n    {\n        $this->serviceVersion = $serviceVersion;\n        return $this;\n    }\n    public function setUser(string $user) : self\n    {\n        $this->user = $user;\n        return $this;\n    }\n    public function setClientIpAddress(string $clientIpAddress) : self\n    {\n        $this->clientIpAddress = $clientIpAddress;\n        return $this;\n    }\n    public function setUserAgent(string $userAgent) : self\n    {\n        $this->userAgent = $userAgent;\n        return $this;\n    }\n    \/**\n     * @throws Exception\n     *\/\n    public function begin(int $samplePercentage = 10) : Segment\n    {\n        parent::begin();\n        if (isset($this->traceId)) {\n            $this->generateTraceId();\n        }\n        if (!$this->isSampled()) {\n            $this->sampled = random_int(0, 99) < $samplePercentage;\n        }\n        return $this;\n    }\n    \/**\n     * @inheritdoc\n     *\/\n    public function jsonSerialize() : array\n    {\n        $data = parent::jsonSerialize();\n        $data['http'] = $this->serialiseHttpData();\n        $data['service'] = empty($this->serviceVersion) ? null : ['version' => $this->serviceVersion];\n        $data['user'] = $this->user ?? null;\n        return array_filter($data);\n    }\n    \/**\n     * @throws Exception if an appropriate source of randomness cannot be found.\n     *\/\n    private function generateTraceId() : void\n    {\n        $startHex = dechex((int) $this->startTime);\n        $uuid = bin2hex(random_bytes(12));\n        $this->setTraceId(\"1-{$startHex}-{$uuid}\");\n    }\n}","originalFilePath":"\/home\/ranpafin\/php-xray\/src\/Trace.php","originalStartLine":59},"diff":"--- Original\n+++ New\n@@ @@\n     public function begin(int $samplePercentage = 10) : Segment\n     {\n         parent::begin();\n-        if (!isset($this->traceId)) {\n+        if (isset($this->traceId)) {\n             $this->generateTraceId();\n         }\n         if (!$this->isSampled()) {","processOutput":"PHPUnit 9.5.10 by Sebastian Bergmann and contributors.\n\nRuntime:       PHP 8.0.13\nConfiguration: \/tmp\/tmp-folder\/infection\/phpunitConfiguration.578896f68b7fa681d9c0986165361811.infection.xml\n\nE\n\nTime: 00:00.003, Memory: 8.00 MB\n\nThere was 1 error:\n\n1) Fido\\PHPXray\\DaemonSegmentSubmitterTest::testSubmitsToDaemon\nsocket_bind(): Unable to bind address [98]: Address already in use\n\n\/home\/ranpafin\/php-xray\/tests\/DaemonSegmentSubmitterTest.php:18\n\nERRORS!\nTests: 1, Assertions: 0, Errors: 1."},{"mutator":{"mutatorName":"MethodCallRemoval","originalSourceCode":"<?php\n\nnamespace Fido\\PHPXray;\n\nuse Exception;\nclass Trace extends Segment\n{\n    use HttpTrait;\n    private static self $instance;\n    private string $serviceVersion;\n    private string $user;\n    public static function getInstance() : self\n    {\n        if (!isset(self::$instance)) {\n            self::$instance = new self();\n        }\n        return self::$instance;\n    }\n    public function setServiceVersion(string $serviceVersion) : self\n    {\n        $this->serviceVersion = $serviceVersion;\n        return $this;\n    }\n    public function setUser(string $user) : self\n    {\n        $this->user = $user;\n        return $this;\n    }\n    public function setClientIpAddress(string $clientIpAddress) : self\n    {\n        $this->clientIpAddress = $clientIpAddress;\n        return $this;\n    }\n    public function setUserAgent(string $userAgent) : self\n    {\n        $this->userAgent = $userAgent;\n        return $this;\n    }\n    \/**\n     * @throws Exception\n     *\/\n    public function begin(int $samplePercentage = 10) : Segment\n    {\n        parent::begin();\n        if (!isset($this->traceId)) {\n            $this->generateTraceId();\n        }\n        if (!$this->isSampled()) {\n            $this->sampled = random_int(0, 99) < $samplePercentage;\n        }\n        return $this;\n    }\n    \/**\n     * @inheritdoc\n     *\/\n    public function jsonSerialize() : array\n    {\n        $data = parent::jsonSerialize();\n        $data['http'] = $this->serialiseHttpData();\n        $data['service'] = empty($this->serviceVersion) ? null : ['version' => $this->serviceVersion];\n        $data['user'] = $this->user ?? null;\n        return array_filter($data);\n    }\n    \/**\n     * @throws Exception if an appropriate source of randomness cannot be found.\n     *\/\n    private function generateTraceId() : void\n    {\n        $startHex = dechex((int) $this->startTime);\n        $uuid = bin2hex(random_bytes(12));\n        $this->setTraceId(\"1-{$startHex}-{$uuid}\");\n    }\n}","mutatedSourceCode":"<?php\n\nnamespace Fido\\PHPXray;\n\nuse Exception;\nclass Trace extends Segment\n{\n    use HttpTrait;\n    private static self $instance;\n    private string $serviceVersion;\n    private string $user;\n    public static function getInstance() : self\n    {\n        if (!isset(self::$instance)) {\n            self::$instance = new self();\n        }\n        return self::$instance;\n    }\n    public function setServiceVersion(string $serviceVersion) : self\n    {\n        $this->serviceVersion = $serviceVersion;\n        return $this;\n    }\n    public function setUser(string $user) : self\n    {\n        $this->user = $user;\n        return $this;\n    }\n    public function setClientIpAddress(string $clientIpAddress) : self\n    {\n        $this->clientIpAddress = $clientIpAddress;\n        return $this;\n    }\n    public function setUserAgent(string $userAgent) : self\n    {\n        $this->userAgent = $userAgent;\n        return $this;\n    }\n    \/**\n     * @throws Exception\n     *\/\n    public function begin(int $samplePercentage = 10) : Segment\n    {\n        parent::begin();\n        if (!isset($this->traceId)) {\n            \n        }\n        if (!$this->isSampled()) {\n            $this->sampled = random_int(0, 99) < $samplePercentage;\n        }\n        return $this;\n    }\n    \/**\n     * @inheritdoc\n     *\/\n    public function jsonSerialize() : array\n    {\n        $data = parent::jsonSerialize();\n        $data['http'] = $this->serialiseHttpData();\n        $data['service'] = empty($this->serviceVersion) ? null : ['version' => $this->serviceVersion];\n        $data['user'] = $this->user ?? null;\n        return array_filter($data);\n    }\n    \/**\n     * @throws Exception if an appropriate source of randomness cannot be found.\n     *\/\n    private function generateTraceId() : void\n    {\n        $startHex = dechex((int) $this->startTime);\n        $uuid = bin2hex(random_bytes(12));\n        $this->setTraceId(\"1-{$startHex}-{$uuid}\");\n    }\n}","originalFilePath":"\/home\/ranpafin\/php-xray\/src\/Trace.php","originalStartLine":60},"diff":"--- Original\n+++ New\n@@ @@\n     {\n         parent::begin();\n         if (!isset($this->traceId)) {\n-            $this->generateTraceId();\n+            \n         }\n         if (!$this->isSampled()) {\n             $this->sampled = random_int(0, 99) < $samplePercentage;","processOutput":"PHPUnit 9.5.10 by Sebastian Bergmann and contributors.\n\nRuntime:       PHP 8.0.13\nConfiguration: \/tmp\/tmp-folder\/infection\/phpunitConfiguration.4f948412abd757cc0880ed2a03e82d58.infection.xml\n\nE\n\nTime: 00:00.003, Memory: 8.00 MB\n\nThere was 1 error:\n\n1) Fido\\PHPXray\\DaemonSegmentSubmitterTest::testSubmitsLongTraceAsFragmented\nsocket_bind(): Unable to bind address [98]: Address already in use\n\n\/home\/ranpafin\/php-xray\/tests\/DaemonSegmentSubmitterTest.php:18\n\nERRORS!\nTests: 1, Assertions: 0, Errors: 1."},{"mutator":{"mutatorName":"LogicalNot","originalSourceCode":"<?php\n\nnamespace Fido\\PHPXray;\n\nuse Exception;\nclass Trace extends Segment\n{\n    use HttpTrait;\n    private static self $instance;\n    private string $serviceVersion;\n    private string $user;\n    public static function getInstance() : self\n    {\n        if (!isset(self::$instance)) {\n            self::$instance = new self();\n        }\n        return self::$instance;\n    }\n    public function setServiceVersion(string $serviceVersion) : self\n    {\n        $this->serviceVersion = $serviceVersion;\n        return $this;\n    }\n    public function setUser(string $user) : self\n    {\n        $this->user = $user;\n        return $this;\n    }\n    public function setClientIpAddress(string $clientIpAddress) : self\n    {\n        $this->clientIpAddress = $clientIpAddress;\n        return $this;\n    }\n    public function setUserAgent(string $userAgent) : self\n    {\n        $this->userAgent = $userAgent;\n        return $this;\n    }\n    \/**\n     * @throws Exception\n     *\/\n    public function begin(int $samplePercentage = 10) : Segment\n    {\n        parent::begin();\n        if (!isset($this->traceId)) {\n            $this->generateTraceId();\n        }\n        if (!$this->isSampled()) {\n            $this->sampled = random_int(0, 99) < $samplePercentage;\n        }\n        return $this;\n    }\n    \/**\n     * @inheritdoc\n     *\/\n    public function jsonSerialize() : array\n    {\n        $data = parent::jsonSerialize();\n        $data['http'] = $this->serialiseHttpData();\n        $data['service'] = empty($this->serviceVersion) ? null : ['version' => $this->serviceVersion];\n        $data['user'] = $this->user ?? null;\n        return array_filter($data);\n    }\n    \/**\n     * @throws Exception if an appropriate source of randomness cannot be found.\n     *\/\n    private function generateTraceId() : void\n    {\n        $startHex = dechex((int) $this->startTime);\n        $uuid = bin2hex(random_bytes(12));\n        $this->setTraceId(\"1-{$startHex}-{$uuid}\");\n    }\n}","mutatedSourceCode":"<?php\n\nnamespace Fido\\PHPXray;\n\nuse Exception;\nclass Trace extends Segment\n{\n    use HttpTrait;\n    private static self $instance;\n    private string $serviceVersion;\n    private string $user;\n    public static function getInstance() : self\n    {\n        if (!isset(self::$instance)) {\n            self::$instance = new self();\n        }\n        return self::$instance;\n    }\n    public function setServiceVersion(string $serviceVersion) : self\n    {\n        $this->serviceVersion = $serviceVersion;\n        return $this;\n    }\n    public function setUser(string $user) : self\n    {\n        $this->user = $user;\n        return $this;\n    }\n    public function setClientIpAddress(string $clientIpAddress) : self\n    {\n        $this->clientIpAddress = $clientIpAddress;\n        return $this;\n    }\n    public function setUserAgent(string $userAgent) : self\n    {\n        $this->userAgent = $userAgent;\n        return $this;\n    }\n    \/**\n     * @throws Exception\n     *\/\n    public function begin(int $samplePercentage = 10) : Segment\n    {\n        parent::begin();\n        if (!isset($this->traceId)) {\n            $this->generateTraceId();\n        }\n        if ($this->isSampled()) {\n            $this->sampled = random_int(0, 99) < $samplePercentage;\n        }\n        return $this;\n    }\n    \/**\n     * @inheritdoc\n     *\/\n    public function jsonSerialize() : array\n    {\n        $data = parent::jsonSerialize();\n        $data['http'] = $this->serialiseHttpData();\n        $data['service'] = empty($this->serviceVersion) ? null : ['version' => $this->serviceVersion];\n        $data['user'] = $this->user ?? null;\n        return array_filter($data);\n    }\n    \/**\n     * @throws Exception if an appropriate source of randomness cannot be found.\n     *\/\n    private function generateTraceId() : void\n    {\n        $startHex = dechex((int) $this->startTime);\n        $uuid = bin2hex(random_bytes(12));\n        $this->setTraceId(\"1-{$startHex}-{$uuid}\");\n    }\n}","originalFilePath":"\/home\/ranpafin\/php-xray\/src\/Trace.php","originalStartLine":63},"diff":"--- Original\n+++ New\n@@ @@\n         if (!isset($this->traceId)) {\n             $this->generateTraceId();\n         }\n-        if (!$this->isSampled()) {\n+        if ($this->isSampled()) {\n             $this->sampled = random_int(0, 99) < $samplePercentage;\n         }\n         return $this;","processOutput":"PHPUnit 9.5.10 by Sebastian Bergmann and contributors.\n\nRuntime:       PHP 8.0.13\nConfiguration: \/tmp\/tmp-folder\/infection\/phpunitConfiguration.c4b49d569980f6b94ead399164c09b49.infection.xml\n\nE\n\nTime: 00:00.003, Memory: 8.00 MB\n\nThere was 1 error:\n\n1) Fido\\PHPXray\\DaemonSegmentSubmitterTest::testSubmitsToDaemon\nsocket_bind(): Unable to bind address [98]: Address already in use\n\n\/home\/ranpafin\/php-xray\/tests\/DaemonSegmentSubmitterTest.php:18\n\nERRORS!\nTests: 1, Assertions: 0, Errors: 1."},{"mutator":{"mutatorName":"Ternary","originalSourceCode":"<?php\n\nnamespace Fido\\PHPXray;\n\nuse Exception;\nclass Trace extends Segment\n{\n    use HttpTrait;\n    private static self $instance;\n    private string $serviceVersion;\n    private string $user;\n    public static function getInstance() : self\n    {\n        if (!isset(self::$instance)) {\n            self::$instance = new self();\n        }\n        return self::$instance;\n    }\n    public function setServiceVersion(string $serviceVersion) : self\n    {\n        $this->serviceVersion = $serviceVersion;\n        return $this;\n    }\n    public function setUser(string $user) : self\n    {\n        $this->user = $user;\n        return $this;\n    }\n    public function setClientIpAddress(string $clientIpAddress) : self\n    {\n        $this->clientIpAddress = $clientIpAddress;\n        return $this;\n    }\n    public function setUserAgent(string $userAgent) : self\n    {\n        $this->userAgent = $userAgent;\n        return $this;\n    }\n    \/**\n     * @throws Exception\n     *\/\n    public function begin(int $samplePercentage = 10) : Segment\n    {\n        parent::begin();\n        if (!isset($this->traceId)) {\n            $this->generateTraceId();\n        }\n        if (!$this->isSampled()) {\n            $this->sampled = random_int(0, 99) < $samplePercentage;\n        }\n        return $this;\n    }\n    \/**\n     * @inheritdoc\n     *\/\n    public function jsonSerialize() : array\n    {\n        $data = parent::jsonSerialize();\n        $data['http'] = $this->serialiseHttpData();\n        $data['service'] = empty($this->serviceVersion) ? null : ['version' => $this->serviceVersion];\n        $data['user'] = $this->user ?? null;\n        return array_filter($data);\n    }\n    \/**\n     * @throws Exception if an appropriate source of randomness cannot be found.\n     *\/\n    private function generateTraceId() : void\n    {\n        $startHex = dechex((int) $this->startTime);\n        $uuid = bin2hex(random_bytes(12));\n        $this->setTraceId(\"1-{$startHex}-{$uuid}\");\n    }\n}","mutatedSourceCode":"<?php\n\nnamespace Fido\\PHPXray;\n\nuse Exception;\nclass Trace extends Segment\n{\n    use HttpTrait;\n    private static self $instance;\n    private string $serviceVersion;\n    private string $user;\n    public static function getInstance() : self\n    {\n        if (!isset(self::$instance)) {\n            self::$instance = new self();\n        }\n        return self::$instance;\n    }\n    public function setServiceVersion(string $serviceVersion) : self\n    {\n        $this->serviceVersion = $serviceVersion;\n        return $this;\n    }\n    public function setUser(string $user) : self\n    {\n        $this->user = $user;\n        return $this;\n    }\n    public function setClientIpAddress(string $clientIpAddress) : self\n    {\n        $this->clientIpAddress = $clientIpAddress;\n        return $this;\n    }\n    public function setUserAgent(string $userAgent) : self\n    {\n        $this->userAgent = $userAgent;\n        return $this;\n    }\n    \/**\n     * @throws Exception\n     *\/\n    public function begin(int $samplePercentage = 10) : Segment\n    {\n        parent::begin();\n        if (!isset($this->traceId)) {\n            $this->generateTraceId();\n        }\n        if (!$this->isSampled()) {\n            $this->sampled = random_int(0, 99) < $samplePercentage;\n        }\n        return $this;\n    }\n    \/**\n     * @inheritdoc\n     *\/\n    public function jsonSerialize() : array\n    {\n        $data = parent::jsonSerialize();\n        $data['http'] = $this->serialiseHttpData();\n        $data['service'] = empty($this->serviceVersion) ? ['version' => $this->serviceVersion] : null;\n        $data['user'] = $this->user ?? null;\n        return array_filter($data);\n    }\n    \/**\n     * @throws Exception if an appropriate source of randomness cannot be found.\n     *\/\n    private function generateTraceId() : void\n    {\n        $startHex = dechex((int) $this->startTime);\n        $uuid = bin2hex(random_bytes(12));\n        $this->setTraceId(\"1-{$startHex}-{$uuid}\");\n    }\n}","originalFilePath":"\/home\/ranpafin\/php-xray\/src\/Trace.php","originalStartLine":78},"diff":"--- Original\n+++ New\n@@ @@\n     {\n         $data = parent::jsonSerialize();\n         $data['http'] = $this->serialiseHttpData();\n-        $data['service'] = empty($this->serviceVersion) ? null : ['version' => $this->serviceVersion];\n+        $data['service'] = empty($this->serviceVersion) ? ['version' => $this->serviceVersion] : null;\n         $data['user'] = $this->user ?? null;\n         return array_filter($data);\n     }","processOutput":"PHPUnit 9.5.10 by Sebastian Bergmann and contributors.\n\nRuntime:       PHP 8.0.13\nConfiguration: \/tmp\/tmp-folder\/infection\/phpunitConfiguration.8adcd2162af00827873ba228c5d2c033.infection.xml\n\nE\n\nTime: 00:00.005, Memory: 8.00 MB\n\nThere was 1 error:\n\n1) Fido\\PHPXray\\DaemonSegmentSubmitterTest::testSubmitsToDaemon\nsocket_bind(): Unable to bind address [98]: Address already in use\n\n\/home\/ranpafin\/php-xray\/tests\/DaemonSegmentSubmitterTest.php:18\n\nERRORS!\nTests: 1, Assertions: 0, Errors: 1."},{"mutator":{"mutatorName":"ArrayItem","originalSourceCode":"<?php\n\nnamespace Fido\\PHPXray;\n\nuse Exception;\nclass Trace extends Segment\n{\n    use HttpTrait;\n    private static self $instance;\n    private string $serviceVersion;\n    private string $user;\n    public static function getInstance() : self\n    {\n        if (!isset(self::$instance)) {\n            self::$instance = new self();\n        }\n        return self::$instance;\n    }\n    public function setServiceVersion(string $serviceVersion) : self\n    {\n        $this->serviceVersion = $serviceVersion;\n        return $this;\n    }\n    public function setUser(string $user) : self\n    {\n        $this->user = $user;\n        return $this;\n    }\n    public function setClientIpAddress(string $clientIpAddress) : self\n    {\n        $this->clientIpAddress = $clientIpAddress;\n        return $this;\n    }\n    public function setUserAgent(string $userAgent) : self\n    {\n        $this->userAgent = $userAgent;\n        return $this;\n    }\n    \/**\n     * @throws Exception\n     *\/\n    public function begin(int $samplePercentage = 10) : Segment\n    {\n        parent::begin();\n        if (!isset($this->traceId)) {\n            $this->generateTraceId();\n        }\n        if (!$this->isSampled()) {\n            $this->sampled = random_int(0, 99) < $samplePercentage;\n        }\n        return $this;\n    }\n    \/**\n     * @inheritdoc\n     *\/\n    public function jsonSerialize() : array\n    {\n        $data = parent::jsonSerialize();\n        $data['http'] = $this->serialiseHttpData();\n        $data['service'] = empty($this->serviceVersion) ? null : ['version' => $this->serviceVersion];\n        $data['user'] = $this->user ?? null;\n        return array_filter($data);\n    }\n    \/**\n     * @throws Exception if an appropriate source of randomness cannot be found.\n     *\/\n    private function generateTraceId() : void\n    {\n        $startHex = dechex((int) $this->startTime);\n        $uuid = bin2hex(random_bytes(12));\n        $this->setTraceId(\"1-{$startHex}-{$uuid}\");\n    }\n}","mutatedSourceCode":"<?php\n\nnamespace Fido\\PHPXray;\n\nuse Exception;\nclass Trace extends Segment\n{\n    use HttpTrait;\n    private static self $instance;\n    private string $serviceVersion;\n    private string $user;\n    public static function getInstance() : self\n    {\n        if (!isset(self::$instance)) {\n            self::$instance = new self();\n        }\n        return self::$instance;\n    }\n    public function setServiceVersion(string $serviceVersion) : self\n    {\n        $this->serviceVersion = $serviceVersion;\n        return $this;\n    }\n    public function setUser(string $user) : self\n    {\n        $this->user = $user;\n        return $this;\n    }\n    public function setClientIpAddress(string $clientIpAddress) : self\n    {\n        $this->clientIpAddress = $clientIpAddress;\n        return $this;\n    }\n    public function setUserAgent(string $userAgent) : self\n    {\n        $this->userAgent = $userAgent;\n        return $this;\n    }\n    \/**\n     * @throws Exception\n     *\/\n    public function begin(int $samplePercentage = 10) : Segment\n    {\n        parent::begin();\n        if (!isset($this->traceId)) {\n            $this->generateTraceId();\n        }\n        if (!$this->isSampled()) {\n            $this->sampled = random_int(0, 99) < $samplePercentage;\n        }\n        return $this;\n    }\n    \/**\n     * @inheritdoc\n     *\/\n    public function jsonSerialize() : array\n    {\n        $data = parent::jsonSerialize();\n        $data['http'] = $this->serialiseHttpData();\n        $data['service'] = empty($this->serviceVersion) ? null : ['version' > $this->serviceVersion];\n        $data['user'] = $this->user ?? null;\n        return array_filter($data);\n    }\n    \/**\n     * @throws Exception if an appropriate source of randomness cannot be found.\n     *\/\n    private function generateTraceId() : void\n    {\n        $startHex = dechex((int) $this->startTime);\n        $uuid = bin2hex(random_bytes(12));\n        $this->setTraceId(\"1-{$startHex}-{$uuid}\");\n    }\n}","originalFilePath":"\/home\/ranpafin\/php-xray\/src\/Trace.php","originalStartLine":78},"diff":"--- Original\n+++ New\n@@ @@\n     {\n         $data = parent::jsonSerialize();\n         $data['http'] = $this->serialiseHttpData();\n-        $data['service'] = empty($this->serviceVersion) ? null : ['version' => $this->serviceVersion];\n+        $data['service'] = empty($this->serviceVersion) ? null : ['version' > $this->serviceVersion];\n         $data['user'] = $this->user ?? null;\n         return array_filter($data);\n     }","processOutput":"PHPUnit 9.5.10 by Sebastian Bergmann and contributors.\n\nRuntime:       PHP 8.0.13\nConfiguration: \/tmp\/tmp-folder\/infection\/phpunitConfiguration.ad82e06a6880ec6d082f01e25cae41b6.infection.xml\n\nE\n\nTime: 00:00.006, Memory: 8.00 MB\n\nThere was 1 error:\n\n1) Fido\\PHPXray\\DaemonSegmentSubmitterTest::testSubmitsToDaemon\nsocket_bind(): Unable to bind address [98]: Address already in use\n\n\/home\/ranpafin\/php-xray\/tests\/DaemonSegmentSubmitterTest.php:18\n\nERRORS!\nTests: 1, Assertions: 0, Errors: 1."},{"mutator":{"mutatorName":"ArrayItemRemoval","originalSourceCode":"<?php\n\nnamespace Fido\\PHPXray;\n\nuse Exception;\nclass Trace extends Segment\n{\n    use HttpTrait;\n    private static self $instance;\n    private string $serviceVersion;\n    private string $user;\n    public static function getInstance() : self\n    {\n        if (!isset(self::$instance)) {\n            self::$instance = new self();\n        }\n        return self::$instance;\n    }\n    public function setServiceVersion(string $serviceVersion) : self\n    {\n        $this->serviceVersion = $serviceVersion;\n        return $this;\n    }\n    public function setUser(string $user) : self\n    {\n        $this->user = $user;\n        return $this;\n    }\n    public function setClientIpAddress(string $clientIpAddress) : self\n    {\n        $this->clientIpAddress = $clientIpAddress;\n        return $this;\n    }\n    public function setUserAgent(string $userAgent) : self\n    {\n        $this->userAgent = $userAgent;\n        return $this;\n    }\n    \/**\n     * @throws Exception\n     *\/\n    public function begin(int $samplePercentage = 10) : Segment\n    {\n        parent::begin();\n        if (!isset($this->traceId)) {\n            $this->generateTraceId();\n        }\n        if (!$this->isSampled()) {\n            $this->sampled = random_int(0, 99) < $samplePercentage;\n        }\n        return $this;\n    }\n    \/**\n     * @inheritdoc\n     *\/\n    public function jsonSerialize() : array\n    {\n        $data = parent::jsonSerialize();\n        $data['http'] = $this->serialiseHttpData();\n        $data['service'] = empty($this->serviceVersion) ? null : ['version' => $this->serviceVersion];\n        $data['user'] = $this->user ?? null;\n        return array_filter($data);\n    }\n    \/**\n     * @throws Exception if an appropriate source of randomness cannot be found.\n     *\/\n    private function generateTraceId() : void\n    {\n        $startHex = dechex((int) $this->startTime);\n        $uuid = bin2hex(random_bytes(12));\n        $this->setTraceId(\"1-{$startHex}-{$uuid}\");\n    }\n}","mutatedSourceCode":"<?php\n\nnamespace Fido\\PHPXray;\n\nuse Exception;\nclass Trace extends Segment\n{\n    use HttpTrait;\n    private static self $instance;\n    private string $serviceVersion;\n    private string $user;\n    public static function getInstance() : self\n    {\n        if (!isset(self::$instance)) {\n            self::$instance = new self();\n        }\n        return self::$instance;\n    }\n    public function setServiceVersion(string $serviceVersion) : self\n    {\n        $this->serviceVersion = $serviceVersion;\n        return $this;\n    }\n    public function setUser(string $user) : self\n    {\n        $this->user = $user;\n        return $this;\n    }\n    public function setClientIpAddress(string $clientIpAddress) : self\n    {\n        $this->clientIpAddress = $clientIpAddress;\n        return $this;\n    }\n    public function setUserAgent(string $userAgent) : self\n    {\n        $this->userAgent = $userAgent;\n        return $this;\n    }\n    \/**\n     * @throws Exception\n     *\/\n    public function begin(int $samplePercentage = 10) : Segment\n    {\n        parent::begin();\n        if (!isset($this->traceId)) {\n            $this->generateTraceId();\n        }\n        if (!$this->isSampled()) {\n            $this->sampled = random_int(0, 99) < $samplePercentage;\n        }\n        return $this;\n    }\n    \/**\n     * @inheritdoc\n     *\/\n    public function jsonSerialize() : array\n    {\n        $data = parent::jsonSerialize();\n        $data['http'] = $this->serialiseHttpData();\n        $data['service'] = empty($this->serviceVersion) ? null : [];\n        $data['user'] = $this->user ?? null;\n        return array_filter($data);\n    }\n    \/**\n     * @throws Exception if an appropriate source of randomness cannot be found.\n     *\/\n    private function generateTraceId() : void\n    {\n        $startHex = dechex((int) $this->startTime);\n        $uuid = bin2hex(random_bytes(12));\n        $this->setTraceId(\"1-{$startHex}-{$uuid}\");\n    }\n}","originalFilePath":"\/home\/ranpafin\/php-xray\/src\/Trace.php","originalStartLine":78},"diff":"--- Original\n+++ New\n@@ @@\n     {\n         $data = parent::jsonSerialize();\n         $data['http'] = $this->serialiseHttpData();\n-        $data['service'] = empty($this->serviceVersion) ? null : ['version' => $this->serviceVersion];\n+        $data['service'] = empty($this->serviceVersion) ? null : [];\n         $data['user'] = $this->user ?? null;\n         return array_filter($data);\n     }","processOutput":"PHPUnit 9.5.10 by Sebastian Bergmann and contributors.\n\nRuntime:       PHP 8.0.13\nConfiguration: \/tmp\/tmp-folder\/infection\/phpunitConfiguration.021a264a09b8d676810d223b06db8090.infection.xml\n\nE\n\nTime: 00:00.005, Memory: 8.00 MB\n\nThere was 1 error:\n\n1) Fido\\PHPXray\\DaemonSegmentSubmitterTest::testSubmitsToDaemon\nsocket_bind(): Unable to bind address [98]: Address already in use\n\n\/home\/ranpafin\/php-xray\/tests\/DaemonSegmentSubmitterTest.php:18\n\nERRORS!\nTests: 1, Assertions: 0, Errors: 1."},{"mutator":{"mutatorName":"Coalesce","originalSourceCode":"<?php\n\nnamespace Fido\\PHPXray;\n\nuse Exception;\nclass Trace extends Segment\n{\n    use HttpTrait;\n    private static self $instance;\n    private string $serviceVersion;\n    private string $user;\n    public static function getInstance() : self\n    {\n        if (!isset(self::$instance)) {\n            self::$instance = new self();\n        }\n        return self::$instance;\n    }\n    public function setServiceVersion(string $serviceVersion) : self\n    {\n        $this->serviceVersion = $serviceVersion;\n        return $this;\n    }\n    public function setUser(string $user) : self\n    {\n        $this->user = $user;\n        return $this;\n    }\n    public function setClientIpAddress(string $clientIpAddress) : self\n    {\n        $this->clientIpAddress = $clientIpAddress;\n        return $this;\n    }\n    public function setUserAgent(string $userAgent) : self\n    {\n        $this->userAgent = $userAgent;\n        return $this;\n    }\n    \/**\n     * @throws Exception\n     *\/\n    public function begin(int $samplePercentage = 10) : Segment\n    {\n        parent::begin();\n        if (!isset($this->traceId)) {\n            $this->generateTraceId();\n        }\n        if (!$this->isSampled()) {\n            $this->sampled = random_int(0, 99) < $samplePercentage;\n        }\n        return $this;\n    }\n    \/**\n     * @inheritdoc\n     *\/\n    public function jsonSerialize() : array\n    {\n        $data = parent::jsonSerialize();\n        $data['http'] = $this->serialiseHttpData();\n        $data['service'] = empty($this->serviceVersion) ? null : ['version' => $this->serviceVersion];\n        $data['user'] = $this->user ?? null;\n        return array_filter($data);\n    }\n    \/**\n     * @throws Exception if an appropriate source of randomness cannot be found.\n     *\/\n    private function generateTraceId() : void\n    {\n        $startHex = dechex((int) $this->startTime);\n        $uuid = bin2hex(random_bytes(12));\n        $this->setTraceId(\"1-{$startHex}-{$uuid}\");\n    }\n}","mutatedSourceCode":"<?php\n\nnamespace Fido\\PHPXray;\n\nuse Exception;\nclass Trace extends Segment\n{\n    use HttpTrait;\n    private static self $instance;\n    private string $serviceVersion;\n    private string $user;\n    public static function getInstance() : self\n    {\n        if (!isset(self::$instance)) {\n            self::$instance = new self();\n        }\n        return self::$instance;\n    }\n    public function setServiceVersion(string $serviceVersion) : self\n    {\n        $this->serviceVersion = $serviceVersion;\n        return $this;\n    }\n    public function setUser(string $user) : self\n    {\n        $this->user = $user;\n        return $this;\n    }\n    public function setClientIpAddress(string $clientIpAddress) : self\n    {\n        $this->clientIpAddress = $clientIpAddress;\n        return $this;\n    }\n    public function setUserAgent(string $userAgent) : self\n    {\n        $this->userAgent = $userAgent;\n        return $this;\n    }\n    \/**\n     * @throws Exception\n     *\/\n    public function begin(int $samplePercentage = 10) : Segment\n    {\n        parent::begin();\n        if (!isset($this->traceId)) {\n            $this->generateTraceId();\n        }\n        if (!$this->isSampled()) {\n            $this->sampled = random_int(0, 99) < $samplePercentage;\n        }\n        return $this;\n    }\n    \/**\n     * @inheritdoc\n     *\/\n    public function jsonSerialize() : array\n    {\n        $data = parent::jsonSerialize();\n        $data['http'] = $this->serialiseHttpData();\n        $data['service'] = empty($this->serviceVersion) ? null : ['version' => $this->serviceVersion];\n        $data['user'] = null ?? $this->user;\n        return array_filter($data);\n    }\n    \/**\n     * @throws Exception if an appropriate source of randomness cannot be found.\n     *\/\n    private function generateTraceId() : void\n    {\n        $startHex = dechex((int) $this->startTime);\n        $uuid = bin2hex(random_bytes(12));\n        $this->setTraceId(\"1-{$startHex}-{$uuid}\");\n    }\n}","originalFilePath":"\/home\/ranpafin\/php-xray\/src\/Trace.php","originalStartLine":79},"diff":"--- Original\n+++ New\n@@ @@\n         $data = parent::jsonSerialize();\n         $data['http'] = $this->serialiseHttpData();\n         $data['service'] = empty($this->serviceVersion) ? null : ['version' => $this->serviceVersion];\n-        $data['user'] = $this->user ?? null;\n+        $data['user'] = null ?? $this->user;\n         return array_filter($data);\n     }\n     \/**","processOutput":"PHPUnit 9.5.10 by Sebastian Bergmann and contributors.\n\nRuntime:       PHP 8.0.13\nConfiguration: \/tmp\/tmp-folder\/infection\/phpunitConfiguration.9630fe925938818096193a40a36131bd.infection.xml\n\nE\n\nTime: 00:00.004, Memory: 8.00 MB\n\nThere was 1 error:\n\n1) Fido\\PHPXray\\DaemonSegmentSubmitterTest::testSubmitsToDaemon\nsocket_bind(): Unable to bind address [98]: Address already in use\n\n\/home\/ranpafin\/php-xray\/tests\/DaemonSegmentSubmitterTest.php:18\n\nERRORS!\nTests: 1, Assertions: 0, Errors: 1."},{"mutator":{"mutatorName":"UnwrapArrayFilter","originalSourceCode":"<?php\n\nnamespace Fido\\PHPXray;\n\nuse Exception;\nclass Trace extends Segment\n{\n    use HttpTrait;\n    private static self $instance;\n    private string $serviceVersion;\n    private string $user;\n    public static function getInstance() : self\n    {\n        if (!isset(self::$instance)) {\n            self::$instance = new self();\n        }\n        return self::$instance;\n    }\n    public function setServiceVersion(string $serviceVersion) : self\n    {\n        $this->serviceVersion = $serviceVersion;\n        return $this;\n    }\n    public function setUser(string $user) : self\n    {\n        $this->user = $user;\n        return $this;\n    }\n    public function setClientIpAddress(string $clientIpAddress) : self\n    {\n        $this->clientIpAddress = $clientIpAddress;\n        return $this;\n    }\n    public function setUserAgent(string $userAgent) : self\n    {\n        $this->userAgent = $userAgent;\n        return $this;\n    }\n    \/**\n     * @throws Exception\n     *\/\n    public function begin(int $samplePercentage = 10) : Segment\n    {\n        parent::begin();\n        if (!isset($this->traceId)) {\n            $this->generateTraceId();\n        }\n        if (!$this->isSampled()) {\n            $this->sampled = random_int(0, 99) < $samplePercentage;\n        }\n        return $this;\n    }\n    \/**\n     * @inheritdoc\n     *\/\n    public function jsonSerialize() : array\n    {\n        $data = parent::jsonSerialize();\n        $data['http'] = $this->serialiseHttpData();\n        $data['service'] = empty($this->serviceVersion) ? null : ['version' => $this->serviceVersion];\n        $data['user'] = $this->user ?? null;\n        return array_filter($data);\n    }\n    \/**\n     * @throws Exception if an appropriate source of randomness cannot be found.\n     *\/\n    private function generateTraceId() : void\n    {\n        $startHex = dechex((int) $this->startTime);\n        $uuid = bin2hex(random_bytes(12));\n        $this->setTraceId(\"1-{$startHex}-{$uuid}\");\n    }\n}","mutatedSourceCode":"<?php\n\nnamespace Fido\\PHPXray;\n\nuse Exception;\nclass Trace extends Segment\n{\n    use HttpTrait;\n    private static self $instance;\n    private string $serviceVersion;\n    private string $user;\n    public static function getInstance() : self\n    {\n        if (!isset(self::$instance)) {\n            self::$instance = new self();\n        }\n        return self::$instance;\n    }\n    public function setServiceVersion(string $serviceVersion) : self\n    {\n        $this->serviceVersion = $serviceVersion;\n        return $this;\n    }\n    public function setUser(string $user) : self\n    {\n        $this->user = $user;\n        return $this;\n    }\n    public function setClientIpAddress(string $clientIpAddress) : self\n    {\n        $this->clientIpAddress = $clientIpAddress;\n        return $this;\n    }\n    public function setUserAgent(string $userAgent) : self\n    {\n        $this->userAgent = $userAgent;\n        return $this;\n    }\n    \/**\n     * @throws Exception\n     *\/\n    public function begin(int $samplePercentage = 10) : Segment\n    {\n        parent::begin();\n        if (!isset($this->traceId)) {\n            $this->generateTraceId();\n        }\n        if (!$this->isSampled()) {\n            $this->sampled = random_int(0, 99) < $samplePercentage;\n        }\n        return $this;\n    }\n    \/**\n     * @inheritdoc\n     *\/\n    public function jsonSerialize() : array\n    {\n        $data = parent::jsonSerialize();\n        $data['http'] = $this->serialiseHttpData();\n        $data['service'] = empty($this->serviceVersion) ? null : ['version' => $this->serviceVersion];\n        $data['user'] = $this->user ?? null;\n        return $data;\n    }\n    \/**\n     * @throws Exception if an appropriate source of randomness cannot be found.\n     *\/\n    private function generateTraceId() : void\n    {\n        $startHex = dechex((int) $this->startTime);\n        $uuid = bin2hex(random_bytes(12));\n        $this->setTraceId(\"1-{$startHex}-{$uuid}\");\n    }\n}","originalFilePath":"\/home\/ranpafin\/php-xray\/src\/Trace.php","originalStartLine":81},"diff":"--- Original\n+++ New\n@@ @@\n         $data['http'] = $this->serialiseHttpData();\n         $data['service'] = empty($this->serviceVersion) ? null : ['version' => $this->serviceVersion];\n         $data['user'] = $this->user ?? null;\n-        return array_filter($data);\n+        return $data;\n     }\n     \/**\n      * @throws Exception if an appropriate source of randomness cannot be found.","processOutput":"PHPUnit 9.5.10 by Sebastian Bergmann and contributors.\n\nRuntime:       PHP 8.0.13\nConfiguration: \/tmp\/tmp-folder\/infection\/phpunitConfiguration.bd4f9891e1613a665c19faf6ccfb04d8.infection.xml\n\nE\n\nTime: 00:00.003, Memory: 8.00 MB\n\nThere was 1 error:\n\n1) Fido\\PHPXray\\DaemonSegmentSubmitterTest::testSubmitsToDaemon\nsocket_bind(): Unable to bind address [98]: Address already in use\n\n\/home\/ranpafin\/php-xray\/tests\/DaemonSegmentSubmitterTest.php:18\n\nERRORS!\nTests: 1, Assertions: 0, Errors: 1."},{"mutator":{"mutatorName":"CastInt","originalSourceCode":"<?php\n\nnamespace Fido\\PHPXray;\n\nuse Exception;\nclass Trace extends Segment\n{\n    use HttpTrait;\n    private static self $instance;\n    private string $serviceVersion;\n    private string $user;\n    public static function getInstance() : self\n    {\n        if (!isset(self::$instance)) {\n            self::$instance = new self();\n        }\n        return self::$instance;\n    }\n    public function setServiceVersion(string $serviceVersion) : self\n    {\n        $this->serviceVersion = $serviceVersion;\n        return $this;\n    }\n    public function setUser(string $user) : self\n    {\n        $this->user = $user;\n        return $this;\n    }\n    public function setClientIpAddress(string $clientIpAddress) : self\n    {\n        $this->clientIpAddress = $clientIpAddress;\n        return $this;\n    }\n    public function setUserAgent(string $userAgent) : self\n    {\n        $this->userAgent = $userAgent;\n        return $this;\n    }\n    \/**\n     * @throws Exception\n     *\/\n    public function begin(int $samplePercentage = 10) : Segment\n    {\n        parent::begin();\n        if (!isset($this->traceId)) {\n            $this->generateTraceId();\n        }\n        if (!$this->isSampled()) {\n            $this->sampled = random_int(0, 99) < $samplePercentage;\n        }\n        return $this;\n    }\n    \/**\n     * @inheritdoc\n     *\/\n    public function jsonSerialize() : array\n    {\n        $data = parent::jsonSerialize();\n        $data['http'] = $this->serialiseHttpData();\n        $data['service'] = empty($this->serviceVersion) ? null : ['version' => $this->serviceVersion];\n        $data['user'] = $this->user ?? null;\n        return array_filter($data);\n    }\n    \/**\n     * @throws Exception if an appropriate source of randomness cannot be found.\n     *\/\n    private function generateTraceId() : void\n    {\n        $startHex = dechex((int) $this->startTime);\n        $uuid = bin2hex(random_bytes(12));\n        $this->setTraceId(\"1-{$startHex}-{$uuid}\");\n    }\n}","mutatedSourceCode":"<?php\n\nnamespace Fido\\PHPXray;\n\nuse Exception;\nclass Trace extends Segment\n{\n    use HttpTrait;\n    private static self $instance;\n    private string $serviceVersion;\n    private string $user;\n    public static function getInstance() : self\n    {\n        if (!isset(self::$instance)) {\n            self::$instance = new self();\n        }\n        return self::$instance;\n    }\n    public function setServiceVersion(string $serviceVersion) : self\n    {\n        $this->serviceVersion = $serviceVersion;\n        return $this;\n    }\n    public function setUser(string $user) : self\n    {\n        $this->user = $user;\n        return $this;\n    }\n    public function setClientIpAddress(string $clientIpAddress) : self\n    {\n        $this->clientIpAddress = $clientIpAddress;\n        return $this;\n    }\n    public function setUserAgent(string $userAgent) : self\n    {\n        $this->userAgent = $userAgent;\n        return $this;\n    }\n    \/**\n     * @throws Exception\n     *\/\n    public function begin(int $samplePercentage = 10) : Segment\n    {\n        parent::begin();\n        if (!isset($this->traceId)) {\n            $this->generateTraceId();\n        }\n        if (!$this->isSampled()) {\n            $this->sampled = random_int(0, 99) < $samplePercentage;\n        }\n        return $this;\n    }\n    \/**\n     * @inheritdoc\n     *\/\n    public function jsonSerialize() : array\n    {\n        $data = parent::jsonSerialize();\n        $data['http'] = $this->serialiseHttpData();\n        $data['service'] = empty($this->serviceVersion) ? null : ['version' => $this->serviceVersion];\n        $data['user'] = $this->user ?? null;\n        return array_filter($data);\n    }\n    \/**\n     * @throws Exception if an appropriate source of randomness cannot be found.\n     *\/\n    private function generateTraceId() : void\n    {\n        $startHex = dechex($this->startTime);\n        $uuid = bin2hex(random_bytes(12));\n        $this->setTraceId(\"1-{$startHex}-{$uuid}\");\n    }\n}","originalFilePath":"\/home\/ranpafin\/php-xray\/src\/Trace.php","originalStartLine":89},"diff":"--- Original\n+++ New\n@@ @@\n      *\/\n     private function generateTraceId() : void\n     {\n-        $startHex = dechex((int) $this->startTime);\n+        $startHex = dechex($this->startTime);\n         $uuid = bin2hex(random_bytes(12));\n         $this->setTraceId(\"1-{$startHex}-{$uuid}\");\n     }\n }","processOutput":"PHPUnit 9.5.10 by Sebastian Bergmann and contributors.\n\nRuntime:       PHP 8.0.13\nConfiguration: \/tmp\/tmp-folder\/infection\/phpunitConfiguration.71cf1ef695d77bc64ed5aed75ed8b0ba.infection.xml\n\nE\n\nTime: 00:00.003, Memory: 8.00 MB\n\nThere was 1 error:\n\n1) Fido\\PHPXray\\DaemonSegmentSubmitterTest::testSubmitsToDaemon\nsocket_bind(): Unable to bind address [98]: Address already in use\n\n\/home\/ranpafin\/php-xray\/tests\/DaemonSegmentSubmitterTest.php:18\n\nERRORS!\nTests: 1, Assertions: 0, Errors: 1."},{"mutator":{"mutatorName":"DecrementInteger","originalSourceCode":"<?php\n\nnamespace Fido\\PHPXray;\n\nuse Exception;\nclass Trace extends Segment\n{\n    use HttpTrait;\n    private static self $instance;\n    private string $serviceVersion;\n    private string $user;\n    public static function getInstance() : self\n    {\n        if (!isset(self::$instance)) {\n            self::$instance = new self();\n        }\n        return self::$instance;\n    }\n    public function setServiceVersion(string $serviceVersion) : self\n    {\n        $this->serviceVersion = $serviceVersion;\n        return $this;\n    }\n    public function setUser(string $user) : self\n    {\n        $this->user = $user;\n        return $this;\n    }\n    public function setClientIpAddress(string $clientIpAddress) : self\n    {\n        $this->clientIpAddress = $clientIpAddress;\n        return $this;\n    }\n    public function setUserAgent(string $userAgent) : self\n    {\n        $this->userAgent = $userAgent;\n        return $this;\n    }\n    \/**\n     * @throws Exception\n     *\/\n    public function begin(int $samplePercentage = 10) : Segment\n    {\n        parent::begin();\n        if (!isset($this->traceId)) {\n            $this->generateTraceId();\n        }\n        if (!$this->isSampled()) {\n            $this->sampled = random_int(0, 99) < $samplePercentage;\n        }\n        return $this;\n    }\n    \/**\n     * @inheritdoc\n     *\/\n    public function jsonSerialize() : array\n    {\n        $data = parent::jsonSerialize();\n        $data['http'] = $this->serialiseHttpData();\n        $data['service'] = empty($this->serviceVersion) ? null : ['version' => $this->serviceVersion];\n        $data['user'] = $this->user ?? null;\n        return array_filter($data);\n    }\n    \/**\n     * @throws Exception if an appropriate source of randomness cannot be found.\n     *\/\n    private function generateTraceId() : void\n    {\n        $startHex = dechex((int) $this->startTime);\n        $uuid = bin2hex(random_bytes(12));\n        $this->setTraceId(\"1-{$startHex}-{$uuid}\");\n    }\n}","mutatedSourceCode":"<?php\n\nnamespace Fido\\PHPXray;\n\nuse Exception;\nclass Trace extends Segment\n{\n    use HttpTrait;\n    private static self $instance;\n    private string $serviceVersion;\n    private string $user;\n    public static function getInstance() : self\n    {\n        if (!isset(self::$instance)) {\n            self::$instance = new self();\n        }\n        return self::$instance;\n    }\n    public function setServiceVersion(string $serviceVersion) : self\n    {\n        $this->serviceVersion = $serviceVersion;\n        return $this;\n    }\n    public function setUser(string $user) : self\n    {\n        $this->user = $user;\n        return $this;\n    }\n    public function setClientIpAddress(string $clientIpAddress) : self\n    {\n        $this->clientIpAddress = $clientIpAddress;\n        return $this;\n    }\n    public function setUserAgent(string $userAgent) : self\n    {\n        $this->userAgent = $userAgent;\n        return $this;\n    }\n    \/**\n     * @throws Exception\n     *\/\n    public function begin(int $samplePercentage = 10) : Segment\n    {\n        parent::begin();\n        if (!isset($this->traceId)) {\n            $this->generateTraceId();\n        }\n        if (!$this->isSampled()) {\n            $this->sampled = random_int(0, 99) < $samplePercentage;\n        }\n        return $this;\n    }\n    \/**\n     * @inheritdoc\n     *\/\n    public function jsonSerialize() : array\n    {\n        $data = parent::jsonSerialize();\n        $data['http'] = $this->serialiseHttpData();\n        $data['service'] = empty($this->serviceVersion) ? null : ['version' => $this->serviceVersion];\n        $data['user'] = $this->user ?? null;\n        return array_filter($data);\n    }\n    \/**\n     * @throws Exception if an appropriate source of randomness cannot be found.\n     *\/\n    private function generateTraceId() : void\n    {\n        $startHex = dechex((int) $this->startTime);\n        $uuid = bin2hex(random_bytes(11));\n        $this->setTraceId(\"1-{$startHex}-{$uuid}\");\n    }\n}","originalFilePath":"\/home\/ranpafin\/php-xray\/src\/Trace.php","originalStartLine":90},"diff":"--- Original\n+++ New\n@@ @@\n     private function generateTraceId() : void\n     {\n         $startHex = dechex((int) $this->startTime);\n-        $uuid = bin2hex(random_bytes(12));\n+        $uuid = bin2hex(random_bytes(11));\n         $this->setTraceId(\"1-{$startHex}-{$uuid}\");\n     }\n }","processOutput":"PHPUnit 9.5.10 by Sebastian Bergmann and contributors.\n\nRuntime:       PHP 8.0.13\nConfiguration: \/tmp\/tmp-folder\/infection\/phpunitConfiguration.59e0140c93f15747a64b78cfbd1d189e.infection.xml\n\nE\n\nTime: 00:00.002, Memory: 8.00 MB\n\nThere was 1 error:\n\n1) Fido\\PHPXray\\DaemonSegmentSubmitterTest::testSubmitsToDaemon\nsocket_bind(): Unable to bind address [98]: Address already in use\n\n\/home\/ranpafin\/php-xray\/tests\/DaemonSegmentSubmitterTest.php:18\n\nERRORS!\nTests: 1, Assertions: 0, Errors: 1."},{"mutator":{"mutatorName":"IncrementInteger","originalSourceCode":"<?php\n\nnamespace Fido\\PHPXray;\n\nuse Exception;\nclass Trace extends Segment\n{\n    use HttpTrait;\n    private static self $instance;\n    private string $serviceVersion;\n    private string $user;\n    public static function getInstance() : self\n    {\n        if (!isset(self::$instance)) {\n            self::$instance = new self();\n        }\n        return self::$instance;\n    }\n    public function setServiceVersion(string $serviceVersion) : self\n    {\n        $this->serviceVersion = $serviceVersion;\n        return $this;\n    }\n    public function setUser(string $user) : self\n    {\n        $this->user = $user;\n        return $this;\n    }\n    public function setClientIpAddress(string $clientIpAddress) : self\n    {\n        $this->clientIpAddress = $clientIpAddress;\n        return $this;\n    }\n    public function setUserAgent(string $userAgent) : self\n    {\n        $this->userAgent = $userAgent;\n        return $this;\n    }\n    \/**\n     * @throws Exception\n     *\/\n    public function begin(int $samplePercentage = 10) : Segment\n    {\n        parent::begin();\n        if (!isset($this->traceId)) {\n            $this->generateTraceId();\n        }\n        if (!$this->isSampled()) {\n            $this->sampled = random_int(0, 99) < $samplePercentage;\n        }\n        return $this;\n    }\n    \/**\n     * @inheritdoc\n     *\/\n    public function jsonSerialize() : array\n    {\n        $data = parent::jsonSerialize();\n        $data['http'] = $this->serialiseHttpData();\n        $data['service'] = empty($this->serviceVersion) ? null : ['version' => $this->serviceVersion];\n        $data['user'] = $this->user ?? null;\n        return array_filter($data);\n    }\n    \/**\n     * @throws Exception if an appropriate source of randomness cannot be found.\n     *\/\n    private function generateTraceId() : void\n    {\n        $startHex = dechex((int) $this->startTime);\n        $uuid = bin2hex(random_bytes(12));\n        $this->setTraceId(\"1-{$startHex}-{$uuid}\");\n    }\n}","mutatedSourceCode":"<?php\n\nnamespace Fido\\PHPXray;\n\nuse Exception;\nclass Trace extends Segment\n{\n    use HttpTrait;\n    private static self $instance;\n    private string $serviceVersion;\n    private string $user;\n    public static function getInstance() : self\n    {\n        if (!isset(self::$instance)) {\n            self::$instance = new self();\n        }\n        return self::$instance;\n    }\n    public function setServiceVersion(string $serviceVersion) : self\n    {\n        $this->serviceVersion = $serviceVersion;\n        return $this;\n    }\n    public function setUser(string $user) : self\n    {\n        $this->user = $user;\n        return $this;\n    }\n    public function setClientIpAddress(string $clientIpAddress) : self\n    {\n        $this->clientIpAddress = $clientIpAddress;\n        return $this;\n    }\n    public function setUserAgent(string $userAgent) : self\n    {\n        $this->userAgent = $userAgent;\n        return $this;\n    }\n    \/**\n     * @throws Exception\n     *\/\n    public function begin(int $samplePercentage = 10) : Segment\n    {\n        parent::begin();\n        if (!isset($this->traceId)) {\n            $this->generateTraceId();\n        }\n        if (!$this->isSampled()) {\n            $this->sampled = random_int(0, 99) < $samplePercentage;\n        }\n        return $this;\n    }\n    \/**\n     * @inheritdoc\n     *\/\n    public function jsonSerialize() : array\n    {\n        $data = parent::jsonSerialize();\n        $data['http'] = $this->serialiseHttpData();\n        $data['service'] = empty($this->serviceVersion) ? null : ['version' => $this->serviceVersion];\n        $data['user'] = $this->user ?? null;\n        return array_filter($data);\n    }\n    \/**\n     * @throws Exception if an appropriate source of randomness cannot be found.\n     *\/\n    private function generateTraceId() : void\n    {\n        $startHex = dechex((int) $this->startTime);\n        $uuid = bin2hex(random_bytes(13));\n        $this->setTraceId(\"1-{$startHex}-{$uuid}\");\n    }\n}","originalFilePath":"\/home\/ranpafin\/php-xray\/src\/Trace.php","originalStartLine":90},"diff":"--- Original\n+++ New\n@@ @@\n     private function generateTraceId() : void\n     {\n         $startHex = dechex((int) $this->startTime);\n-        $uuid = bin2hex(random_bytes(12));\n+        $uuid = bin2hex(random_bytes(13));\n         $this->setTraceId(\"1-{$startHex}-{$uuid}\");\n     }\n }","processOutput":"PHPUnit 9.5.10 by Sebastian Bergmann and contributors.\n\nRuntime:       PHP 8.0.13\nConfiguration: \/tmp\/tmp-folder\/infection\/phpunitConfiguration.6324c0e3ddadc87b5eb1b1f42fb951d9.infection.xml\n\nE\n\nTime: 00:00.002, Memory: 8.00 MB\n\nThere was 1 error:\n\n1) Fido\\PHPXray\\DaemonSegmentSubmitterTest::testSubmitsToDaemon\nsocket_bind(): Unable to bind address [98]: Address already in use\n\n\/home\/ranpafin\/php-xray\/tests\/DaemonSegmentSubmitterTest.php:18\n\nERRORS!\nTests: 1, Assertions: 0, Errors: 1."},{"mutator":{"mutatorName":"MethodCallRemoval","originalSourceCode":"<?php\n\nnamespace Fido\\PHPXray;\n\nuse Exception;\nclass Trace extends Segment\n{\n    use HttpTrait;\n    private static self $instance;\n    private string $serviceVersion;\n    private string $user;\n    public static function getInstance() : self\n    {\n        if (!isset(self::$instance)) {\n            self::$instance = new self();\n        }\n        return self::$instance;\n    }\n    public function setServiceVersion(string $serviceVersion) : self\n    {\n        $this->serviceVersion = $serviceVersion;\n        return $this;\n    }\n    public function setUser(string $user) : self\n    {\n        $this->user = $user;\n        return $this;\n    }\n    public function setClientIpAddress(string $clientIpAddress) : self\n    {\n        $this->clientIpAddress = $clientIpAddress;\n        return $this;\n    }\n    public function setUserAgent(string $userAgent) : self\n    {\n        $this->userAgent = $userAgent;\n        return $this;\n    }\n    \/**\n     * @throws Exception\n     *\/\n    public function begin(int $samplePercentage = 10) : Segment\n    {\n        parent::begin();\n        if (!isset($this->traceId)) {\n            $this->generateTraceId();\n        }\n        if (!$this->isSampled()) {\n            $this->sampled = random_int(0, 99) < $samplePercentage;\n        }\n        return $this;\n    }\n    \/**\n     * @inheritdoc\n     *\/\n    public function jsonSerialize() : array\n    {\n        $data = parent::jsonSerialize();\n        $data['http'] = $this->serialiseHttpData();\n        $data['service'] = empty($this->serviceVersion) ? null : ['version' => $this->serviceVersion];\n        $data['user'] = $this->user ?? null;\n        return array_filter($data);\n    }\n    \/**\n     * @throws Exception if an appropriate source of randomness cannot be found.\n     *\/\n    private function generateTraceId() : void\n    {\n        $startHex = dechex((int) $this->startTime);\n        $uuid = bin2hex(random_bytes(12));\n        $this->setTraceId(\"1-{$startHex}-{$uuid}\");\n    }\n}","mutatedSourceCode":"<?php\n\nnamespace Fido\\PHPXray;\n\nuse Exception;\nclass Trace extends Segment\n{\n    use HttpTrait;\n    private static self $instance;\n    private string $serviceVersion;\n    private string $user;\n    public static function getInstance() : self\n    {\n        if (!isset(self::$instance)) {\n            self::$instance = new self();\n        }\n        return self::$instance;\n    }\n    public function setServiceVersion(string $serviceVersion) : self\n    {\n        $this->serviceVersion = $serviceVersion;\n        return $this;\n    }\n    public function setUser(string $user) : self\n    {\n        $this->user = $user;\n        return $this;\n    }\n    public function setClientIpAddress(string $clientIpAddress) : self\n    {\n        $this->clientIpAddress = $clientIpAddress;\n        return $this;\n    }\n    public function setUserAgent(string $userAgent) : self\n    {\n        $this->userAgent = $userAgent;\n        return $this;\n    }\n    \/**\n     * @throws Exception\n     *\/\n    public function begin(int $samplePercentage = 10) : Segment\n    {\n        parent::begin();\n        if (!isset($this->traceId)) {\n            $this->generateTraceId();\n        }\n        if (!$this->isSampled()) {\n            $this->sampled = random_int(0, 99) < $samplePercentage;\n        }\n        return $this;\n    }\n    \/**\n     * @inheritdoc\n     *\/\n    public function jsonSerialize() : array\n    {\n        $data = parent::jsonSerialize();\n        $data['http'] = $this->serialiseHttpData();\n        $data['service'] = empty($this->serviceVersion) ? null : ['version' => $this->serviceVersion];\n        $data['user'] = $this->user ?? null;\n        return array_filter($data);\n    }\n    \/**\n     * @throws Exception if an appropriate source of randomness cannot be found.\n     *\/\n    private function generateTraceId() : void\n    {\n        $startHex = dechex((int) $this->startTime);\n        $uuid = bin2hex(random_bytes(12));\n        \n    }\n}","originalFilePath":"\/home\/ranpafin\/php-xray\/src\/Trace.php","originalStartLine":91},"diff":"--- Original\n+++ New\n@@ @@\n     {\n         $startHex = dechex((int) $this->startTime);\n         $uuid = bin2hex(random_bytes(12));\n-        $this->setTraceId(\"1-{$startHex}-{$uuid}\");\n+        \n     }\n }","processOutput":"PHPUnit 9.5.10 by Sebastian Bergmann and contributors.\n\nRuntime:       PHP 8.0.13\nConfiguration: \/tmp\/tmp-folder\/infection\/phpunitConfiguration.cf02a74fcf616c69489416b231ddd42d.infection.xml\n\nE\n\nTime: 00:00.002, Memory: 8.00 MB\n\nThere was 1 error:\n\n1) Fido\\PHPXray\\DaemonSegmentSubmitterTest::testSubmitsToDaemon\nsocket_bind(): Unable to bind address [98]: Address already in use\n\n\/home\/ranpafin\/php-xray\/tests\/DaemonSegmentSubmitterTest.php:18\n\nERRORS!\nTests: 1, Assertions: 0, Errors: 1."}],"errored":[],"syntaxErrors":[],"uncovered":[{"mutator":{"mutatorName":"Concat","originalSourceCode":"<?php\n\nnamespace Fido\\PHPXray\\Submission;\n\nuse Error;\nuse Fido\\PHPXray\\Segment;\nuse Socket;\nuse function socket_create;\nuse function socket_last_error;\nclass DaemonSegmentSubmitter implements SegmentSubmitter\n{\n    protected const MAX_SEGMENT_SIZE = 64000;\n    \/**\n     * @var array<string, mixed>\n     *\/\n    public const HEADER = ['format' => 'json', 'version' => 1];\n    private string $host;\n    private int $port;\n    \/** @var Socket *\/\n    private $socket;\n    public function __construct(string $host = '127.0.0.1', int $port = 2000)\n    {\n        if (isset($_SERVER['AWS_XRAY_DAEMON_ADDRESS'])) {\n            [$host, $port] = explode(\":\", $_SERVER['AWS_XRAY_DAEMON_ADDRESS']);\n        }\n        $this->host = $_SERVER['_AWS_XRAY_DAEMON_ADDRESS'] ?? $host;\n        $this->port = (int) ($_SERVER['_AWS_XRAY_DAEMON_PORT'] ?? $port);\n        if (!($socket = socket_create(AF_INET, SOCK_DGRAM, SOL_UDP))) {\n            throw new Error('Can\\'t create socket: ' . socket_last_error());\n        }\n        $this->socket = $socket;\n    }\n    public function __destruct()\n    {\n        socket_close($this->socket);\n    }\n    public function submitSegment(Segment $segment) : void\n    {\n        $packet = $this->buildPacket($segment);\n        $packetLength = strlen($packet);\n        if ($packetLength > self::MAX_SEGMENT_SIZE) {\n            $this->submitFragmented($segment);\n            return;\n        }\n        $this->sendPacket($packet);\n    }\n    \/**\n     * @param Segment|array<string, mixed> $segment\n     *\/\n    private function buildPacket(Segment|array $segment) : string\n    {\n        return implode(\"\\n\", array_map('json_encode', [self::HEADER, $segment]));\n    }\n    private function sendPacket(string $packet) : void\n    {\n        socket_sendto($this->socket, $packet, strlen($packet), 0, $this->host, $this->port);\n    }\n    private function submitFragmented(Segment $segment) : void\n    {\n        $rawSegment = $segment->jsonSerialize();\n        \/** @var Segment[] $subsegments *\/\n        $subsegments = $rawSegment['subsegments'] ?? [];\n        unset($rawSegment['subsegments']);\n        $this->submitOpenSegment($rawSegment);\n        foreach ($subsegments as $subsegment) {\n            $subsegment = clone $subsegment;\n            $subsegment->setParentId($segment->getId())->setTraceId($segment->getTraceId())->setIndependent(true);\n            $this->submitSegment($subsegment);\n        }\n        $completePacket = $this->buildPacket($rawSegment);\n        $this->sendPacket($completePacket);\n    }\n    \/**\n     * @param array<string, mixed> $openSegment\n     *\/\n    private function submitOpenSegment(array $openSegment) : void\n    {\n        unset($openSegment['end_time']);\n        $openSegment['in_progress'] = true;\n        $this->sendPacket($this->buildPacket($openSegment));\n    }\n}","mutatedSourceCode":"<?php\n\nnamespace Fido\\PHPXray\\Submission;\n\nuse Error;\nuse Fido\\PHPXray\\Segment;\nuse Socket;\nuse function socket_create;\nuse function socket_last_error;\nclass DaemonSegmentSubmitter implements SegmentSubmitter\n{\n    protected const MAX_SEGMENT_SIZE = 64000;\n    \/**\n     * @var array<string, mixed>\n     *\/\n    public const HEADER = ['format' => 'json', 'version' => 1];\n    private string $host;\n    private int $port;\n    \/** @var Socket *\/\n    private $socket;\n    public function __construct(string $host = '127.0.0.1', int $port = 2000)\n    {\n        if (isset($_SERVER['AWS_XRAY_DAEMON_ADDRESS'])) {\n            [$host, $port] = explode(\":\", $_SERVER['AWS_XRAY_DAEMON_ADDRESS']);\n        }\n        $this->host = $_SERVER['_AWS_XRAY_DAEMON_ADDRESS'] ?? $host;\n        $this->port = (int) ($_SERVER['_AWS_XRAY_DAEMON_PORT'] ?? $port);\n        if (!($socket = socket_create(AF_INET, SOCK_DGRAM, SOL_UDP))) {\n            throw new Error(socket_last_error() . 'Can\\'t create socket: ');\n        }\n        $this->socket = $socket;\n    }\n    public function __destruct()\n    {\n        socket_close($this->socket);\n    }\n    public function submitSegment(Segment $segment) : void\n    {\n        $packet = $this->buildPacket($segment);\n        $packetLength = strlen($packet);\n        if ($packetLength > self::MAX_SEGMENT_SIZE) {\n            $this->submitFragmented($segment);\n            return;\n        }\n        $this->sendPacket($packet);\n    }\n    \/**\n     * @param Segment|array<string, mixed> $segment\n     *\/\n    private function buildPacket(Segment|array $segment) : string\n    {\n        return implode(\"\\n\", array_map('json_encode', [self::HEADER, $segment]));\n    }\n    private function sendPacket(string $packet) : void\n    {\n        socket_sendto($this->socket, $packet, strlen($packet), 0, $this->host, $this->port);\n    }\n    private function submitFragmented(Segment $segment) : void\n    {\n        $rawSegment = $segment->jsonSerialize();\n        \/** @var Segment[] $subsegments *\/\n        $subsegments = $rawSegment['subsegments'] ?? [];\n        unset($rawSegment['subsegments']);\n        $this->submitOpenSegment($rawSegment);\n        foreach ($subsegments as $subsegment) {\n            $subsegment = clone $subsegment;\n            $subsegment->setParentId($segment->getId())->setTraceId($segment->getTraceId())->setIndependent(true);\n            $this->submitSegment($subsegment);\n        }\n        $completePacket = $this->buildPacket($rawSegment);\n        $this->sendPacket($completePacket);\n    }\n    \/**\n     * @param array<string, mixed> $openSegment\n     *\/\n    private function submitOpenSegment(array $openSegment) : void\n    {\n        unset($openSegment['end_time']);\n        $openSegment['in_progress'] = true;\n        $this->sendPacket($this->buildPacket($openSegment));\n    }\n}","originalFilePath":"\/home\/ranpafin\/php-xray\/src\/Submission\/DaemonSegmentSubmitter.php","originalStartLine":38},"diff":"--- Original\n+++ New\n@@ @@\n         $this->host = $_SERVER['_AWS_XRAY_DAEMON_ADDRESS'] ?? $host;\n         $this->port = (int) ($_SERVER['_AWS_XRAY_DAEMON_PORT'] ?? $port);\n         if (!($socket = socket_create(AF_INET, SOCK_DGRAM, SOL_UDP))) {\n-            throw new Error('Can\\'t create socket: ' . socket_last_error());\n+            throw new Error(socket_last_error() . 'Can\\'t create socket: ');\n         }\n         $this->socket = $socket;\n     }","processOutput":""},{"mutator":{"mutatorName":"ConcatOperandRemoval","originalSourceCode":"<?php\n\nnamespace Fido\\PHPXray\\Submission;\n\nuse Error;\nuse Fido\\PHPXray\\Segment;\nuse Socket;\nuse function socket_create;\nuse function socket_last_error;\nclass DaemonSegmentSubmitter implements SegmentSubmitter\n{\n    protected const MAX_SEGMENT_SIZE = 64000;\n    \/**\n     * @var array<string, mixed>\n     *\/\n    public const HEADER = ['format' => 'json', 'version' => 1];\n    private string $host;\n    private int $port;\n    \/** @var Socket *\/\n    private $socket;\n    public function __construct(string $host = '127.0.0.1', int $port = 2000)\n    {\n        if (isset($_SERVER['AWS_XRAY_DAEMON_ADDRESS'])) {\n            [$host, $port] = explode(\":\", $_SERVER['AWS_XRAY_DAEMON_ADDRESS']);\n        }\n        $this->host = $_SERVER['_AWS_XRAY_DAEMON_ADDRESS'] ?? $host;\n        $this->port = (int) ($_SERVER['_AWS_XRAY_DAEMON_PORT'] ?? $port);\n        if (!($socket = socket_create(AF_INET, SOCK_DGRAM, SOL_UDP))) {\n            throw new Error('Can\\'t create socket: ' . socket_last_error());\n        }\n        $this->socket = $socket;\n    }\n    public function __destruct()\n    {\n        socket_close($this->socket);\n    }\n    public function submitSegment(Segment $segment) : void\n    {\n        $packet = $this->buildPacket($segment);\n        $packetLength = strlen($packet);\n        if ($packetLength > self::MAX_SEGMENT_SIZE) {\n            $this->submitFragmented($segment);\n            return;\n        }\n        $this->sendPacket($packet);\n    }\n    \/**\n     * @param Segment|array<string, mixed> $segment\n     *\/\n    private function buildPacket(Segment|array $segment) : string\n    {\n        return implode(\"\\n\", array_map('json_encode', [self::HEADER, $segment]));\n    }\n    private function sendPacket(string $packet) : void\n    {\n        socket_sendto($this->socket, $packet, strlen($packet), 0, $this->host, $this->port);\n    }\n    private function submitFragmented(Segment $segment) : void\n    {\n        $rawSegment = $segment->jsonSerialize();\n        \/** @var Segment[] $subsegments *\/\n        $subsegments = $rawSegment['subsegments'] ?? [];\n        unset($rawSegment['subsegments']);\n        $this->submitOpenSegment($rawSegment);\n        foreach ($subsegments as $subsegment) {\n            $subsegment = clone $subsegment;\n            $subsegment->setParentId($segment->getId())->setTraceId($segment->getTraceId())->setIndependent(true);\n            $this->submitSegment($subsegment);\n        }\n        $completePacket = $this->buildPacket($rawSegment);\n        $this->sendPacket($completePacket);\n    }\n    \/**\n     * @param array<string, mixed> $openSegment\n     *\/\n    private function submitOpenSegment(array $openSegment) : void\n    {\n        unset($openSegment['end_time']);\n        $openSegment['in_progress'] = true;\n        $this->sendPacket($this->buildPacket($openSegment));\n    }\n}","mutatedSourceCode":"<?php\n\nnamespace Fido\\PHPXray\\Submission;\n\nuse Error;\nuse Fido\\PHPXray\\Segment;\nuse Socket;\nuse function socket_create;\nuse function socket_last_error;\nclass DaemonSegmentSubmitter implements SegmentSubmitter\n{\n    protected const MAX_SEGMENT_SIZE = 64000;\n    \/**\n     * @var array<string, mixed>\n     *\/\n    public const HEADER = ['format' => 'json', 'version' => 1];\n    private string $host;\n    private int $port;\n    \/** @var Socket *\/\n    private $socket;\n    public function __construct(string $host = '127.0.0.1', int $port = 2000)\n    {\n        if (isset($_SERVER['AWS_XRAY_DAEMON_ADDRESS'])) {\n            [$host, $port] = explode(\":\", $_SERVER['AWS_XRAY_DAEMON_ADDRESS']);\n        }\n        $this->host = $_SERVER['_AWS_XRAY_DAEMON_ADDRESS'] ?? $host;\n        $this->port = (int) ($_SERVER['_AWS_XRAY_DAEMON_PORT'] ?? $port);\n        if (!($socket = socket_create(AF_INET, SOCK_DGRAM, SOL_UDP))) {\n            throw new Error(socket_last_error());\n        }\n        $this->socket = $socket;\n    }\n    public function __destruct()\n    {\n        socket_close($this->socket);\n    }\n    public function submitSegment(Segment $segment) : void\n    {\n        $packet = $this->buildPacket($segment);\n        $packetLength = strlen($packet);\n        if ($packetLength > self::MAX_SEGMENT_SIZE) {\n            $this->submitFragmented($segment);\n            return;\n        }\n        $this->sendPacket($packet);\n    }\n    \/**\n     * @param Segment|array<string, mixed> $segment\n     *\/\n    private function buildPacket(Segment|array $segment) : string\n    {\n        return implode(\"\\n\", array_map('json_encode', [self::HEADER, $segment]));\n    }\n    private function sendPacket(string $packet) : void\n    {\n        socket_sendto($this->socket, $packet, strlen($packet), 0, $this->host, $this->port);\n    }\n    private function submitFragmented(Segment $segment) : void\n    {\n        $rawSegment = $segment->jsonSerialize();\n        \/** @var Segment[] $subsegments *\/\n        $subsegments = $rawSegment['subsegments'] ?? [];\n        unset($rawSegment['subsegments']);\n        $this->submitOpenSegment($rawSegment);\n        foreach ($subsegments as $subsegment) {\n            $subsegment = clone $subsegment;\n            $subsegment->setParentId($segment->getId())->setTraceId($segment->getTraceId())->setIndependent(true);\n            $this->submitSegment($subsegment);\n        }\n        $completePacket = $this->buildPacket($rawSegment);\n        $this->sendPacket($completePacket);\n    }\n    \/**\n     * @param array<string, mixed> $openSegment\n     *\/\n    private function submitOpenSegment(array $openSegment) : void\n    {\n        unset($openSegment['end_time']);\n        $openSegment['in_progress'] = true;\n        $this->sendPacket($this->buildPacket($openSegment));\n    }\n}","originalFilePath":"\/home\/ranpafin\/php-xray\/src\/Submission\/DaemonSegmentSubmitter.php","originalStartLine":38},"diff":"--- Original\n+++ New\n@@ @@\n         $this->host = $_SERVER['_AWS_XRAY_DAEMON_ADDRESS'] ?? $host;\n         $this->port = (int) ($_SERVER['_AWS_XRAY_DAEMON_PORT'] ?? $port);\n         if (!($socket = socket_create(AF_INET, SOCK_DGRAM, SOL_UDP))) {\n-            throw new Error('Can\\'t create socket: ' . socket_last_error());\n+            throw new Error(socket_last_error());\n         }\n         $this->socket = $socket;\n     }","processOutput":""},{"mutator":{"mutatorName":"ConcatOperandRemoval","originalSourceCode":"<?php\n\nnamespace Fido\\PHPXray\\Submission;\n\nuse Error;\nuse Fido\\PHPXray\\Segment;\nuse Socket;\nuse function socket_create;\nuse function socket_last_error;\nclass DaemonSegmentSubmitter implements SegmentSubmitter\n{\n    protected const MAX_SEGMENT_SIZE = 64000;\n    \/**\n     * @var array<string, mixed>\n     *\/\n    public const HEADER = ['format' => 'json', 'version' => 1];\n    private string $host;\n    private int $port;\n    \/** @var Socket *\/\n    private $socket;\n    public function __construct(string $host = '127.0.0.1', int $port = 2000)\n    {\n        if (isset($_SERVER['AWS_XRAY_DAEMON_ADDRESS'])) {\n            [$host, $port] = explode(\":\", $_SERVER['AWS_XRAY_DAEMON_ADDRESS']);\n        }\n        $this->host = $_SERVER['_AWS_XRAY_DAEMON_ADDRESS'] ?? $host;\n        $this->port = (int) ($_SERVER['_AWS_XRAY_DAEMON_PORT'] ?? $port);\n        if (!($socket = socket_create(AF_INET, SOCK_DGRAM, SOL_UDP))) {\n            throw new Error('Can\\'t create socket: ' . socket_last_error());\n        }\n        $this->socket = $socket;\n    }\n    public function __destruct()\n    {\n        socket_close($this->socket);\n    }\n    public function submitSegment(Segment $segment) : void\n    {\n        $packet = $this->buildPacket($segment);\n        $packetLength = strlen($packet);\n        if ($packetLength > self::MAX_SEGMENT_SIZE) {\n            $this->submitFragmented($segment);\n            return;\n        }\n        $this->sendPacket($packet);\n    }\n    \/**\n     * @param Segment|array<string, mixed> $segment\n     *\/\n    private function buildPacket(Segment|array $segment) : string\n    {\n        return implode(\"\\n\", array_map('json_encode', [self::HEADER, $segment]));\n    }\n    private function sendPacket(string $packet) : void\n    {\n        socket_sendto($this->socket, $packet, strlen($packet), 0, $this->host, $this->port);\n    }\n    private function submitFragmented(Segment $segment) : void\n    {\n        $rawSegment = $segment->jsonSerialize();\n        \/** @var Segment[] $subsegments *\/\n        $subsegments = $rawSegment['subsegments'] ?? [];\n        unset($rawSegment['subsegments']);\n        $this->submitOpenSegment($rawSegment);\n        foreach ($subsegments as $subsegment) {\n            $subsegment = clone $subsegment;\n            $subsegment->setParentId($segment->getId())->setTraceId($segment->getTraceId())->setIndependent(true);\n            $this->submitSegment($subsegment);\n        }\n        $completePacket = $this->buildPacket($rawSegment);\n        $this->sendPacket($completePacket);\n    }\n    \/**\n     * @param array<string, mixed> $openSegment\n     *\/\n    private function submitOpenSegment(array $openSegment) : void\n    {\n        unset($openSegment['end_time']);\n        $openSegment['in_progress'] = true;\n        $this->sendPacket($this->buildPacket($openSegment));\n    }\n}","mutatedSourceCode":"<?php\n\nnamespace Fido\\PHPXray\\Submission;\n\nuse Error;\nuse Fido\\PHPXray\\Segment;\nuse Socket;\nuse function socket_create;\nuse function socket_last_error;\nclass DaemonSegmentSubmitter implements SegmentSubmitter\n{\n    protected const MAX_SEGMENT_SIZE = 64000;\n    \/**\n     * @var array<string, mixed>\n     *\/\n    public const HEADER = ['format' => 'json', 'version' => 1];\n    private string $host;\n    private int $port;\n    \/** @var Socket *\/\n    private $socket;\n    public function __construct(string $host = '127.0.0.1', int $port = 2000)\n    {\n        if (isset($_SERVER['AWS_XRAY_DAEMON_ADDRESS'])) {\n            [$host, $port] = explode(\":\", $_SERVER['AWS_XRAY_DAEMON_ADDRESS']);\n        }\n        $this->host = $_SERVER['_AWS_XRAY_DAEMON_ADDRESS'] ?? $host;\n        $this->port = (int) ($_SERVER['_AWS_XRAY_DAEMON_PORT'] ?? $port);\n        if (!($socket = socket_create(AF_INET, SOCK_DGRAM, SOL_UDP))) {\n            throw new Error('Can\\'t create socket: ');\n        }\n        $this->socket = $socket;\n    }\n    public function __destruct()\n    {\n        socket_close($this->socket);\n    }\n    public function submitSegment(Segment $segment) : void\n    {\n        $packet = $this->buildPacket($segment);\n        $packetLength = strlen($packet);\n        if ($packetLength > self::MAX_SEGMENT_SIZE) {\n            $this->submitFragmented($segment);\n            return;\n        }\n        $this->sendPacket($packet);\n    }\n    \/**\n     * @param Segment|array<string, mixed> $segment\n     *\/\n    private function buildPacket(Segment|array $segment) : string\n    {\n        return implode(\"\\n\", array_map('json_encode', [self::HEADER, $segment]));\n    }\n    private function sendPacket(string $packet) : void\n    {\n        socket_sendto($this->socket, $packet, strlen($packet), 0, $this->host, $this->port);\n    }\n    private function submitFragmented(Segment $segment) : void\n    {\n        $rawSegment = $segment->jsonSerialize();\n        \/** @var Segment[] $subsegments *\/\n        $subsegments = $rawSegment['subsegments'] ?? [];\n        unset($rawSegment['subsegments']);\n        $this->submitOpenSegment($rawSegment);\n        foreach ($subsegments as $subsegment) {\n            $subsegment = clone $subsegment;\n            $subsegment->setParentId($segment->getId())->setTraceId($segment->getTraceId())->setIndependent(true);\n            $this->submitSegment($subsegment);\n        }\n        $completePacket = $this->buildPacket($rawSegment);\n        $this->sendPacket($completePacket);\n    }\n    \/**\n     * @param array<string, mixed> $openSegment\n     *\/\n    private function submitOpenSegment(array $openSegment) : void\n    {\n        unset($openSegment['end_time']);\n        $openSegment['in_progress'] = true;\n        $this->sendPacket($this->buildPacket($openSegment));\n    }\n}","originalFilePath":"\/home\/ranpafin\/php-xray\/src\/Submission\/DaemonSegmentSubmitter.php","originalStartLine":38},"diff":"--- Original\n+++ New\n@@ @@\n         $this->host = $_SERVER['_AWS_XRAY_DAEMON_ADDRESS'] ?? $host;\n         $this->port = (int) ($_SERVER['_AWS_XRAY_DAEMON_PORT'] ?? $port);\n         if (!($socket = socket_create(AF_INET, SOCK_DGRAM, SOL_UDP))) {\n-            throw new Error('Can\\'t create socket: ' . socket_last_error());\n+            throw new Error('Can\\'t create socket: ');\n         }\n         $this->socket = $socket;\n     }","processOutput":""},{"mutator":{"mutatorName":"Throw_","originalSourceCode":"<?php\n\nnamespace Fido\\PHPXray\\Submission;\n\nuse Error;\nuse Fido\\PHPXray\\Segment;\nuse Socket;\nuse function socket_create;\nuse function socket_last_error;\nclass DaemonSegmentSubmitter implements SegmentSubmitter\n{\n    protected const MAX_SEGMENT_SIZE = 64000;\n    \/**\n     * @var array<string, mixed>\n     *\/\n    public const HEADER = ['format' => 'json', 'version' => 1];\n    private string $host;\n    private int $port;\n    \/** @var Socket *\/\n    private $socket;\n    public function __construct(string $host = '127.0.0.1', int $port = 2000)\n    {\n        if (isset($_SERVER['AWS_XRAY_DAEMON_ADDRESS'])) {\n            [$host, $port] = explode(\":\", $_SERVER['AWS_XRAY_DAEMON_ADDRESS']);\n        }\n        $this->host = $_SERVER['_AWS_XRAY_DAEMON_ADDRESS'] ?? $host;\n        $this->port = (int) ($_SERVER['_AWS_XRAY_DAEMON_PORT'] ?? $port);\n        if (!($socket = socket_create(AF_INET, SOCK_DGRAM, SOL_UDP))) {\n            throw new Error('Can\\'t create socket: ' . socket_last_error());\n        }\n        $this->socket = $socket;\n    }\n    public function __destruct()\n    {\n        socket_close($this->socket);\n    }\n    public function submitSegment(Segment $segment) : void\n    {\n        $packet = $this->buildPacket($segment);\n        $packetLength = strlen($packet);\n        if ($packetLength > self::MAX_SEGMENT_SIZE) {\n            $this->submitFragmented($segment);\n            return;\n        }\n        $this->sendPacket($packet);\n    }\n    \/**\n     * @param Segment|array<string, mixed> $segment\n     *\/\n    private function buildPacket(Segment|array $segment) : string\n    {\n        return implode(\"\\n\", array_map('json_encode', [self::HEADER, $segment]));\n    }\n    private function sendPacket(string $packet) : void\n    {\n        socket_sendto($this->socket, $packet, strlen($packet), 0, $this->host, $this->port);\n    }\n    private function submitFragmented(Segment $segment) : void\n    {\n        $rawSegment = $segment->jsonSerialize();\n        \/** @var Segment[] $subsegments *\/\n        $subsegments = $rawSegment['subsegments'] ?? [];\n        unset($rawSegment['subsegments']);\n        $this->submitOpenSegment($rawSegment);\n        foreach ($subsegments as $subsegment) {\n            $subsegment = clone $subsegment;\n            $subsegment->setParentId($segment->getId())->setTraceId($segment->getTraceId())->setIndependent(true);\n            $this->submitSegment($subsegment);\n        }\n        $completePacket = $this->buildPacket($rawSegment);\n        $this->sendPacket($completePacket);\n    }\n    \/**\n     * @param array<string, mixed> $openSegment\n     *\/\n    private function submitOpenSegment(array $openSegment) : void\n    {\n        unset($openSegment['end_time']);\n        $openSegment['in_progress'] = true;\n        $this->sendPacket($this->buildPacket($openSegment));\n    }\n}","mutatedSourceCode":"<?php\n\nnamespace Fido\\PHPXray\\Submission;\n\nuse Error;\nuse Fido\\PHPXray\\Segment;\nuse Socket;\nuse function socket_create;\nuse function socket_last_error;\nclass DaemonSegmentSubmitter implements SegmentSubmitter\n{\n    protected const MAX_SEGMENT_SIZE = 64000;\n    \/**\n     * @var array<string, mixed>\n     *\/\n    public const HEADER = ['format' => 'json', 'version' => 1];\n    private string $host;\n    private int $port;\n    \/** @var Socket *\/\n    private $socket;\n    public function __construct(string $host = '127.0.0.1', int $port = 2000)\n    {\n        if (isset($_SERVER['AWS_XRAY_DAEMON_ADDRESS'])) {\n            [$host, $port] = explode(\":\", $_SERVER['AWS_XRAY_DAEMON_ADDRESS']);\n        }\n        $this->host = $_SERVER['_AWS_XRAY_DAEMON_ADDRESS'] ?? $host;\n        $this->port = (int) ($_SERVER['_AWS_XRAY_DAEMON_PORT'] ?? $port);\n        if (!($socket = socket_create(AF_INET, SOCK_DGRAM, SOL_UDP))) {\n            new Error('Can\\'t create socket: ' . socket_last_error());\n        }\n        $this->socket = $socket;\n    }\n    public function __destruct()\n    {\n        socket_close($this->socket);\n    }\n    public function submitSegment(Segment $segment) : void\n    {\n        $packet = $this->buildPacket($segment);\n        $packetLength = strlen($packet);\n        if ($packetLength > self::MAX_SEGMENT_SIZE) {\n            $this->submitFragmented($segment);\n            return;\n        }\n        $this->sendPacket($packet);\n    }\n    \/**\n     * @param Segment|array<string, mixed> $segment\n     *\/\n    private function buildPacket(Segment|array $segment) : string\n    {\n        return implode(\"\\n\", array_map('json_encode', [self::HEADER, $segment]));\n    }\n    private function sendPacket(string $packet) : void\n    {\n        socket_sendto($this->socket, $packet, strlen($packet), 0, $this->host, $this->port);\n    }\n    private function submitFragmented(Segment $segment) : void\n    {\n        $rawSegment = $segment->jsonSerialize();\n        \/** @var Segment[] $subsegments *\/\n        $subsegments = $rawSegment['subsegments'] ?? [];\n        unset($rawSegment['subsegments']);\n        $this->submitOpenSegment($rawSegment);\n        foreach ($subsegments as $subsegment) {\n            $subsegment = clone $subsegment;\n            $subsegment->setParentId($segment->getId())->setTraceId($segment->getTraceId())->setIndependent(true);\n            $this->submitSegment($subsegment);\n        }\n        $completePacket = $this->buildPacket($rawSegment);\n        $this->sendPacket($completePacket);\n    }\n    \/**\n     * @param array<string, mixed> $openSegment\n     *\/\n    private function submitOpenSegment(array $openSegment) : void\n    {\n        unset($openSegment['end_time']);\n        $openSegment['in_progress'] = true;\n        $this->sendPacket($this->buildPacket($openSegment));\n    }\n}","originalFilePath":"\/home\/ranpafin\/php-xray\/src\/Submission\/DaemonSegmentSubmitter.php","originalStartLine":38},"diff":"--- Original\n+++ New\n@@ @@\n         $this->host = $_SERVER['_AWS_XRAY_DAEMON_ADDRESS'] ?? $host;\n         $this->port = (int) ($_SERVER['_AWS_XRAY_DAEMON_PORT'] ?? $port);\n         if (!($socket = socket_create(AF_INET, SOCK_DGRAM, SOL_UDP))) {\n-            throw new Error('Can\\'t create socket: ' . socket_last_error());\n+            new Error('Can\\'t create socket: ' . socket_last_error());\n         }\n         $this->socket = $socket;\n     }","processOutput":""}]}